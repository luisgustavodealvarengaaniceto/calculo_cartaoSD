// Main Application Logic
let currentModel = null;
let currentConfig = null;
let recordingChart = null;
const currentLang = 'pt-BR'; // Fixed to Portuguese

// Simple translation function (Portuguese only)
function t(key) {
    const translations = {
        'configuration': 'Configuração',
        'fixed_configuration': 'Configuração Fixa',
        'resolution': 'Resolução',
        'fps': 'FPS (Quadros/seg)',
        'bitrate': 'Bitrate (Mbps)',
        'codec': 'Codec',
        'hours': 'horas',
        'days': 'dias',
        'cardCapacity': 'Capacidade do Cartão',
        'usableCapacity': 'Espaço Útil',
        'activeChannelsCount': 'Canais Ativos'
    };
    return translations[key] || key;
}

// DOM Elements
const modelCards = document.querySelectorAll('.model-card');
const configSection = document.getElementById('configSection');
const resultsSection = document.getElementById('resultsSection');
const cardSizeSelect = document.getElementById('cardSize');
const channelCountInput = document.getElementById('channelCount');
const channelConfigDiv = document.getElementById('channelConfig');
const calculateBtn = document.getElementById('calculateBtn');
const resetBtn = document.getElementById('resetBtn');
const presetSection = document.getElementById('presetSection');
const presetsContainer = document.getElementById('presetsContainer');
const customConfigBtn = document.getElementById('customConfigBtn');
const manualConfigSection = document.getElementById('manualConfigSection');
const manualModeBtn = document.getElementById('manualModeBtn');
const autoModeBtn = document.getElementById('autoModeBtn');
const autoModePanel = document.getElementById('autoModePanel');
const manualConfigPanel = document.getElementById('manualConfigPanel');
const desiredDaysInput = document.getElementById('desiredDays');
const desiredHoursInput = document.getElementById('desiredHours');
const totalDesiredTimeSpan = document.getElementById('totalDesiredTime');
const generateConfigBtn = document.getElementById('generateConfigBtn');
const cardCountSelector = document.getElementById('cardCountSelector');
const oneCardBtn = document.getElementById('oneCardBtn');
const twoCardsBtn = document.getElementById('twoCardsBtn');
const recommendedSection = document.getElementById('recommendedSection');
const recommendedAlternatives = document.getElementById('recommendedAlternatives');
const channelPriorityDiv = document.getElementById('channelPriorityDiv');
const channelPrioritySelect = document.getElementById('channelPriority');

// State
let isReverseCalcMode = false;
let autoGeneratedConfig = null;
let lastTargetBitrate = null; // Store for recommended alternatives
let lastDesiredHours = null; // Store for recommended alternatives
let useOneCardOnly = false; // For JC450: default is 2 cards
let selectedPriorityChannel = 'equal'; // Default: all channels equal

// Initialize Application
function init() {
    console.log('Initializing DVR Calculator...');
    attachEventListeners();
    
    // Don't load saved state on first init - let user select model
    // loadSavedState();
    
    console.log('DVR Calculator initialized successfully');
}

// Attach Event Listeners
function attachEventListeners() {
    modelCards.forEach(card => {
        card.addEventListener('click', () => selectModel(card.dataset.model));
    });
    
    if (calculateBtn) calculateBtn.addEventListener('click', calculateRecording);
    if (resetBtn) resetBtn.addEventListener('click', resetCalculator);
    
    if (channelCountInput) {
        channelCountInput.addEventListener('change', updateChannelConfig);
    }
    if (cardSizeSelect) {
        cardSizeSelect.addEventListener('change', saveState);
    }
    
    // Mode toggle buttons
    if (manualModeBtn) {
        manualModeBtn.addEventListener('click', () => switchToManualMode());
    }
    if (autoModeBtn) {
        autoModeBtn.addEventListener('click', () => switchToAutoMode());
    }
    
    // Auto mode inputs
    if (desiredDaysInput) {
        desiredDaysInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (desiredHoursInput) {
        desiredHoursInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (generateConfigBtn) {
        console.log('Generate config button found, attaching listener...');
        generateConfigBtn.addEventListener('click', generateAutoConfig);
    } else {
        console.warn('Generate config button NOT found!');
    }
    
    // Card count buttons for JC450
    if (oneCardBtn) {
        oneCardBtn.addEventListener('click', () => selectCardCount(1));
    }
    if (twoCardsBtn) {
        twoCardsBtn.addEventListener('click', () => selectCardCount(2));
    }
    
    // Channel priority selector
    if (channelPrioritySelect) {
        channelPrioritySelect.addEventListener('change', (e) => {
            selectedPriorityChannel = e.target.value;
            console.log('Channel priority changed to:', selectedPriorityChannel);
        });
    }
    
    console.log('Event listeners attached');
}

// Select Card Count (for JC450)
function selectCardCount(cardCount) {
    useOneCardOnly = (cardCount === 1);
    
    // Update button states
    if (oneCardBtn && twoCardsBtn) {
        if (cardCount === 1) {
            oneCardBtn.classList.add('active');
            twoCardsBtn.classList.remove('active');
        } else {
            oneCardBtn.classList.remove('active');
            twoCardsBtn.classList.add('active');
        }
    }
    
    // Update card size options display
    updateCardSizeDisplay();
}

// Update Card Size Display
function updateCardSizeDisplay() {
    if (!currentModel) return;
    
    const cardSizeLabel = document.getElementById('cardSizeLabel');
    const cardSizeHint = document.getElementById('cardSizeHint');
    
    // Repopulate card sizes with updated labels
    cardSizeSelect.innerHTML = '';
    currentModel.cardSizes.forEach(size => {
        const option = document.createElement('option');
        option.value = size;
        
        if (currentModel.dualCard && !useOneCardOnly) {
            option.textContent = `${size} GB × 2 = ${size * 2} GB total`;
        } else {
            option.textContent = `${size} GB`;
        }
        cardSizeSelect.appendChild(option);
    });
    
    // Update label
    if (currentModel.dualCard) {
        if (useOneCardOnly) {
            if (cardSizeLabel) cardSizeLabel.textContent = 'Tamanho do Cartão SD (1 cartão)';
            if (cardSizeHint) {
                cardSizeHint.textContent = 'ℹ️ Usando apenas 1 cartão SD.';
                cardSizeHint.classList.remove('hidden');
            }
        } else {
            if (cardSizeLabel) cardSizeLabel.textContent = 'Capacidade por Cartão SD (2 cartões)';
            if (cardSizeHint) {
                cardSizeHint.textContent = '⚠️ JC450 utiliza 2 cartões SD. Selecione a capacidade de CADA cartão.';
                cardSizeHint.classList.remove('hidden');
            }
        }
    } else {
        if (cardSizeLabel) cardSizeLabel.textContent = 'Tamanho do Cartão SD';
        if (cardSizeHint) cardSizeHint.classList.add('hidden');
    }
}

// Warning Modal Functions
function showWarningModal(data) {
    const modal = document.getElementById('warningModal');
    const modalContent = document.getElementById('warningModalContent');
    const closeBtn = document.getElementById('warningModalClose');
    const changeCardBtn = document.getElementById('warningModalChangeCard');
    
    if (!modal || !modalContent) return;
    
    // Update modal content
    document.getElementById('warningDesiredTime').textContent = `${data.desiredHours.toFixed(1)} horas`;
    document.getElementById('warningDesiredDays').textContent = `(${data.desiredDays.toFixed(1)} dias)`;
    document.getElementById('warningCurrentCard').textContent = `${data.currentCard} GB`;
    document.getElementById('warningMaxTime').textContent = `${data.maxHours.toFixed(1)} horas`;
    document.getElementById('warningMaxDays').textContent = `(${data.maxDays.toFixed(1)} dias)`;
    document.getElementById('warningSolution').textContent = data.solution;
    
    // Show modal with animation
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    
    setTimeout(() => {
        modalContent.style.transform = 'scale(1)';
        modalContent.style.opacity = '1';
    }, 10);
    
    // Close button
    closeBtn.onclick = () => closeWarningModal();
    
    // Change card button - scroll to card size selector
    changeCardBtn.onclick = () => {
        closeWarningModal();
        cardSizeSelect.focus();
        cardSizeSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
    };
    
    // Close on backdrop click
    modal.onclick = (e) => {
        if (e.target === modal) {
            closeWarningModal();
        }
    };
}

function closeWarningModal() {
    const modal = document.getElementById('warningModal');
    const modalContent = document.getElementById('warningModalContent');
    
    if (!modal || !modalContent) return;
    
    modalContent.style.transform = 'scale(0.95)';
    modalContent.style.opacity = '0';
    
    setTimeout(() => {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }, 200);
}

// Switch to Manual Mode
function switchToManualMode() {
    isReverseCalcMode = false;
    
    // Update button states
    if (manualModeBtn) {
        manualModeBtn.classList.add('active');
    }
    if (autoModeBtn) {
        autoModeBtn.classList.remove('active');
    }
    
    // Show/hide panels
    if (autoModePanel) {
        autoModePanel.classList.add('hidden');
    }
    if (manualConfigPanel) {
        manualConfigPanel.classList.remove('hidden');
    }
    
    // Re-setup manual configuration if coming back from auto mode
    if (currentModel && channelConfigDiv) {
        channelConfigDiv.style.display = 'block';
        // Check if we need to re-create the channel configs
        const existingCards = channelConfigDiv.querySelectorAll('.channel-config-card');
        if (existingCards.length === 0) {
            setupManualConfiguration();
        }
    }
    
    // Show calculate button in manual mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection && currentModel) {
        calculateButtonSection.classList.remove('hidden');
    }
    
    // Clear results
    resultsSection.classList.add('hidden');
}

// Switch to Auto Mode
function switchToAutoMode() {
    isReverseCalcMode = true;
    
    // Update button states
    if (manualModeBtn) {
        manualModeBtn.classList.remove('active');
    }
    if (autoModeBtn) {
        autoModeBtn.classList.add('active');
    }
    
    // Show/hide panels
    if (autoModePanel) {
        autoModePanel.classList.remove('hidden');
    }
    if (manualConfigPanel) {
        manualConfigPanel.classList.add('hidden');
    }
    if (channelConfigDiv) {
        channelConfigDiv.style.display = 'block'; // Show to display suggestions
        channelConfigDiv.innerHTML = '<div class="text-center text-gray-500 p-8">' +
            '<i class="fas fa-arrow-left text-4xl mb-4"></i>' +
            '<p>' + (currentLang === 'pt-BR' 
                ? 'Configure o tempo desejado e clique em "Gerar Configurações Automáticas"' 
                : 'Set desired time and click "Generate Automatic Configurations"') +
            '</p></div>';
    }
    
    // Hide calculate button in auto mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection) {
        calculateButtonSection.classList.add('hidden');
    }
    
    // Clear results
    resultsSection.classList.add('hidden');
    
    // Update total time display
    updateTotalDesiredTime();
}

// Select Model
function selectModel(modelName) {
    console.log('selectModel called with:', modelName);
    
    if (!isValidModel(modelName)) {
        console.error('Invalid model:', modelName);
        return;
    }
    
    currentModel = getModelConfig(modelName);
    console.log('Current model set to:', currentModel);
    
    // Update UI
    modelCards.forEach(card => {
        card.classList.remove('active');
        if (card.dataset.model === modelName) {
            card.classList.add('active');
        }
    });
    
    // Show configuration section
    configSection.classList.remove('hidden');
    resultsSection.classList.add('hidden');
    
    // Initialize in manual mode by default
    switchToManualMode();
    
    // Initialize configuration
    initializeConfiguration();
    saveState();
}

// Initialize Configuration
function initializeConfiguration() {
    console.log('initializeConfiguration called');
    console.log('currentModel:', currentModel);
    console.log('cardSizeSelect:', cardSizeSelect);
    
    // Reset to default (2 cards for JC450)
    useOneCardOnly = false;
    
    // Show/hide card count selector for JC450
    if (cardCountSelector) {
        if (currentModel.dualCard) {
            cardCountSelector.classList.remove('hidden');
            // Reset buttons to 2 cards (default)
            if (oneCardBtn) oneCardBtn.classList.remove('active');
            if (twoCardsBtn) twoCardsBtn.classList.add('active');
        } else {
            cardCountSelector.classList.add('hidden');
        }
    }
    
    // Update card size display
    updateCardSizeDisplay();
    
    // Set max card size as default
    cardSizeSelect.value = currentModel.maxCapacity <= Math.max(...currentModel.cardSizes) 
        ? currentModel.maxCapacity 
        : Math.max(...currentModel.cardSizes);
    
    console.log('cardSizeSelect.value set to:', cardSizeSelect.value);
    
    // Update channel priority options
    updateChannelPriorityOptions();
    
    // Always setup manual configuration (no presets)
    setupManualConfiguration();
    
    // Show calculate button since we're in manual mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection) {
        calculateButtonSection.classList.remove('hidden');
    }
}

// Update Channel Priority Options
function updateChannelPriorityOptions() {
    if (!channelPrioritySelect || !channelPriorityDiv || !currentModel) return;
    
    // Clear existing options
    channelPrioritySelect.innerHTML = '';
    
    // Add "equal quality" option
    const equalOption = document.createElement('option');
    equalOption.value = 'equal';
    equalOption.textContent = '🎥 Todas as câmeras com mesma qualidade';
    channelPrioritySelect.appendChild(equalOption);
    
    // Add option for each channel (if model has multiple channels)
    if (currentModel.channels && currentModel.channels.length > 1) {
        currentModel.channels.forEach((channel, index) => {
            const option = document.createElement('option');
            option.value = index.toString();
            option.textContent = `⭐ Priorizar ${channel.name || `Canal ${index + 1}`}`;
            channelPrioritySelect.appendChild(option);
        });
        
        // Show the priority selector
        channelPriorityDiv.classList.remove('hidden');
    } else {
        // Hide if only one channel
        channelPriorityDiv.classList.add('hidden');
    }
    
    // Reset selection to equal
    selectedPriorityChannel = 'equal';
    channelPrioritySelect.value = 'equal';
}

// Render Preset Cards
// Preset functions removed - always use manual configuration

// Setup Manual Configuration (always active now)

// Setup Manual Configuration
function setupManualConfiguration() {
    console.log('Setting up manual configuration for:', currentModel.name);
    
    // Set channel count
    if (currentModel.name === 'JC181' || currentModel.name === 'JC400') {
        if (channelCountInput) {
            channelCountInput.value = currentModel.maxChannels;
            channelCountInput.disabled = true;
        }
        const channelCountDiv = document.getElementById('channelCountDiv');
        if (channelCountDiv) {
            channelCountDiv.style.display = 'none';
        }
    } else {
        if (channelCountInput) {
            channelCountInput.max = currentModel.maxChannels;
            channelCountInput.value = Math.min(2, currentModel.maxChannels);
            channelCountInput.disabled = false;
        }
        const channelCountDiv = document.getElementById('channelCountDiv');
        if (channelCountDiv) {
            channelCountDiv.style.display = 'block';
        }
    }
    
    updateChannelConfig();
    console.log('Manual configuration setup complete');
}

// Update Channel Configuration
function updateChannelConfig() {
    if (!channelConfigDiv || !currentModel) {
        console.warn('Cannot update channel config: missing elements or model');
        return;
    }
    
    channelConfigDiv.innerHTML = '';
    
    const channelCount = currentModel.name === 'JC181' || currentModel.name === 'JC400' 
        ? currentModel.maxChannels 
        : parseInt(channelCountInput.value);
    
    console.log(`Creating ${channelCount} channel cards for ${currentModel.name}`);
    
    for (let i = 0; i < channelCount; i++) {
        const channelCard = createChannelCard(i);
        channelConfigDiv.appendChild(channelCard);
    }
    
    saveState();
}

// Create Channel Configuration Card
function createChannelCard(index) {
    const card = document.createElement('div');
    card.className = 'channel-config-card';
    
    const channelInfo = currentModel.channels 
        ? currentModel.channels[index] 
        : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
    
    card.innerHTML = `
        <h4 class="font-bold text-gray-800 mb-3">
            <i class="fas fa-video text-blue-500"></i> ${channelInfo.name}
        </h4>
        <div class="space-y-3" id="channel-${index}">
            ${generateChannelInputs(index, channelInfo)}
        </div>
    `;
    
    return card;
}

// Generate Channel Inputs based on Model
function generateChannelInputs(index, channelInfo) {
    if (currentModel.name === 'JC400') {
        return generateJC400Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC181') {
        return generateJC181Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC371') {
        return generateJC371Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC450') {
        return generateJC450Inputs(index, channelInfo);
    }
    return '';
}

// JC400 Preset Selection
function generateJC400Inputs(index, channelInfo) {
    const presets = channelInfo.presets.map(preset => 
        `<option value="${preset.value}" data-resolution="${preset.resolution}" data-bitrate="${preset.bitrate}" data-fps="${preset.fps}">
            ${preset.label}
        </option>`
    ).join('');
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('configuration')}</label>
            <select class="channel-preset w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${presets}
            </select>
        </div>
    `;
}

// JC181 Inputs
function generateJC181Inputs(index, channelInfo) {
    // Get the specific channel configuration from the model
    const channelConfig = currentModel.channels[index];
    
    // Check if this channel is fixed (CH2 is always 360P@0.5M)
    if (channelConfig.fixed) {
        return `
            <div class="bg-yellow-50/20 border border-yellow-300 rounded-lg p-3">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-lock"></i> <strong>${t('fixed_configuration')}:</strong><br>
                    360P (640×360) @ 0.5 Mbps, 25 FPS
                </p>
            </div>
        `;
    }
    
    // CH1 is configurable
    const resolutionOptions = channelConfig.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    // Get default FPS and bitrates from first resolution
    const defaultFps = channelConfig.fps || [15, 25, 30];
    const defaultBitrates = channelConfig.resolutions[0].bitrates || [1, 2, 4];
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
            <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}" onchange="updateJC181Bitrates(${index})">
                ${resolutionOptions}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('fps')}</label>
            <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultFps.map(fps => `<option value="${fps}">${fps} FPS</option>`).join('')}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('bitrate')}</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultBitrates.map(br => `<option value="${br}">${br} Mbps</option>`).join('')}
            </select>
        </div>
    `;
}

// Update JC181 bitrates when resolution changes
window.updateJC181Bitrates = function(channelIndex) {
    const channelConfig = currentModel.channels[channelIndex];
    const resolutionSelect = document.querySelector(`.channel-resolution[data-channel="${channelIndex}"]`);
    const bitrateSelect = document.querySelector(`.channel-bitrate[data-channel="${channelIndex}"]`);
    
    if (!resolutionSelect || !bitrateSelect) return;
    
    const selectedResolution = resolutionSelect.value;
    const resConfig = channelConfig.resolutions.find(r => r.value === selectedResolution);
    
    if (resConfig && resConfig.bitrates) {
        bitrateSelect.innerHTML = resConfig.bitrates.map(br => 
            `<option value="${br}">${br}</option>`
        ).join('');
    }
}

// JC371 Inputs
function generateJC371Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    const codecOptions = currentModel.codecs.map(codec => 
        `<option value="${codec.value}" data-multiplier="${codec.multiplier}">${codec.label}</option>`
    ).join('');
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">Bitrate (Mbps)</label>
                <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.resolutions[0].bitrates.map(br => `<option value="${br}">${br}</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('codec')}</label>
                <select class="channel-codec w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${codecOptions}
                </select>
            </div>
        </div>
    `;
}

// JC450 Inputs
function generateJC450Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">Bitrate</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${currentModel.resolutions[0].bitrates.map(br => `<option value="${br}">${br/1024}M (${br}Kbps)</option>`).join('')}
            </select>
        </div>
    `;
}

// Update Total Desired Time Display
function updateTotalDesiredTime() {
    if (!desiredDaysInput || !desiredHoursInput || !totalDesiredTimeSpan) return;
    
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    const totalHours = (days * 24) + hours;
    
    const hoursText = t('hours');
    totalDesiredTimeSpan.textContent = totalHours + ' ' + hoursText + ' (' + days + 'd ' + hours + 'h)';
}

// Generate Auto Configuration
function generateAutoConfig() {
    console.log('=== Generate Auto Config Called ===');
    console.log('Current Model:', currentModel);
    
    if (!currentModel) {
        console.error('No model selected!');
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, selecione um modelo primeiro.' 
            : 'Please select a model first.');
        return;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    const totalDesiredHours = (days * 24) + hours;
    
    console.log('Card Size:', cardSize, 'GB');
    console.log('Desired Time:', totalDesiredHours, 'hours', '(' + days + 'd ' + hours + 'h)');
    
    if (totalDesiredHours <= 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, informe um tempo desejado maior que zero.' 
            : 'Please enter a desired time greater than zero.');
        return;
    }
    
    // Get number of channels for this model
    const numChannels = currentModel.channels ? currentModel.channels.length : parseInt(channelCountInput.value) || 1;
    
    // Generate ALL possible configurations
    const allPossibleConfigs = generateAllPossibleConfigs(numChannels);
    
    console.log('Generated', allPossibleConfigs.length, 'possible configurations');
    if (allPossibleConfigs.length > 0) {
        console.log('Sample configs:', allPossibleConfigs.slice(0, 3).map(c => 
            c.configs.map(ch => `${ch.resolution}P@${ch.bitrate}M`).join(', ')
        ));
    }
    
    if (allPossibleConfigs.length === 0) {
        alert(currentLang === 'pt-BR'
            ? 'Erro ao gerar configurações. Verifique se o modelo está configurado corretamente.'
            : 'Error generating configurations. Check if the model is configured correctly.');
        return;
    }
    
    // Calculate actual recording time for each configuration and find the closest
    let bestConfig = null;
    let minTimeDifference = Infinity;
    
    allPossibleConfigs.forEach(configSet => {
        const channels = configSet.configs.map((config, index) => {
            const channelInfo = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index] 
                : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
            
            // Handle JC400 preset-based configuration
            if (currentModel.name === 'JC400' && config.preset !== undefined) {
                const presetData = channelInfo.presets[config.preset];
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: presetData.resolution.toString(),
                    fps: presetData.fps,
                    bitrate: presetData.bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    preset: config.preset
                };
            }
            
            // Handle standard resolution/fps/bitrate configuration
            return {
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: config.resolution.toString(),
                fps: config.fps,
                bitrate: config.bitrate,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: config.fixed || false
            };
        });
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard);
        const timeDifference = Math.abs(results.totalTimeHours - totalDesiredHours);
        
        if (timeDifference < minTimeDifference) {
            minTimeDifference = timeDifference;
            bestConfig = configSet;
            bestConfig.calculatedTime = results.totalTimeHours;
        }
    });
    
    // Use the best configuration found
    autoGeneratedConfig = bestConfig ? bestConfig.configs : generateConfigForModel(0, numChannels);
    
    // Check if the best configuration can achieve the desired time
    if (bestConfig && bestConfig.calculatedTime) {
        const maxPossibleTime = bestConfig.calculatedTime;
        const timeDifferencePercent = ((totalDesiredHours - maxPossibleTime) / totalDesiredHours) * 100;
        
        // If the best possible configuration is still far from the target (more than 30% less)
        if (maxPossibleTime < totalDesiredHours && timeDifferencePercent > 30) {
            const availableCardSizes = currentModel.cardSizes || [16, 32, 64, 128, 256];
            const currentCardIndex = availableCardSizes.indexOf(cardSize);
            const nextCardSize = currentCardIndex < availableCardSizes.length - 1 
                ? availableCardSizes[currentCardIndex + 1] 
                : null;
            
            let solutionText = '';
            if (nextCardSize) {
                solutionText = currentLang === 'pt-BR'
                    ? `Use um cartão SD de ${nextCardSize}GB ou maior para atingir o tempo desejado.`
                    : `Use an SD card of ${nextCardSize}GB or larger to achieve the desired time.`;
            } else {
                solutionText = currentLang === 'pt-BR'
                    ? `Use o maior cartão SD disponível (${availableCardSizes[availableCardSizes.length - 1]}GB) ou reduza o tempo desejado de gravação.`
                    : `Use the largest available SD card (${availableCardSizes[availableCardSizes.length - 1]}GB) or reduce the desired recording time.`;
            }
            
            // Show modal instead of alert
            showWarningModal({
                desiredHours: totalDesiredHours,
                desiredDays: totalDesiredHours / 24,
                currentCard: cardSize,
                maxHours: maxPossibleTime,
                maxDays: maxPossibleTime / 24,
                solution: solutionText
            });
            
            return; // Don't proceed with calculation
        }
    }
    
    // Calculate required bitrate for display purposes
    const MB_PER_GB = 1000;
    const availableSpaceMB = cardSize * MB_PER_GB * 0.9;
    const requiredTotalMBh = availableSpaceMB / totalDesiredHours;
    const requiredMBhPerChannel = requiredTotalMBh / numChannels;
    const requiredBitratePerChannel = requiredMBhPerChannel / 450;
    
    // Display suggested configurations on the right side
    displaySuggestedConfigs(autoGeneratedConfig, requiredBitratePerChannel, totalDesiredHours);
}

// Display Suggested Configurations
function displaySuggestedConfigs(configs, targetBitrate, desiredHours) {
    const channelConfigDiv = document.getElementById('channelConfig');
    if (!channelConfigDiv) return;
    
    // Store for recommended alternatives
    lastTargetBitrate = targetBitrate;
    lastDesiredHours = desiredHours;
    
    channelConfigDiv.innerHTML = '';
    
    // Header with Jimi blue colors
    const header = document.createElement('div');
    header.className = 'mb-4 p-4 text-white rounded-lg';
    header.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
    header.innerHTML = '<h3 class="text-lg font-bold mb-2">' +
        '<i class="fas fa-lightbulb mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Configurações Recomendadas' : 'Recommended Configurations') +
        '</h3>' +
        '<p class="text-sm opacity-90">' +
        (currentLang === 'pt-BR' 
            ? 'Configuração otimizada para atingir <strong>' + desiredHours.toFixed(1) + ' horas</strong> de gravação' 
            : 'Optimized configuration to achieve <strong>' + desiredHours.toFixed(1) + ' hours</strong> of recording') +
        '</p>' +
        '<p class="text-xs mt-1 opacity-80">' +
        (currentLang === 'pt-BR' 
            ? 'Bitrate alvo calculado: ' + targetBitrate.toFixed(2) + ' Mbps por canal' 
            : 'Calculated target bitrate: ' + targetBitrate.toFixed(2) + ' Mbps per channel') +
        '</p>';
    channelConfigDiv.appendChild(header);
    
    // Configuration cards (without GB consumption)
    configs.forEach((config, index) => {
        const card = document.createElement('div');
        card.className = 'p-4 bg-white rounded-lg shadow-md mb-3';
        card.style.border = '2px solid #0066CC';
        
        const channelName = currentModel.channels && currentModel.channels[index] 
            ? currentModel.channels[index].name 
            : 'Canal ' + (index + 1);
        
        const isFixed = config.fixed || (currentModel.name === 'JC181' && index === 1);
        
        // Get actual config values (handle JC400 presets)
        let resolution, fps, bitrate;
        if (currentModel.name === 'JC400' && config.preset !== undefined) {
            const channelInfo = currentModel.channels[index];
            const presetData = channelInfo.presets[config.preset];
            resolution = presetData.resolution;
            fps = presetData.fps;
            bitrate = presetData.bitrate;
        } else {
            resolution = config.resolution;
            fps = config.fps;
            bitrate = config.bitrate;
        }
        
        // Calculate MB/h consumption
        const consumptionMBh = bitrate * 450; // 1 Mbps = 450 MB/h
        
        card.innerHTML = '<div class="flex items-center justify-between mb-3">' +
            '<h4 class="font-bold text-gray-800">' +
            '<i class="fas fa-video mr-2" style="color: #0066CC;"></i>' +
            channelName +
            '</h4>' +
            (isFixed ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded">' + t('fixed_configuration') + '</span>' : '') +
            '</div>' +
            '<div class="space-y-2 text-sm text-gray-700">' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-image text-blue-500 mr-2"></i>' + t('resolution') + ':</span>' +
            '<strong>' + resolution + 'P</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-tachometer-alt text-green-500 mr-2"></i>FPS:</span>' +
            '<strong>' + fps + ' fps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-signal text-purple-500 mr-2"></i>Bitrate:</span>' +
            '<strong>' + bitrate + ' Mbps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 rounded" style="background-color: #E6F0FF; border: 1px solid #0066CC;">' +
            '<span><i class="fas fa-clock mr-2" style="color: #0066CC;"></i>' + 
            (currentLang === 'pt-BR' ? 'Taxa de gravação:' : 'Recording rate:') + '</span>' +
            '<strong style="color: #0052A3;">' + consumptionMBh.toFixed(0) + ' MB/h</strong>' +
            '</div>' +
            '</div>';
        
        channelConfigDiv.appendChild(card);
    });
    
    // Info box
    const infoBox = document.createElement('div');
    infoBox.className = 'mt-4 p-3 bg-green-50 border border-green-200 rounded-lg text-sm text-green-800';
    infoBox.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-info-circle text-green-600 mr-2 mt-1"></i>' +
        '<div>' +
        '<strong>' + (currentLang === 'pt-BR' ? 'Esta é a configuração mais próxima do seu objetivo' : 'This is the configuration closest to your goal') + '</strong><br>' +
        '<span class="text-xs">' + 
        (currentLang === 'pt-BR' 
            ? 'Aguarde o cálculo dos resultados detalhados abaixo.' 
            : 'Wait for detailed results calculation below.') +
        '</span>' +
        '</div>' +
        '</div>';
    channelConfigDiv.appendChild(infoBox);
    
    // Calculate directly without using applyAutoConfigToUI to avoid showing channel selectors
    setTimeout(function() {
        calculateAutoConfig(autoGeneratedConfig);
    }, 100);
}

// Calculate Auto Config directly
function calculateAutoConfig(configs) {
    if (!configs || configs.length === 0) return;
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Build channels array from auto-generated configs
    const channels = configs.map((config, index) => {
        const channelInfo = currentModel.channels && currentModel.channels[index] 
            ? currentModel.channels[index] 
            : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
        
        return {
            active: true,
            channelId: channelInfo.id,
            channelName: channelInfo.name,
            resolution: config.resolution.toString(),
            fps: config.fps,
            bitrate: config.bitrate,
            codec: 'H.264',
            codecMultiplier: 1,
            fixed: config.fixed || false,
            preset: config.preset
        };
    });
    
    // Perform calculation (pass dualCard parameter, considering useOneCardOnly)
    const useDualCard = currentModel.dualCard && !useOneCardOnly;
    const results = calculator.calculateTotal(cardSize, channels, useDualCard);
    currentConfig = { modelName: currentModel.name, results, channels };
    
    // Display results
    displayResults(results);
    resultsSection.classList.remove('hidden');
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    // Show recommended alternatives
    showRecommendedAlternatives();
    
    saveState();
}

// Show Recommended Alternatives
function showRecommendedAlternatives() {
    if (!lastTargetBitrate || !lastDesiredHours) return;
    
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedAlternatives = document.getElementById('recommendedAlternatives');
    
    if (!recommendedSection || !recommendedAlternatives) return;
    
    // Clear previous content
    recommendedAlternatives.innerHTML = '';
    
    // Generate alternative configurations
    const alternatives = generateAlternativeConfigs(lastTargetBitrate);
    
    if (alternatives.length === 0) {
        recommendedSection.classList.add('hidden');
        return;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Calculate results and remove duplicates
    const alternativesWithResults = [];
    const seenConfigs = new Set();
    
    alternatives.forEach((altConfig) => {
        // Calculate results for this alternative
        const channels = altConfig.configs.map((config, index) => {
            const channelInfo = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index] 
                : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
            
            // Handle JC400 presets
            let resolution, fps, bitrate;
            if (currentModel.name === 'JC400' && config.preset !== undefined) {
                const presetData = channelInfo.presets[config.preset];
                resolution = presetData.resolution;
                fps = presetData.fps;
                bitrate = presetData.bitrate;
            } else {
                resolution = config.resolution;
                fps = config.fps;
                bitrate = config.bitrate;
            }
            
            return {
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: resolution.toString(),
                fps: fps,
                bitrate: bitrate,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: config.fixed || false
            };
        });
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard);
        
        // Create a unique key for this configuration
        const configKey = altConfig.configs.map(c => {
            if (c.preset !== undefined) {
                return `preset${c.preset}`;
            }
            return `${c.resolution}_${c.fps}_${c.bitrate}`;
        }).join('|');
        
        // Only add if not duplicate
        if (!seenConfigs.has(configKey)) {
            seenConfigs.add(configKey);
            alternativesWithResults.push({
                ...altConfig,
                results: results,
                channels: channels
            });
        }
    });
    
    // If no unique alternatives, hide section
    if (alternativesWithResults.length === 0) {
        recommendedSection.classList.add('hidden');
        return;
    }
    
    // Sort alternatives by relevance:
    // 1. First by time difference (closest to desired time)
    // 2. Then by quality (higher bitrate preferred if time is similar)
    alternativesWithResults.sort((a, b) => {
        const timeDiffA = Math.abs(a.results.totalTimeHours - lastDesiredHours);
        const timeDiffB = Math.abs(b.results.totalTimeHours - lastDesiredHours);
        const timeDiffPercentA = (timeDiffA / lastDesiredHours) * 100;
        const timeDiffPercentB = (timeDiffB / lastDesiredHours) * 100;
        
        // If time difference is similar (within 5%), prefer higher quality
        if (Math.abs(timeDiffPercentA - timeDiffPercentB) < 5) {
            const totalBitrateA = a.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
            const totalBitrateB = b.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
            return totalBitrateB - totalBitrateA; // Higher bitrate first
        }
        
        // Otherwise, sort by time difference (closest first)
        return timeDiffA - timeDiffB;
    });
    
    // Limit to top 6 most relevant alternatives
    const topAlternatives = alternativesWithResults.slice(0, 6);
    
    // Show section
    recommendedSection.classList.remove('hidden');
    
    topAlternatives.forEach((altConfig, altIndex) => {
        const altCard = document.createElement('div');
        altCard.className = 'p-5 bg-white rounded-xl shadow-lg border-2 transition-all cursor-pointer overflow-hidden';
        altCard.style.borderColor = '#E5E7EB';
        
        altCard.onmouseenter = function() {
            this.style.borderColor = '#0066CC';
            this.style.transform = 'translateY(-4px)';
            this.style.boxShadow = '0 12px 24px rgba(0, 102, 204, 0.15)';
        };
        altCard.onmouseleave = function() {
            this.style.borderColor = '#E5E7EB';
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '';
        };
        
        const results = altConfig.results;
        
        // Calculate total bitrate and data consumption
        const totalBitrate = altConfig.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
        const totalMBh = totalBitrate * 450; // MB/h
        
        // Determine badge and classification
        let badge = '';
        let badgeClass = '';
        let badgeIcon = '';
        let description = '';
        
        const timeDiff = results.totalTimeHours - lastDesiredHours;
        const timeDiffPercent = Math.abs((timeDiff / lastDesiredHours) * 100);
        
        // Use strategy name if available
        if (altConfig.name) {
            badge = altConfig.name;
            
            // Determine icon and color based on strategy
            if (altConfig.strategy === 'balanced' && altConfig.multiplier < 1) {
                badgeIcon = '💾';
                badgeClass = 'bg-green-100 text-green-700 border-green-300';
                description = 'Menor consumo de espaço, maior tempo de gravação';
            } else if (altConfig.strategy === 'balanced' && altConfig.multiplier > 1) {
                badgeIcon = '⭐';
                badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                description = 'Melhor qualidade de imagem em todos os canais';
            } else if (altConfig.strategy === 'mixed-high-ch1' || altConfig.strategy === 'out-priority') {
                badgeIcon = '🎯';
                badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                description = 'Canal principal com alta qualidade, outros otimizados';
            } else if (altConfig.strategy === 'mixed-max-time' || altConfig.strategy === 'max-time') {
                badgeIcon = '⏱️';
                badgeClass = 'bg-orange-100 text-orange-700 border-orange-300';
                description = 'Configuração otimizada para máximo tempo de gravação';
            } else if (altConfig.strategy === 'high-all') {
                badgeIcon = '💎';
                badgeClass = 'bg-indigo-100 text-indigo-700 border-indigo-300';
                description = 'Máxima qualidade em todos os canais';
            } else if (altConfig.strategy === 'balanced-medium') {
                badgeIcon = '⚖️';
                badgeClass = 'bg-teal-100 text-teal-700 border-teal-300';
                description = 'Equilíbrio entre qualidade e tempo de gravação';
            } else {
                badgeIcon = '📹';
                badgeClass = 'bg-gray-100 text-gray-700 border-gray-300';
                description = 'Configuração alternativa';
            }
        } else {
            // Fallback to old logic
            if (timeDiffPercent < 5) {
                badge = 'Tempo Exato';
                badgeIcon = '🎯';
                badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                description = 'Atinge o tempo desejado com precisão';
            } else if (altConfig.multiplier < 1) {
                badge = 'Econômico';
                badgeIcon = '💾';
                badgeClass = 'bg-green-100 text-green-700 border-green-300';
                description = 'Menor consumo de espaço, maior tempo de gravação';
            } else {
                badge = 'Alta Qualidade';
                badgeIcon = '⭐';
                badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                description = 'Melhor qualidade de imagem';
            }
        }
        
        // Build channel summary with icons and better formatting
        let channelsHTML = '';
        altConfig.configs.forEach((config, index) => {
            const channelName = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index].name 
                : 'Canal ' + (index + 1);
            
            // Get actual values (handle JC400 presets)
            let resolution, fps, bitrate;
            if (currentModel.name === 'JC400' && config.preset !== undefined) {
                const channelInfo = currentModel.channels[index];
                const presetData = channelInfo.presets[config.preset];
                resolution = presetData.resolution;
                fps = presetData.fps;
                bitrate = presetData.bitrate;
            } else {
                resolution = config.resolution;
                fps = config.fps;
                bitrate = config.bitrate;
            }
            
            // Determine quality level for visual indication
            let qualityColor = '#6B7280'; // gray
            if (bitrate >= 6) qualityColor = '#059669'; // green - high
            else if (bitrate >= 3) qualityColor = '#0066CC'; // blue - medium
            else if (bitrate >= 1) qualityColor = '#F59E0B'; // orange - low
            
            channelsHTML += '<div class="flex items-center justify-between p-2 rounded mb-2" style="background-color: #F9FAFB; border-left: 3px solid ' + qualityColor + ';">' +
                '<div class="flex-1">' +
                '<div class="font-semibold text-sm text-gray-800">' +
                '<i class="fas fa-video mr-2" style="color: ' + qualityColor + ';"></i>' +
                channelName +
                '</div>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                '<span class="inline-block mr-3"><i class="fas fa-image mr-1"></i>' + resolution + 'P</span>' +
                '<span class="inline-block mr-3"><i class="fas fa-tachometer-alt mr-1"></i>' + fps + ' fps</span>' +
                '<span class="inline-block"><i class="fas fa-signal mr-1"></i>' + bitrate + ' Mbps</span>' +
                '</div>' +
                '</div>' +
                '</div>';
        });
        
        const timeDiffSign = timeDiff >= 0 ? '+' : '';
        const timeDiffColor = Math.abs(timeDiffPercent) < 10 ? '#059669' : (timeDiff >= 0 ? '#0066CC' : '#EF4444');
        
        altCard.innerHTML = 
            // Header with badge
            '<div class="flex items-center justify-between mb-4 pb-3 border-b-2 border-gray-100">' +
            '<div>' +
            '<h4 class="font-bold text-lg text-gray-800 mb-1">' +
            badgeIcon + ' Opção ' + (altIndex + 1) +
            '</h4>' +
            '<p class="text-xs text-gray-500 italic">' + description + '</p>' +
            '</div>' +
            '<span class="text-xs px-3 py-1.5 rounded-full border-2 font-bold ' + badgeClass + '">' + badge + '</span>' +
            '</div>' +
            
            // Channel configurations
            '<div class="mb-4">' +
            '<h5 class="text-xs font-bold text-gray-600 uppercase tracking-wide mb-2">' +
            '<i class="fas fa-cog mr-1"></i>Configuração dos Canais' +
            '</h5>' +
            channelsHTML +
            '</div>' +
            
            // Statistics grid
            '<div class="grid grid-cols-2 gap-3 mb-4">' +
            
            // Recording time
            '<div class="col-span-2 p-3 rounded-lg" style="background: linear-gradient(135deg, #E6F0FF 0%, #CCE0FF 100%); border: 2px solid #0066CC;">' +
            '<div class="flex items-center justify-between">' +
            '<div>' +
            '<div class="text-xs text-gray-700 font-semibold mb-1">' +
            '<i class="fas fa-clock mr-1" style="color: #0066CC;"></i>Tempo Total' +
            '</div>' +
            '<div class="font-bold text-2xl" style="color: #0052A3;">' +
            results.totalTimeDays.toFixed(1) + ' dias' +
            '</div>' +
            '<div class="text-sm text-gray-700">' + results.totalTimeHours.toFixed(1) + ' horas</div>' +
            '</div>' +
            '<div class="text-center px-3 py-2 bg-white rounded-lg border-2" style="border-color: ' + timeDiffColor + ';">' +
            '<div class="font-bold text-lg" style="color: ' + timeDiffColor + ';">' + timeDiffSign + timeDiffPercent.toFixed(0) + '%</div>' +
            '<div class="text-xs text-gray-600">vs desejado</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // Total bitrate
            '<div class="p-3 rounded-lg bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-200">' +
            '<div class="text-xs text-purple-700 font-semibold mb-1">' +
            '<i class="fas fa-signal mr-1"></i>Bitrate Total' +
            '</div>' +
            '<div class="font-bold text-xl text-purple-800">' + totalBitrate.toFixed(1) + ' Mbps</div>' +
            '</div>' +
            
            // Data consumption
            '<div class="p-3 rounded-lg bg-gradient-to-br from-orange-50 to-orange-100 border-2 border-orange-200">' +
            '<div class="text-xs text-orange-700 font-semibold mb-1">' +
            '<i class="fas fa-database mr-1"></i>Consumo/Hora' +
            '</div>' +
            '<div class="font-bold text-xl text-orange-800">' + (totalMBh / 1000).toFixed(2) + ' GB/h</div>' +
            '</div>' +
            
            '</div>' +
            
            // Action button
            '<button class="w-full text-white py-3 px-4 rounded-lg transition-all text-sm font-bold shadow-md hover:shadow-xl transform hover:scale-105" style="background: linear-gradient(135deg, #0066CC 0%, #0052A3 100%);">' +
            '<i class="fas fa-check-circle mr-2"></i>Usar Esta Configuração' +
            '</button>';
        
        const useBtn = altCard.querySelector('button');
        useBtn.onclick = function() {
            autoGeneratedConfig = altConfig.configs;
            calculateAutoConfig(altConfig.configs);
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        };
        
        recommendedAlternatives.appendChild(altCard);
    });
    
    // Show the section
    recommendedSection.classList.remove('hidden');
}

// Show More Alternatives
function showMoreAlternatives(targetBitrate, desiredHours) {
    const channelConfigDiv = document.getElementById('channelConfig');
    if (!channelConfigDiv) return;
    
    // Clear current content
    channelConfigDiv.innerHTML = '';
    
    // Header with Jimi colors
    const header = document.createElement('div');
    header.className = 'mb-4 p-4 text-white rounded-lg';
    header.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
    header.innerHTML = '<h3 class="text-lg font-bold mb-2">' +
        '<i class="fas fa-layer-group mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Configurações Alternativas' : 'Alternative Configurations') +
        '</h3>' +
        '<p class="text-sm opacity-90">' +
        (currentLang === 'pt-BR' 
            ? 'Outras opções que também atendem sua solicitação de <strong>' + desiredHours.toFixed(1) + ' horas</strong>' 
            : 'Other options that also meet your request of <strong>' + desiredHours.toFixed(1) + ' hours</strong>') +
        '</p>';
    channelConfigDiv.appendChild(header);
    
    // Generate multiple alternative configurations
    const alternatives = generateAlternativeConfigs(targetBitrate);
    
    alternatives.forEach((altConfig, altIndex) => {
        const altCard = document.createElement('div');
        altCard.className = 'mb-4 p-4 bg-white rounded-lg shadow-md border-2 transition-all';
        altCard.style.borderColor = '#0066CC';
        altCard.style.cursor = 'pointer';
        altCard.onmouseenter = function() {
            this.style.borderColor = '#0052A3';
            this.style.boxShadow = '0 4px 12px rgba(0, 102, 204, 0.3)';
        };
        altCard.onmouseleave = function() {
            this.style.borderColor = '#0066CC';
            this.style.boxShadow = '';
        };
        
        const cardSize = parseInt(cardSizeSelect.value);
        const channels = altConfig.configs.map((config, index) => {
            const channelInfo = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index] 
                : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
            
            return {
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: config.resolution.toString(),
                fps: config.fps,
                bitrate: config.bitrate,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: config.fixed || false
            };
        });
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard);
        
        // Determine badge based on multiplier
        let badge = '';
        let badgeClass = '';
        if (altConfig.multiplier < 1) {
            badge = currentLang === 'pt-BR' ? '💾 Mais Econômico' : '💾 More Economical';
            badgeClass = 'bg-green-100 text-green-700 border-green-300';
        } else {
            badge = currentLang === 'pt-BR' ? '⭐ Melhor Qualidade' : '⭐ Better Quality';
            badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
        }
        
        let channelsHTML = '';
        altConfig.configs.forEach((config, index) => {
            const channelName = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index].name 
                : 'Canal ' + (index + 1);
            const isFixed = config.fixed || (currentModel.name === 'JC181' && index === 1);
            
            channelsHTML += '<div class="mb-2 p-2 bg-gray-50 rounded">' +
                '<div class="flex items-center justify-between">' +
                '<strong class="text-sm" style="color: #0066CC;">' + channelName + ':</strong> ' +
                (isFixed ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded ml-2">' + t('fixed_configuration') + '</span>' : '') +
                '</div>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                config.resolution + 'P @ ' + config.fps + 'fps - ' + config.bitrate + ' Mbps' +
                '</div>' +
                '</div>';
        });
        
        const timeDiff = results.totalTimeHours - desiredHours;
        const timeDiffPercent = ((timeDiff / desiredHours) * 100).toFixed(0);
        
        altCard.innerHTML = '<div class="mb-3">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h4 class="font-bold text-gray-800">' +
            '<i class="fas fa-star mr-2" style="color: #0066CC;"></i>' +
            (currentLang === 'pt-BR' ? 'Alternativa ' : 'Alternative ') + (altIndex + 1) +
            '</h4>' +
            '<span class="text-xs px-2 py-1 rounded border font-semibold ' + badgeClass + '">' + badge + '</span>' +
            '</div>' +
            channelsHTML +
            '</div>' +
            '<div class="mt-3 pt-3 border-t border-gray-200">' +
            '<div class="grid grid-cols-3 gap-2 text-xs mb-2">' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + results.totalTimeDays.toFixed(1) + '</div>' +
            '<div class="text-gray-600">' + t('days') + '</div>' +
            '</div>' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + results.totalTimeHours.toFixed(1) + '</div>' +
            '<div class="text-gray-600">' + t('hours') + '</div>' +
            '</div>' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + (timeDiff >= 0 ? '+' : '') + timeDiffPercent + '%</div>' +
            '<div class="text-gray-600 text-xs">' + (currentLang === 'pt-BR' ? 'Diferença' : 'Difference') + '</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<button class="w-full mt-3 text-white py-2 px-3 rounded transition text-sm font-semibold shadow-md hover:shadow-lg" style="background: linear-gradient(135deg, #0066CC 0%, #0052A3 100%);">' +
            '<i class="fas fa-check-circle mr-2"></i>' +
            (currentLang === 'pt-BR' ? 'Usar Esta Configuração' : 'Use This Configuration') +
            '</button>';
        
        const useBtn = altCard.querySelector('button');
        useBtn.onclick = function() {
            autoGeneratedConfig = altConfig.configs;
            calculateAutoConfig(altConfig.configs);
        };
        useBtn.onmouseenter = function() {
            this.style.background = 'linear-gradient(135deg, #0052A3 0%, #003d7a 100%)';
        };
        useBtn.onmouseleave = function() {
            this.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
        };
        
        channelConfigDiv.appendChild(altCard);
    });
    
    // Back button
    const backBtn = document.createElement('button');
    backBtn.className = 'w-full mt-4 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition';
    backBtn.innerHTML = '<i class="fas fa-arrow-left mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Voltar para Recomendação Principal' : 'Back to Main Recommendation');
    backBtn.onclick = function() {
        const days = parseInt(desiredDaysInput.value) || 0;
        const hours = parseInt(desiredHoursInput.value) || 0;
        const totalHours = (days * 24) + hours;
        generateAutoConfig();
    };
    channelConfigDiv.appendChild(backBtn);
}

// Generate All Possible Configurations
function generateAllPossibleConfigs(numChannels) {
    const allConfigs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: Only CH1 is configurable, CH2 is fixed
        const ch1Channel = currentModel.channels[0];
        const ch2Fixed = {
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        };
        
        if (ch1Channel.resolutions) {
            ch1Channel.resolutions.forEach(res => {
                res.bitrates.forEach(bitrate => {
                    const defaultFps = ch1Channel.fps ? (Array.isArray(ch1Channel.fps) ? ch1Channel.fps[0] : ch1Channel.fps) : 25;
                    allConfigs.push({
                        configs: [
                            {
                                resolution: res.value,
                                fps: defaultFps,
                                bitrate: bitrate
                            },
                            ch2Fixed
                        ]
                    });
                });
            });
        }
    } else if (currentModel.name === 'JC400') {
        // JC400: Generate combinations of presets
        const outPresets = currentModel.channels[0].presets || [];
        const inPresets = currentModel.channels[1].presets || [];
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        if (priorityChannelIndex === -1) {
            // User wants all channels equal - generate all combinations
            outPresets.forEach((outPreset, outIndex) => {
                inPresets.forEach((inPreset, inIndex) => {
                    allConfigs.push({
                        configs: [
                            { preset: outIndex },
                            { preset: inIndex }
                        ]
                    });
                });
            });
        } else {
            // User wants a specific channel prioritized
            if (priorityChannelIndex === 0) {
                // Prioritize OUT camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if OUT has same or better quality than IN
                        if (outPreset.bitrate >= inPreset.bitrate) {
                            allConfigs.push({
                                configs: [
                                    { preset: outIndex },
                                    { preset: inIndex }
                                ]
                            });
                        }
                    });
                });
            } else {
                // Prioritize IN camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if IN has same or better quality than OUT
                        if (inPreset.bitrate >= outPreset.bitrate) {
                            allConfigs.push({
                                configs: [
                                    { preset: outIndex },
                                    { preset: inIndex }
                                ]
                            });
                        }
                    });
                });
            }
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // For simplicity, generate a subset of common configurations
        // instead of ALL combinations (which would be too many)
        
        // Get all available bitrates from model resolutions
        const allBitrates = currentModel.resolutions 
            ? currentModel.resolutions.flatMap(res => res.bitrates)
            : [];
        
        // Get unique bitrates and sort
        const uniqueBitrates = [...new Set(allBitrates)].sort((a, b) => a - b);
        
        const numChannels = currentModel.channels ? currentModel.channels.length : 2;
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        if (priorityChannelIndex === -1) {
            // User wants all channels with equal quality
            uniqueBitrates.forEach(bitrate => {
                const channelConfigs = [];
                for (let i = 0; i < numChannels; i++) {
                    const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                    if (config) {
                        channelConfigs.push(config);
                    }
                }
                
                if (channelConfigs.length === numChannels) {
                    allConfigs.push({
                        configs: channelConfigs
                    });
                }
            });
        } else {
            // User wants a specific channel prioritized
            uniqueBitrates.forEach(bitratePriority => {
                uniqueBitrates.forEach(bitrateOthers => {
                    if (bitratePriority >= bitrateOthers) { // Priority channel has same or higher bitrate
                        const channelConfigs = [];
                        
                        for (let i = 0; i < numChannels; i++) {
                            const bitrate = (i === priorityChannelIndex) ? bitratePriority : bitrateOthers;
                            const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                            if (config) {
                                channelConfigs.push(config);
                            }
                        }
                        
                        if (channelConfigs.length === numChannels) {
                            allConfigs.push({
                                configs: channelConfigs
                            });
                        }
                    }
                });
            });
        }
    }
    
    return allConfigs;
}

// Find Best Config for Specific Bitrate (helper function)
function findBestConfigForBitrate(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                if (bitrate === targetBitrate) {
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    // If exact match not found, find closest
    if (!bestConfig && channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                if (difference < minDifference) {
                    minDifference = difference;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig;
}

// Find Best Resolution for Specific Bitrate (for models with resolutions at model level)
function findBestResolutionForBitrate(targetBitrate, resolutions) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    if (!resolutions) return null;
    
    // First try exact match
    resolutions.forEach(res => {
        if (res.bitrates && res.bitrates.includes(targetBitrate)) {
            bestConfig = {
                resolution: res.value,
                fps: 25, // default
                bitrate: targetBitrate
            };
        }
    });
    
    // If exact match not found, find closest
    if (!bestConfig) {
        resolutions.forEach(res => {
            if (res.bitrates) {
                res.bitrates.forEach(bitrate => {
                    const difference = Math.abs(bitrate - targetBitrate);
                    if (difference < minDifference) {
                        minDifference = difference;
                        bestConfig = {
                            resolution: res.value,
                            fps: 25,
                            bitrate: bitrate
                        };
                    }
                });
            }
        });
    }
    
    return bestConfig;
}

// Generate Alternative Configurations
function generateAlternativeConfigs(targetBitrate) {
    const alternatives = [];
    const numChannels = currentModel.channels ? currentModel.channels.length : 1;
    const cardSize = parseInt(cardSizeSelect.value);
    const useDualCard = currentModel.dualCard && !useOneCardOnly;
    
    // Strategy 1: Balanced quality (all channels similar)
    const balancedVariations = [0.6, 0.8, 1.2, 1.4]; // -40%, -20%, +20%, +40%
    balancedVariations.forEach(multiplier => {
        const adjustedBitrate = targetBitrate * multiplier;
        const configs = generateConfigForModel(adjustedBitrate, numChannels);
        if (configs && configs.length > 0) {
            alternatives.push({ 
                configs, 
                multiplier,
                strategy: 'balanced',
                name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
            });
        }
    });
    
    // Strategy 2: For multi-channel models, create mixed quality options
    if (numChannels > 1 && (currentModel.name === 'JC371' || currentModel.name === 'JC450')) {
        // High priority on CH1, lower on others
        const mixedConfigs1 = generateMixedQualityConfig(targetBitrate * 1.5, targetBitrate * 0.7, 0);
        if (mixedConfigs1) {
            alternatives.push({
                configs: mixedConfigs1,
                multiplier: 1.0,
                strategy: 'mixed-high-ch1',
                name: 'CH1 Priorizado'
            });
        }
        
        // Medium CH1, very low others (maximum recording time)
        const mixedConfigs2 = generateMixedQualityConfig(targetBitrate * 0.8, targetBitrate * 0.4, 0);
        if (mixedConfigs2) {
            alternatives.push({
                configs: mixedConfigs2,
                multiplier: 0.6,
                strategy: 'mixed-max-time',
                name: 'Máximo Tempo'
            });
        }
        
        // High quality all main channels
        const highConfigs = generateMixedQualityConfig(targetBitrate * 1.3, targetBitrate * 1.3, -1);
        if (highConfigs) {
            alternatives.push({
                configs: highConfigs,
                multiplier: 1.3,
                strategy: 'high-all',
                name: 'Máxima Qualidade'
            });
        }
    }
    
    // Strategy 3: For JC400, create smart preset combinations
    if (currentModel.name === 'JC400') {
        // OUT high, IN medium
        alternatives.push({
            configs: [{ preset: 0 }, { preset: 1 }], // 1080P@8M, 720P@3M
            multiplier: 1.1,
            strategy: 'out-priority',
            name: 'OUT Priorizado'
        });
        
        // Both medium
        alternatives.push({
            configs: [{ preset: 1 }, { preset: 1 }], // 720P@4M, 720P@3M
            multiplier: 0.7,
            strategy: 'balanced-medium',
            name: 'Qualidade Média'
        });
        
        // Maximum time
        alternatives.push({
            configs: [{ preset: 3 }, { preset: 3 }], // 360P@0.5M, 360P@0.5M
            multiplier: 0.1,
            strategy: 'max-time',
            name: 'Máximo Tempo'
        });
    }
    
    // Strategy 4: For JC181, vary CH1 quality
    if (currentModel.name === 'JC181') {
        const ch1Variations = [0.5, 0.75, 1.25, 1.5];
        ch1Variations.forEach(multiplier => {
            const ch1Config = findBestConfig(targetBitrate * multiplier, currentModel.channels[0]);
            if (ch1Config) {
                alternatives.push({
                    configs: [
                        ch1Config,
                        { resolution: '360', fps: 25, bitrate: 0.5, fixed: true }
                    ],
                    multiplier,
                    strategy: 'ch1-variation',
                    name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
                });
            }
        });
    }
    
    // Remove alternatives that result in the same configuration as the main one
    // and sort by how close they are to the desired time
    return alternatives.filter((alt, index, self) => {
        // Remove duplicates based on actual bitrate
        const altKey = alt.configs.map(c => 
            c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
        ).join('|');
        
        return index === self.findIndex(t => {
            const tKey = t.configs.map(c => 
                c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
            ).join('|');
            return tKey === altKey;
        });
    });
}

// Helper function to generate mixed quality configurations
function generateMixedQualityConfig(priorityBitrate, othersBitrate, priorityChannelIndex) {
    if (!currentModel.resolutions) return null;
    
    const numChannels = currentModel.channels ? currentModel.channels.length : 2;
    const configs = [];
    
    for (let i = 0; i < numChannels; i++) {
        const bitrate = (priorityChannelIndex === -1 || i === priorityChannelIndex) 
            ? priorityBitrate 
            : othersBitrate;
        const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
        if (config) {
            configs.push(config);
        }
    }
    
    return configs.length === numChannels ? configs : null;
}

// Generate Configuration For Model
function generateConfigForModel(targetBitrate, numChannels) {
    const configs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: CH1 configurable, CH2 fixed
        configs.push(findBestConfig(targetBitrate, currentModel.channels[0]));
        configs.push({
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        });
    } else if (currentModel.name === 'JC400') {
        // JC400: OUT and IN cameras with presets
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            const preset = findBestPresetJC400(targetBitrate, channel);
            configs.push(preset);
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // JC371 and JC450: Flexible configuration
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            configs.push(findBestConfig(targetBitrate, channel));
        }
    }
    
    return configs;
}

// Find Best Config for Channel
function findBestConfig(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    // Get default FPS from channel
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                
                // Prefer configurations that are closer to target
                // If difference is similar, prefer slightly lower bitrate (longer recording time)
                // to avoid exceeding storage too quickly
                let penalty = 0;
                if (bitrate < targetBitrate) {
                    // Lower bitrate = longer recording time (good)
                    penalty = difference * 0.8; // 20% preference for lower bitrate
                } else {
                    // Higher bitrate = shorter recording time (less preferred)
                    penalty = difference * 1.2; // 20% penalty for higher bitrate
                }
                
                if (penalty < minDifference) {
                    minDifference = penalty;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig || {
        resolution: '720',
        fps: defaultFps,
        bitrate: 2
    };
}

// Find Best Preset for JC400
function findBestPresetJC400(targetBitrate, channel) {
    if (!channel.presets) {
        return { preset: 0 };
    }
    
    let bestPreset = 0;
    let minDifference = Infinity;
    
    channel.presets.forEach((preset, index) => {
        const difference = Math.abs(preset.bitrate - targetBitrate);
        
        // Apply same logic: prefer slightly lower bitrate for longer recording
        let penalty = 0;
        if (preset.bitrate < targetBitrate) {
            penalty = difference * 0.8; // Prefer lower bitrate
        } else {
            penalty = difference * 1.2; // Penalize higher bitrate
        }
        
        if (penalty < minDifference) {
            minDifference = penalty;
            bestPreset = index;
        }
    });
    
    return { preset: bestPreset };
}

// Apply Auto Config to UI
function applyAutoConfigToUI(configs) {
    if (!configs || configs.length === 0) return;
    
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, index) => {
        if (index >= configs.length) return;
        
        const config = configs[index];
        
        if (config.fixed) {
            // CH2 of JC181 is fixed, skip
            return;
        }
        
        if (currentModel.name === 'JC400') {
            // Set preset
            const presetSelect = div.querySelector('.channel-preset');
            if (presetSelect && config.preset !== undefined) {
                presetSelect.value = config.preset;
            }
        } else {
            // Set resolution, fps, and bitrate
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            
            if (resolutionSelect && config.resolution) {
                resolutionSelect.value = config.resolution;
            }
            
            if (fpsSelect && config.fps) {
                fpsSelect.value = config.fps;
            }
            
            if (bitrateSelect && config.bitrate) {
                // For JC181, need to update bitrates first
                if (currentModel.name === 'JC181' && index === 0) {
                    updateJC181Bitrates(0);
                }
                bitrateSelect.value = config.bitrate;
            }
        }
    });
    
    // Add visual indicator
    channelDivs.forEach(div => {
        div.style.borderColor = '#10b981';
        div.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.2)';
        setTimeout(() => {
            div.style.borderColor = '';
            div.style.boxShadow = '';
        }, 2000);
    });
}

// Show Notification
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 z-50 px-6 py-4 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full';
    
    if (type === 'success') {
        notification.className += ' bg-green-500 text-white';
        notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>' + message;
    } else if (type === 'error') {
        notification.className += ' bg-red-500 text-white';
        notification.innerHTML = '<i class="fas fa-exclamation-circle mr-2"></i>' + message;
    } else {
        notification.className += ' bg-blue-500 text-white';
        notification.innerHTML = '<i class="fas fa-info-circle mr-2"></i>' + message;
    }
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(120%)';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 4000);
}

// Calculate Recording
function calculateRecording() {
    if (!currentModel) return;
    
    const cardSize = parseInt(cardSizeSelect.value);
    const channels = collectChannelData();
    
    if (channels.length === 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, configure pelo menos um canal.' 
            : 'Please configure at least one channel.');
        return;
    }
    
    // Perform calculation (pass dualCard parameter, considering useOneCardOnly)
    const useDualCard = currentModel.dualCard && !useOneCardOnly;
    const results = calculator.calculateTotal(cardSize, channels, useDualCard);
    currentConfig = { modelName: currentModel.name, results, channels };
    
    // Display results
    displayResults(results);
    
    // Show results section
    resultsSection.classList.remove('hidden');
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    saveState();
}

// Calculate Reverse Mode
// Collect Channel Data
function collectChannelData() {
    const channels = [];
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, index) => {
        const channelInfo = currentModel.channels 
            ? currentModel.channels[index] 
            : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
        
        // JC181 - CH2 is fixed
        if (currentModel.name === 'JC181' && index === 1) {
            channels.push({
                active: true,
                channelId: 'CH2',
                channelName: 'CH2 - Internal Camera',
                resolution: '360',
                fps: 25,
                bitrate: 0.5,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: true
            });
            return;
        }
        
        if (currentModel.name === 'JC400') {
            const presetSelect = div.querySelector('.channel-preset');
            const selectedOption = presetSelect.options[presetSelect.selectedIndex];
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                preset: presetSelect.value,
                resolution: selectedOption.dataset.resolution,
                fps: parseInt(selectedOption.dataset.fps),
                bitrate: parseFloat(selectedOption.dataset.bitrate),
                codec: 'H.264',
                codecMultiplier: 1
            });
        } else {
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            const codecSelect = div.querySelector('.channel-codec');
            
            // Skip if elements not found (fixed channel)
            if (!resolutionSelect || !fpsSelect || !bitrateSelect) {
                return;
            }
            
            let bitrate = parseFloat(bitrateSelect.value);
            // Convert Kbps to Mbps for JC450
            if (currentModel.name === 'JC450') {
                bitrate = bitrate / 1024;
            }
            
            let codecMultiplier = 1;
            let codecName = 'H.264';
            if (codecSelect) {
                const selectedCodec = codecSelect.options[codecSelect.selectedIndex];
                codecMultiplier = parseFloat(selectedCodec.dataset.multiplier);
                codecName = selectedCodec.textContent;
            }
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: resolutionSelect.value,
                fps: parseInt(fpsSelect.value),
                bitrate: bitrate,
                codec: codecName,
                codecMultiplier: codecMultiplier
            });
        }
    });
    
    return channels;
}

// Display Results
function displayResults(results) {
    // Update main time display - showing only days and hours
    document.getElementById('totalTimeDays').textContent = results.totalTimeDays.toFixed(1);
    document.getElementById('totalTimeHours').textContent = results.totalTimeHours.toFixed(1);
    
    // Create configuration summary
    const configSummaryDiv = document.getElementById('configSummary');
    configSummaryDiv.innerHTML = '';
    
    // Check if we're in auto mode and show comparison
    const isAutoMode = autoModeBtn && autoModeBtn.classList.contains('active');
    if (isAutoMode && desiredDaysInput && desiredHoursInput) {
        const desiredDays = parseInt(desiredDaysInput.value) || 0;
        const desiredHours = parseInt(desiredHoursInput.value) || 0;
        const totalDesiredHours = (desiredDays * 24) + desiredHours;
        const achievedHours = results.totalTimeHours;
        const difference = achievedHours - totalDesiredHours;
        const percentDiff = ((achievedHours / totalDesiredHours) - 1) * 100;
        
        if (totalDesiredHours > 0) {
            const comparisonBox = document.createElement('div');
            comparisonBox.className = 'mb-4 p-4 rounded-lg border-2 ' + 
                (Math.abs(percentDiff) <= 5 ? 'bg-green-50 border-green-300' : 'bg-blue-50 border-blue-300');
            
            comparisonBox.innerHTML = '<div class="flex items-start">' +
                '<i class="fas fa-chart-line text-2xl mr-3 ' + 
                (Math.abs(percentDiff) <= 5 ? 'text-green-600' : 'text-blue-600') + '"></i>' +
                '<div class="flex-1">' +
                '<h4 class="font-bold text-gray-800 mb-2">' +
                '<i class="fas fa-bullseye mr-2"></i>' +
                (currentLang === 'pt-BR' ? 'Comparação: Tempo Desejado vs Tempo Real Alcançado' : 'Comparison: Desired Time vs Actual Time Achieved') +
                '</h4>' +
                '<div class="grid grid-cols-2 gap-3 text-sm">' +
                '<div class="p-2 bg-white rounded border border-gray-200">' +
                '<div class="text-gray-600 text-xs mb-1">' + 
                (currentLang === 'pt-BR' ? '🎯 Tempo Solicitado:' : '🎯 Requested Time:') + 
                '</div>' +
                '<div class="font-bold text-gray-800">' + 
                totalDesiredHours.toFixed(1) + ' ' + t('hours') + 
                ' <span class="text-xs text-gray-500">(' + desiredDays + 'd ' + (desiredHours) + 'h)</span>' +
                '</div>' +
                '</div>' +
                '<div class="p-2 bg-white rounded border border-gray-200">' +
                '<div class="text-gray-600 text-xs mb-1">' + 
                (currentLang === 'pt-BR' ? '✅ Tempo Alcançado:' : '✅ Time Achieved:') + 
                '</div>' +
                '<div class="font-bold text-gray-800">' + 
                achievedHours.toFixed(1) + ' ' + t('hours') + 
                ' <span class="text-xs text-gray-500">(' + results.totalTimeDays.toFixed(1) + 'd)</span>' +
                '</div>' +
                '</div>' +
                '</div>' +
                '<div class="mt-3 p-2 bg-white rounded text-sm">' +
                '<strong>' + (currentLang === 'pt-BR' ? 'Diferença:' : 'Difference:') + '</strong> ' +
                '<span class="' + (difference >= 0 ? 'text-green-700' : 'text-red-700') + ' font-bold">' +
                (difference >= 0 ? '+' : '') + difference.toFixed(1) + ' ' + t('hours') +
                ' (' + (percentDiff >= 0 ? '+' : '') + percentDiff.toFixed(1) + '%)' +
                '</span>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                '<i class="fas fa-info-circle mr-1"></i>' +
                (currentLang === 'pt-BR' 
                    ? 'Variação devido às configurações discretas disponíveis (resoluções, fps e bitrates fixos).' 
                    : 'Variation due to discrete configurations available (fixed resolutions, fps and bitrates).') +
                '</div>' +
                '</div>' +
                '</div>' +
                '</div>';
            
            configSummaryDiv.appendChild(comparisonBox);
        }
    }
    
    // Card info
    const cardInfo = document.createElement('div');
    cardInfo.className = 'flex items-center p-3 bg-white rounded-lg border border-gray-200';
    cardInfo.innerHTML = '<div class="flex-1">' +
        '<i class="fas fa-sd-card text-blue-500 mr-2"></i>' +
        '<strong>' + t('cardCapacity') + ':</strong> ' + results.cardSizeGB + ' GB' +
        '</div>' +
        '<div class="text-sm text-gray-600">' +
        '<i class="fas fa-check-circle text-green-500 mr-1"></i>' +
        t('usableCapacity') + ': ' + results.availableSpaceMB.toFixed(0) + ' MB (' + results.usablePercentage.toFixed(0) + '%)' +
        '</div>';
    configSummaryDiv.appendChild(cardInfo);
    
    // Channels info
    const channelsDiv = document.createElement('div');
    channelsDiv.className = 'mt-3 space-y-2';
    
    const channelHeader = document.createElement('div');
    channelHeader.className = 'font-bold text-gray-700 mb-2';
    channelHeader.innerHTML = '<i class="fas fa-video text-blue-500 mr-2"></i>' + 
        t('activeChannelsCount') + ': ' + results.activeChannels;
    channelsDiv.appendChild(channelHeader);
    
    results.channelResults.forEach((channel, index) => {
        const channelItem = document.createElement('div');
        channelItem.className = 'flex items-center justify-between p-3 bg-white rounded-lg border border-gray-200';
        
        // Calculate individual channel consumption
        const channelConsumption = (channel.bitrate * 450 * results.totalTimeHours / 1000).toFixed(2);
        
        channelItem.innerHTML = '<div class="flex-1">' +
            '<span class="font-medium text-gray-800">' + channel.channelName + '</span>: ' +
            '<span class="text-gray-600">' + 
            channel.resolution + 'P @ ' + channel.fps + 'fps, ' + 
            channel.bitrate + ' Mbps (' + channel.codec + ')' +
            '</span>' +
            '</div>' +
            '<div class="text-xs text-gray-500 ml-3">' +
            '<i class="fas fa-database mr-1"></i>' +
            channelConsumption + ' GB' +
            '</div>';
        channelsDiv.appendChild(channelItem);
    });
    
    configSummaryDiv.appendChild(channelsDiv);
    
    // Total consumption summary
    const totalConsumption = results.channelResults.reduce((sum, ch) => 
        sum + (ch.bitrate * 450 * results.totalTimeHours / 1000), 0);
    
    const consumptionSummary = document.createElement('div');
    consumptionSummary.className = 'mt-3 p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200';
    consumptionSummary.innerHTML = '<div class="flex items-center justify-between">' +
        '<div>' +
        '<i class="fas fa-chart-pie text-purple-600 mr-2"></i>' +
        '<strong class="text-gray-800">' + (currentLang === 'pt-BR' ? 'Consumo Total:' : 'Total Consumption:') + '</strong>' +
        '</div>' +
        '<div class="text-right">' +
        '<div class="font-bold text-purple-700 text-lg">' + totalConsumption.toFixed(2) + ' GB</div>' +
        '<div class="text-xs text-gray-600">' + 
        (currentLang === 'pt-BR' ? 'Taxa média: ' : 'Average rate: ') +
        (totalConsumption * 1000 / results.totalTimeHours).toFixed(0) + ' MB/h' +
        '</div>' +
        '</div>' +
        '</div>';
    configSummaryDiv.appendChild(consumptionSummary);
    
    // Update command display
    updateCommandDisplay();
}

// Update Command Display
function updateCommandDisplay() {
    if (!currentConfig) return;
    
    const commandDiv = document.getElementById('commandDisplay');
    const commands = currentModel.commandFormat(currentConfig);
    
    commandDiv.innerHTML = commands.split('\n').map(function(cmd) {
        return '<div class="mb-1">' + cmd + '</div>';
    }).join('');
}

// Reset Calculator
function resetCalculator() {
    currentModel = null;
    currentConfig = null;
    
    modelCards.forEach(card => card.classList.remove('active'));
    configSection.classList.add('hidden');
    resultsSection.classList.add('hidden');
    
    // Hide recommended section
    if (recommendedSection) {
        recommendedSection.classList.add('hidden');
    }
    
    if (recordingChart) {
        recordingChart.destroy();
        recordingChart = null;
    }
    
    localStorage.removeItem('dvrCalculatorState');
}

// State Management
function saveState() {
    if (!currentModel) return;
    
    const state = {
        modelName: currentModel.name,
        cardSize: cardSizeSelect.value,
        channelCount: channelCountInput.value
    };
    
    localStorage.setItem('dvrCalculatorState', JSON.stringify(state));
}

function loadSavedState() {
    const savedState = localStorage.getItem('dvrCalculatorState');
    if (savedState) {
        try {
            const state = JSON.parse(savedState);
            if (state.modelName && isValidModel(state.modelName)) {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    selectModel(state.modelName);
                    if (state.cardSize && cardSizeSelect) {
                        cardSizeSelect.value = state.cardSize;
                    }
                    if (state.channelCount && channelCountInput) {
                        channelCountInput.value = state.channelCount;
                    }
                    if (currentModel) {
                        updateChannelConfig();
                    }
                }, 100);
            }
        } catch (e) {
            console.error('Error loading saved state:', e);
            // Clear invalid state
            localStorage.removeItem('dvrCalculatorState');
        }
    }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', init);

