// Main Application Logic
let currentModel = null;
let currentConfig = null;
let recordingChart = null;
let configAlternatives = null;
let autoGeneratedConfig = null; // Auto-generated configuration
let lastTargetBitrate = null; // Last target bitrate for alternatives
let lastDesiredHours = null; // Last desired hours for alternatives
const currentLang = 'pt-BR'; // Fixed to Portuguese
let useOneCardOnly = false; // For JC450 single-card testing
let warningModalShown = false; // Track if warning modal was shown

// Simple translation function (Portuguese only)
function t(key) {
    const translations = {
        'configuration': 'Configuração',
        'fixed_configuration': 'Configuração Fixa',
        'resolution': 'Resolução',
        'fps': 'FPS (Quadros/seg)',
        'bitrate': 'Bitrate (Mbps)',
        'codec': 'Codec',
        'hours': 'horas',
        'days': 'dias',
        'cardCapacity': 'Capacidade do Cartão',
        'usableCapacity': 'Espaço Útil',
        'activeChannelsCount': 'Canais Ativos'
    };
    return translations[key] || key;
}

// Simple warning modal function
function showWarningModal(data) {
    console.log('🚨 showWarningModal called with data:', data);
    
    const modal = document.getElementById('warningModal');
    const desiredTimeEl = document.getElementById('warningDesiredTime');
    const desiredDaysEl = document.getElementById('warningDesiredDays');
    const currentCardEl = document.getElementById('warningCurrentCard');
    const maxTimeEl = document.getElementById('warningMaxTime');
    const maxDaysEl = document.getElementById('warningMaxDays');
    const solutionEl = document.getElementById('warningSolution');
    const closeBtn = document.getElementById('warningModalClose');
    const changeCardBtn = document.getElementById('warningModalChangeCard');
    
    if (!modal || !desiredTimeEl || !desiredDaysEl || !currentCardEl || !maxTimeEl || !maxDaysEl || !solutionEl || !closeBtn || !changeCardBtn) {
        console.error('❌ Warning modal elements not found');
        return;
    }
    
    console.log('🚨 Populating modal fields');
    // Populate the modal fields
    desiredTimeEl.textContent = data.desiredHours.toFixed(1) + ' horas';
    desiredDaysEl.textContent = '(' + data.desiredDays.toFixed(1) + ' dias)';
    currentCardEl.textContent = data.currentCard + ' GB';
    maxTimeEl.textContent = data.maxHours.toFixed(1) + ' horas';
    maxDaysEl.textContent = '(' + data.maxDays.toFixed(1) + ' dias)';
    solutionEl.textContent = data.solution;
    
    modal.classList.remove('hidden');
    
    console.log('✅ Modal classList after remove hidden:', modal.classList);
    console.log('✅ Modal rect:', modal.getBoundingClientRect());
    
    const innerDiv = modal.querySelector('div');
    console.log('✅ Inner div:', innerDiv);
    console.log('✅ Inner div classList:', innerDiv.classList);
    console.log('✅ Inner div rect:', innerDiv.getBoundingClientRect());
    
    // Make inner div visible
    innerDiv.classList.remove('opacity-0', 'scale-95');
    innerDiv.classList.add('opacity-100', 'scale-100');
    
    console.log('✅ Modal shown');
    
    const closeModal = () => {
        console.log('🔒 Closing modal');
        innerDiv.classList.remove('opacity-100', 'scale-100');
        innerDiv.classList.add('opacity-0', 'scale-95');
        modal.classList.add('hidden');
        console.log('✅ Modal hidden');
        // Reset configAlternatives to allow modal to show again on next calculation
        configAlternatives = null;
    };
    
    closeBtn.onclick = closeModal;
    
    changeCardBtn.onclick = () => {
        console.log('🔄 Change card button clicked');
        closeModal();
        // Focus on card size select to allow user to change it
        if (cardSizeSelect) {
            cardSizeSelect.focus();
            cardSizeSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    };
    
    // Close on click outside
    modal.onclick = (e) => {
        if (e.target === modal) {
            closeModal();
        }
    };
}

// DOM Elements (may be null until DOM is ready)
const modelCards = document.querySelectorAll('.model-card');
const configSection = document.getElementById('configSection');
const resultsSection = document.getElementById('resultsSection');
const cardSizeSelect = document.getElementById('cardSize');
const channelConfigDiv = document.getElementById('channelConfig');
const channelPrioritySelect = document.getElementById('channelPrioritySelect');
const channelPriorityDiv = document.getElementById('channelPriorityDiv');
let selectedPriorityChannel = 'free';
let activeChannels = [];
// Common global input references (may be null until DOM ready)
const dailyUsageHoursInput = document.getElementById('dailyUsageHours');
const desiredDaysInput = document.getElementById('desiredDays');
const desiredHoursInput = document.getElementById('desiredHours');
const totalDesiredTimeSpan = document.getElementById('totalDesiredTime');

// Lightweight helper: ensure manual config visibility and active channel checkboxes
function updateManualConfigVisibility() {
    try {
        const manualDiv = document.getElementById('activeChannelsDivManual');
        const checkboxesContainer = document.getElementById('activeChannelsCheckboxesManual');
        if (!manualDiv || !checkboxesContainer || !currentModel) return;

        // Clear existing
        checkboxesContainer.innerHTML = '';

        const num = currentModel.channels ? currentModel.channels.length : (currentModel.maxChannels || 1);
        activeChannels = [];

        for (let i = 0; i < num; i++) {
            const ch = currentModel.channels && currentModel.channels[i];
            const id = `active-ch-${i}`;
            const label = document.createElement('label');
            label.className = 'flex items-center space-x-2';

            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = id;
            input.checked = true;
            input.dataset.channel = String(i);
            input.addEventListener('change', (e) => {
                const idx = Number(e.target.dataset.channel);
                if (e.target.checked) {
                    if (!activeChannels.includes(idx)) activeChannels.push(idx);
                } else {
                    activeChannels = activeChannels.filter(x => x !== idx);
                }
                saveState();
                // Rebuild channel cards to reflect the new activeChannels selection
                try { updateChannelConfig(); } catch (err) { console.warn('Could not update channel config after checkbox change', err); }
            });

            const span = document.createElement('span');
            span.className = 'text-sm text-gray-700';
            span.textContent = ch && ch.name ? ch.name : `Canal ${i + 1}`;

            label.appendChild(input);
            label.appendChild(span);
            checkboxesContainer.appendChild(label);

            activeChannels.push(i);
        }

        // Show the manual active channels area
        manualDiv.classList.remove('hidden');
    } catch (e) {
        console.warn('updateManualConfigVisibility failed:', e);
    }
}

// Attach listeners to newly created channel inputs so changes persist and can trigger recalculation
function attachChannelInputListeners() {
    try {
        const container = document.getElementById('channelConfig');
        if (!container) return;

        const selects = container.querySelectorAll('select');
        selects.forEach(sel => {
            // Avoid duplicate listeners by cloning and replacing
            const newSel = sel.cloneNode(true);
            sel.parentNode.replaceChild(newSel, sel);
            newSel.addEventListener('change', (e) => {
                // Special-case JC181 resolution change handler
                const chIdx = newSel.dataset.channel ? Number(newSel.dataset.channel) : null;
                if (currentModel && currentModel.name === 'JC181' && newSel.classList.contains('channel-resolution') && chIdx === 0) {
                    try { updateJC181Bitrates(0); } catch (err) { /* ignore */ }
                }
                saveState();
            });
        });
    } catch (e) {
        console.warn('attachChannelInputListeners failed:', e);
    }
}

// Update Channel Priority Options
function updateChannelPriorityOptions() {
    if (!channelPrioritySelect || !channelPriorityDiv || !currentModel) return;
    
    // Clear existing options
    channelPrioritySelect.innerHTML = '';
    
    // Add "free" option (default)
    const freeOption = document.createElement('option');
    freeOption.value = 'free';
    freeOption.textContent = '🎨 Livre - Bitrates diferentes (mais próximo do tempo)';
    channelPrioritySelect.appendChild(freeOption);
    
    // Add "equal quality" option
    const equalOption = document.createElement('option');
    equalOption.value = 'equal';
    equalOption.textContent = '🎥 Todas as câmeras com mesma qualidade';
    channelPrioritySelect.appendChild(equalOption);
    
    // Add option for each channel (if model has multiple channels)
    if (currentModel.channels && currentModel.channels.length > 1) {
        currentModel.channels.forEach((channel, index) => {
            const option = document.createElement('option');
            option.value = index.toString();
            option.textContent = `⭐ Priorizar ${channel.name || `Canal ${index + 1}`}`;
            channelPrioritySelect.appendChild(option);
        });
        
        // Show the priority selector
        channelPriorityDiv.classList.remove('hidden');
    } else {
        // Hide if only one channel
        channelPriorityDiv.classList.add('hidden');
    }
    
    // Reset selection to free (default)
    selectedPriorityChannel = 'free';
    channelPrioritySelect.value = 'free';
}

// Render Preset Cards
// Preset functions removed - always use manual configuration

// Setup Manual Configuration (always active now)

// Setup Manual Configuration
function setupManualConfiguration() {
    console.log('Setting up manual configuration for:', currentModel.name);
    
    // Ensure active-channel checkboxes exist before creating channel cards
    updateManualConfigVisibility();

    // Simply update channel config - no need for channel count input anymore
    updateChannelConfig();
    console.log('Manual configuration setup complete');
    
    // Update visibility based on active channels
    updateManualConfigVisibility();

}

// Update Channel Configuration
function updateChannelConfig() {
    if (!channelConfigDiv || !currentModel) {
        console.warn('Cannot update channel config: missing elements or model');
        return;
    }
    
    channelConfigDiv.innerHTML = '';

    // Recompute activeChannels from the manual checkboxes if present to keep UI state authoritative
    const manualCheckboxes = document.querySelectorAll('#activeChannelsCheckboxesManual input[type="checkbox"]');
    const numChannels = currentModel.channels ? currentModel.channels.length : currentModel.maxChannels;
    if (manualCheckboxes && manualCheckboxes.length > 0) {
        activeChannels = Array.from(manualCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => Number(cb.dataset.channel))
            .filter(i => !Number.isNaN(i) && i >= 0 && i < numChannels);
    }

    // If still empty (first run), default to all channels.
    if (!Array.isArray(activeChannels) || activeChannels.length === 0) {
        activeChannels = Array.from({ length: numChannels }, (_, i) => i);
    }

    console.log(`Creating ${activeChannels.length} channel cards for ${currentModel.name} (from ${numChannels} total)`);

    // Create a card only for each active channel index (preserve original order)
    const sortedActive = Array.from(new Set(activeChannels.map(Number))).sort((a,b) => a - b);
    sortedActive.forEach(i => {
        if (i < 0 || i >= numChannels) return;
        const channelCard = createChannelCard(i);
        channelConfigDiv.appendChild(channelCard);
    });
    
    // Attach listeners to newly created inputs so changes auto-trigger calculation
    setTimeout(() => attachChannelInputListeners(), 0);

    saveState();
}

// Create Channel Configuration Card
function createChannelCard(index) {
    const card = document.createElement('div');
    card.className = 'channel-config-card';
    
    const channelInfo = currentModel.channels 
        ? currentModel.channels[index] 
        : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
    
    card.innerHTML = `
        <h4 class="font-bold text-gray-800 mb-3">
            <i class="fas fa-video text-blue-500"></i> ${channelInfo.name}
        </h4>
        <div class="space-y-3" id="channel-${index}">
            ${generateChannelInputs(index, channelInfo)}
        </div>
    `;
    
    return card;
}

// Generate Channel Inputs based on Model
function generateChannelInputs(index, channelInfo) {
    if (currentModel.name === 'JC400') {
        return generateJC400Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC181') {
        return generateJC181Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC371') {
        return generateJC371Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC450') {
        return generateJC450Inputs(index, channelInfo);
    }
    return '';
}

// JC400 Preset Selection
function generateJC400Inputs(index, channelInfo) {
    console.log('JC400 Channel', index, 'Info:', channelInfo);
    
    if (!channelInfo || !channelInfo.presets) {
        console.error('No presets found for JC400 channel', index);
        return '<p class="text-red-500">Erro: Presets não encontrados</p>';
    }
    
    const presets = channelInfo.presets.map(preset => 
        `<option value="${preset.value}" data-resolution="${preset.resolution}" data-bitrate="${preset.bitrate}" data-fps="${preset.fps}">
            ${preset.label}
        </option>`
    ).join('');
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('configuration')}</label>
            <select class="channel-preset w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${presets}
            </select>
        </div>
    `;
}

// JC181 Inputs
function generateJC181Inputs(index, channelInfo) {
    console.log('JC181 Channel', index, 'Info:', channelInfo);
    
    // Get the specific channel configuration from the model
    const channelConfig = currentModel.channels[index];
    
    console.log('JC181 Channel Config:', channelConfig);
    
    // Check if this channel is fixed (CH2 is always 360P@0.5M)
    if (channelConfig.fixed) {
        return `
            <div class="bg-yellow-50/20 border border-yellow-300 rounded-lg p-3">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-lock"></i> <strong>${t('fixed_configuration')}:</strong><br>
                    360P (640×360) @ 0.5 Mbps, 25 FPS
                </p>
            </div>
        `;
    }
    
    // CH1 is configurable
    const resolutionOptions = channelConfig.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    // Get default FPS and bitrates from first resolution
    const defaultFps = channelConfig.fps || [15, 25, 30];
    // Use bitrates from first resolution (480P) - updateJC181Bitrates will change when user selects different resolution
    const defaultBitrates = channelConfig.resolutions[0].bitrates || [1, 2, 4];
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
            <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}" onchange="updateJC181Bitrates(${index})">
                ${resolutionOptions}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('fps')}</label>
            <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultFps.map(fps => `<option value="${fps}">${fps} FPS</option>`).join('')}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('bitrate')}</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultBitrates.map(br => `<option value="${br}">${br} Mbps</option>`).join('')}
            </select>
        </div>
    `;
}

// Update JC181 bitrates when resolution changes
window.updateJC181Bitrates = function(channelIndex) {
    const channelConfig = currentModel.channels[channelIndex];
    const resolutionSelect = document.querySelector(`.channel-resolution[data-channel="${channelIndex}"]`);
    const bitrateSelect = document.querySelector(`.channel-bitrate[data-channel="${channelIndex}"]`);
    
    if (!resolutionSelect || !bitrateSelect) return;
    
    const selectedResolution = resolutionSelect.value;
    const resConfig = channelConfig.resolutions.find(r => r.value === selectedResolution);
    
    if (resConfig && resConfig.bitrates) {
        bitrateSelect.innerHTML = resConfig.bitrates.map(br => 
            `<option value="${br}">${br} Mbps</option>`
        ).join('');
    }
}

// JC371 Inputs
function generateJC371Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    const codecOptions = currentModel.codecs.map(codec => 
        `<option value="${codec.value}" data-multiplier="${codec.multiplier}">${codec.label}</option>`
    ).join('');
    
    // Get all unique bitrates across all resolutions (0.5-8 Mbps)
    const allBitrates = [...new Set(currentModel.resolutions.flatMap(r => r.bitrates))].sort((a, b) => a - b);
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">Bitrate (Mbps)</label>
                <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${allBitrates.map(br => `<option value="${br}">${br}</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('codec')}</label>
                <select class="channel-codec w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${codecOptions}
                </select>
            </div>
        </div>
    `;
}

// JC450 Inputs
function generateJC450Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">Bitrate</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${currentModel.resolutions[0].bitrates.map(br => `<option value="${br}">${br}M</option>`).join('')}
            </select>
        </div>
        <div class="mt-1">
            <div class="channel-multiplier text-xs text-gray-600" data-channel="${index}"></div>
        </div>
    `;
}

// Update Total Desired Time Display
function updateTotalDesiredTime() {
    if (!desiredDaysInput || !desiredHoursInput || !totalDesiredTimeSpan) return;
    
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    const dailyUsageHours = parseFloat(dailyUsageHoursInput?.value) || 24;
    
    // Calculate total recording hours based on daily usage
    const totalHours = (days * dailyUsageHours) + hours;
    
    const hoursText = t('hours');
    
    if (dailyUsageHours === 24) {
        // If 24h/day, show traditional format
        totalDesiredTimeSpan.textContent = totalHours + ' ' + hoursText + ' (' + days + 'd ' + hours + 'h)';
    } else {
        // If custom daily usage, show calculation
        totalDesiredTimeSpan.textContent = totalHours.toFixed(1) + ' ' + hoursText + 
            ' (' + days + 'd × ' + dailyUsageHours + 'h/dia' + (hours > 0 ? ' + ' + hours + 'h' : '') + ')';
    }
}

// Generate Auto Configuration
function generateAutoConfig() {
    console.log('🔢 [AUTO] generateAutoConfig called');
    console.log('Current Model:', currentModel);
    
    // Reset warning modal flag
    warningModalShown = false;
    
    if (!currentModel) {
        console.error('No model selected!');
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, selecione um modelo primeiro.' 
            : 'Please select a model first.');
        return;
    }
    
    // Read current priority selection (in case it wasn't captured by event listener)
    if (channelPrioritySelect) {
        selectedPriorityChannel = channelPrioritySelect.value;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    
    // Get daily usage hours
    const dailyUsageHours = parseFloat(dailyUsageHoursInput?.value) || 24;
    
    // Calculate total recording hours based on daily usage
    // If user wants 50 days with 6h/day usage, total recording time = 50 * 6 = 300 hours
    const totalDesiredHours = (days * dailyUsageHours) + hours;
    
    console.log('Card Size:', cardSize, 'GB');
    console.log('Daily Usage Hours:', dailyUsageHours, 'h/day');
    console.log('Desired Time:', totalDesiredHours, 'hours', '(' + days + 'd × ' + dailyUsageHours + 'h/day + ' + hours + 'h extra)');
    
    if (totalDesiredHours <= 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, informe um tempo desejado maior que zero.' 
            : 'Please enter a desired time greater than zero.');
        return;
    }
    
    // Get number of channels for this model
    const numChannels = currentModel.channels ? currentModel.channels.length : currentModel.maxChannels || 1;
    
    // Generate ALL possible configurations
    const allPossibleConfigs = generateAllPossibleConfigs(numChannels);
    
    console.log('Generated', allPossibleConfigs.length, 'possible configurations');
    if (allPossibleConfigs.length > 0) {
        console.log('Sample configs:', allPossibleConfigs.slice(0, 3).map(c => 
            c.configs.filter(ch => ch !== null).map(ch => `${ch.resolution}P@${ch.bitrate}M`).join(', ')
        ));
    }
    console.log('🎯 Priority setting:', 
        selectedPriorityChannel === 'free' ? 'FREE MODE (different bitrates allowed)' :
        selectedPriorityChannel === 'equal' ? 'EQUAL (all same)' : 
        `CHANNEL ${selectedPriorityChannel} gets higher quality`);
    
    if (selectedPriorityChannel === 'free') {
        const priorityOrder = getChannelPriorityOrder();
        const channelNames = priorityOrder.map(chIdx => {
            const ch = currentModel.channels?.[chIdx];
            return ch ? (ch.name || `CH${chIdx + 1}`) : `CH${chIdx + 1}`;
        });
        console.log('   📊 Channel priority order (highest to lowest):', channelNames.join(' > '));
    }
    
    if (allPossibleConfigs.length === 0) {
        alert(currentLang === 'pt-BR'
            ? 'Erro ao gerar configurações. Verifique se o modelo está configurado corretamente.'
            : 'Error generating configurations. Check if the model is configured correctly.');
        return;
    }
    
    // Calculate actual recording time for each configuration and find the closest
    // Priority: configurations that meet or exceed the desired time
    let bestConfig = null;
    let minTimeDifference = Infinity;
    
    // First pass: try to find configs that meet or exceed the desired time
    const validConfigs = [];
    
    allPossibleConfigs.forEach(configSet => {
        const channels = configSet.configs
            .map((config, index) => {
                // Skip null configs (inactive channels)
                if (config === null) return null;
                
                const channelInfo = currentModel.channels && currentModel.channels[index] 
                    ? currentModel.channels[index] 
                    : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
                
                // Handle JC400 preset-based configuration
                if (currentModel.name === 'JC400' && config.preset !== undefined) {
                    const presetData = channelInfo.presets[config.preset];
                    return {
                        active: true,
                        channelId: channelInfo.id,
                        channelName: channelInfo.name,
                        resolution: presetData.resolution.toString(),
                        fps: presetData.fps,
                        bitrate: presetData.bitrate,
                        codec: 'H.264',
                        codecMultiplier: 1,
                        preset: config.preset
                    };
                }
                
                // Handle standard resolution/fps/bitrate configuration
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: config.resolution.toString(),
                    fps: config.fps,
                    bitrate: config.bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    fixed: config.fixed || false
                };
            })
            .filter(ch => ch !== null); // Remove null entries
        
        // Calculate recording time based on model type
        let results;
        if (currentModel.name === 'JC450') {
            // Use JC450-specific dual card calculation
            results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
        } else {
            // Use regular calculation for other models
            const useDualCard = currentModel.dualCard && !useOneCardOnly;
            results = calculator.calculateTotal(cardSize, channels, useDualCard, { modelId: (currentModel.name || '').toLowerCase() });
        }
        
        configSet.calculatedTime = results.totalTimeHours;
        configSet.channels = channels;
        
        // Store all configs for later analysis
        if (results.totalTimeHours >= totalDesiredHours) {
            validConfigs.push(configSet);
        }
    });
    
    // If no configs meet the requirement, accept configs within 20% below desired
    if (validConfigs.length === 0) {
        const tolerance = totalDesiredHours * 0.2; // 20% below
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime >= totalDesiredHours - tolerance) {
                validConfigs.push(configSet);
            }
        });
        if (validConfigs.length > 0) {
            console.log(`⚠️ No configs >= ${totalDesiredHours}h. Accepting configs within 20% (>= ${(totalDesiredHours - tolerance).toFixed(1)}h)`);
        }
    }
    
    // If we have configs that meet the requirement, pick the closest one
    if (validConfigs.length > 0) {
        const sortedValid = validConfigs.map(c => c.calculatedTime).sort((a, b) => a - b);
        console.log(`✅ Found ${validConfigs.length} configs >= ${totalDesiredHours}h:`, sortedValid.map(t => t.toFixed(1) + 'h').join(', '));
        console.log(`   Selecting closest to ${totalDesiredHours}h...`);
        
        // STRATEGY: ALWAYS prioritize proximity to desired time above all else
        // Then use channel priority as a tiebreaker for configs with similar times
        
        // Find the closest config to desired time
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        
        if (priorityChannelIndex === -2) {
            // FREE MODE: First find configs within 5% of the closest time, then apply priority scoring
            const closestTime = Math.min(...validConfigs.map(c => c.calculatedTime));
            const timeThreshold = closestTime * 1.05; // Within 5% of closest
            
            // Filter configs within time threshold
            const nearestConfigs = validConfigs.filter(c => c.calculatedTime <= timeThreshold);
            
            console.log(`   📍 Closest time: ${closestTime.toFixed(1)}h, threshold: ${timeThreshold.toFixed(1)}h`);
            console.log(`   🎯 ${nearestConfigs.length} configs within 5% of closest time`);
            
            let bestScore = -Infinity;
            const scoredConfigs = []; // Track all configs with scores
            
            nearestConfigs.forEach(configSet => {
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive = above desired
                const totalScore = calculateFreeModeScore(configSet, timeDifference);
                
                scoredConfigs.push({
                    config: configSet,
                    score: totalScore,
                    timeDiff: timeDifference
                });
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            });
            
            // Log top 3 configurations for debugging
            scoredConfigs.sort((a, b) => b.score - a.score);
            console.log('   🏆 Top 3 configurations by score (within time threshold):');
            scoredConfigs.slice(0, 3).forEach((item, index) => {
                const bitrates = item.config.configs.map(c => `${c?.bitrate || 0}M`).join(', ');
                console.log(`   ${index + 1}. Score: ${item.score.toFixed(0)} | Time: ${item.config.calculatedTime.toFixed(1)}h | Bitrates: ${bitrates}`);
            });
            
            // Show detailed scoring for winner
            console.log('   🎯 Detailed scoring for selected config:');
            calculateFreeModeScore(bestConfig, bestConfig.calculatedTime - totalDesiredHours, true);
            
            console.log('   🎨 Free mode: Selected config closest to desired time with best priority scores');
        } else if (priorityChannelIndex >= 0) {
            // Priority mode: find config >= desired time with best score (close to time + high priority bitrate)
            let bestScore = -Infinity;
            validConfigs.forEach(configSet => {
                // Penalize configs that are far from desired time
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive = above desired
                const priorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                
                // Score: prefer closer to desired time, then higher priority bitrate
                // Use exponential penalty for time difference to strongly prefer closer times
                const timeScore = 10000 / (1 + timeDifference); // Closer = higher score
                const bitrateScore = priorityBitrate * 100; // Higher bitrate = higher score
                const totalScore = timeScore + bitrateScore;
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            });
        } else {
            // No priority - just pick the one closest to (but >= ) desired time
            let minDiff = Infinity;
            validConfigs.forEach(configSet => {
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive value
                if (timeDifference < minDiff) {
                    minDiff = timeDifference;
                    bestConfig = configSet;
                }
            });
        }
    } else {
        // No config meets the requirement - find the one closest to target
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        let bestScore = -Infinity;
        
        allPossibleConfigs.forEach(configSet => {
            // Find config closest to desired time
            const timeDifference = Math.abs(configSet.calculatedTime - totalDesiredHours);
            
            if (priorityChannelIndex === -2) {
                // FREE MODE: Use channel priority order
                const totalScore = calculateFreeModeScore(configSet, timeDifference);
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            } else if (priorityChannelIndex >= 0 && configSet.configs[priorityChannelIndex]) {
                const priorityBitrate = configSet.configs[priorityChannelIndex].bitrate || 0;
                
                // Prioritize time proximity, then bitrate
                const timeScore = 1000 / (1 + timeDifference); // Closer time = higher score
                const bitrateScore = priorityBitrate * 10;
                const totalScore = timeScore + bitrateScore;
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            } else {
                // No priority - pick closest to time
                const score = 1000 / (1 + timeDifference);
                if (score > bestScore) {
                    bestScore = score;
                    bestConfig = configSet;
                }
            }
        });
    }
    
    // Use the best configuration found
    autoGeneratedConfig = bestConfig ? bestConfig.configs : generateConfigForModel(0, numChannels);
    
    // Find alternative configurations (one above, one below)
    let alternativeHigher = null;
    let alternativeLower = null;
    
    if (bestConfig) {
        const bestTime = bestConfig.calculatedTime;
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        // Find configuration with higher time (closer to desired if below, or slightly above)
        let minHigherDiff = Infinity;
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime > bestTime) {
                const diff = configSet.calculatedTime - bestTime;
                if (diff < minHigherDiff) {
                    // If priority enabled, check if priority channel has same or higher bitrate
                    if (priorityChannelIndex >= 0) {
                        const bestPriorityBitrate = bestConfig.configs[priorityChannelIndex]?.bitrate || 0;
                        const altPriorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                        if (altPriorityBitrate >= bestPriorityBitrate * 0.8) { // Allow 20% lower
                            minHigherDiff = diff;
                            alternativeHigher = configSet;
                        }
                    } else {
                        minHigherDiff = diff;
                        alternativeHigher = configSet;
                    }
                }
            }
        });
        
        // Find configuration with lower time
        let minLowerDiff = Infinity;
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime < bestTime) {
                const diff = bestTime - configSet.calculatedTime;
                if (diff < minLowerDiff) {
                    // If priority enabled, prefer higher priority bitrate
                    if (priorityChannelIndex >= 0) {
                        const altPriorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                        const currentAltBitrate = alternativeLower?.configs[priorityChannelIndex]?.bitrate || 0;
                        if (altPriorityBitrate >= currentAltBitrate) {
                            minLowerDiff = diff;
                            alternativeLower = configSet;
                        }
                    } else {
                        minLowerDiff = diff;
                        alternativeLower = configSet;
                    }
                }
            }
        });
    }
    
    // Calculate TRUE MAXIMUM time possible (all channels at minimum bitrate)
    const maxPossibleConfig = allPossibleConfigs.reduce((max, config) => {
        return (!max || config.calculatedTime > max.calculatedTime) ? config : max;
    }, null);
    
    const maxPossibleTime = maxPossibleConfig ? maxPossibleConfig.calculatedTime : 0;
    console.log(`⏱️ TRUE MAXIMUM time possible: ${maxPossibleTime.toFixed(1)}h (all channels at minimum bitrate)`);
    
    // Check if desired time is impossible even with minimum bitrates
    if (maxPossibleTime < totalDesiredHours) {
        const timeDifferencePercent = ((totalDesiredHours - maxPossibleTime) / totalDesiredHours) * 100;
        console.log(`⚠️ WARNING: Desired time ${totalDesiredHours.toFixed(1)}h exceeds maximum possible ${maxPossibleTime.toFixed(1)}h (${timeDifferencePercent.toFixed(0)}% over)`);
        
        // Show warning modal
        const availableCardSizes = currentModel.cardSizes || [16, 32, 64, 128, 256];
        const currentCardIndex = availableCardSizes.indexOf(cardSize);
        const nextCardSize = currentCardIndex < availableCardSizes.length - 1 
            ? availableCardSizes[currentCardIndex + 1] 
            : null;
        
        let solutionText = '';
        if (nextCardSize) {
            solutionText = currentLang === 'pt-BR'
                ? 'Use um cartão SD de ' + nextCardSize + 'GB ou maior para atingir o tempo desejado.'
                : 'Use an SD card of ' + nextCardSize + 'GB or larger to achieve the desired time.';
        } else {
            solutionText = currentLang === 'pt-BR'
                ? 'Use o maior cartão SD disponível (' + availableCardSizes[availableCardSizes.length - 1] + 'GB) ou reduza o tempo desejado de gravação.'
                : 'Use the largest available SD card (' + availableCardSizes[availableCardSizes.length - 1] + 'GB) or reduce the desired recording time.';
        }
        
        console.log('🔢 [AUTO] Desired time', totalDesiredHours, 'exceeds max possible', maxPossibleTime, '- showing warning modal');
        
        warningModalShown = true; // Mark that modal was shown
        showWarningModal({
            desiredHours: totalDesiredHours,
            desiredDays: totalDesiredHours / dailyUsageHours,
            currentCard: cardSize,
            maxHours: maxPossibleTime,
            maxDays: maxPossibleTime / dailyUsageHours,
            solution: solutionText
        });
        
        return; // Don't proceed with calculation - time exceeds card capacity
    }
    
    // Log selected configuration and alternatives
    if (bestConfig) {
        console.log('✅ Selected configuration:');
        bestConfig.configs.forEach((config, i) => {
            if (config) {
                const isPriority = (selectedPriorityChannel !== 'equal' && i === parseInt(selectedPriorityChannel));
                console.log(`   CH${i}: ${config.resolution || config.preset}@${config.fps || 0}fps, ${config.bitrate}M ${isPriority ? '← PRIORITY' : ''}`);
            }
        });
        console.log(`   Total time: ${bestConfig.calculatedTime.toFixed(1)} hours (desired: ${totalDesiredHours.toFixed(1)}h)`);
        
        if (alternativeHigher) {
            console.log('📈 Alternative (higher time): ' + alternativeHigher.calculatedTime.toFixed(1) + 'h');
        }
        if (alternativeLower) {
            console.log('📉 Alternative (lower time): ' + alternativeLower.calculatedTime.toFixed(1) + 'h');
        }
    }
    
    // Store alternatives temporarily (will be added to currentConfig later)
    configAlternatives = {
        bestConfig: bestConfig,
        alternativeHigher: alternativeHigher,
        alternativeLower: alternativeLower,
        desiredTime: totalDesiredHours
    };
    
    // Check if the best configuration can achieve the desired time
    if (bestConfig && bestConfig.calculatedTime) {
        const maxPossibleTime = bestConfig.calculatedTime;
        const timeDifferencePercent = ((totalDesiredHours - maxPossibleTime) / totalDesiredHours) * 100;
        
        // If the best possible configuration is still far from the target (more than 30% less)
        if (maxPossibleTime < totalDesiredHours && timeDifferencePercent > 30) {
            const availableCardSizes = currentModel.cardSizes || [16, 32, 64, 128, 256];
            const currentCardIndex = availableCardSizes.indexOf(cardSize);
            const nextCardSize = currentCardIndex < availableCardSizes.length - 1 
                ? availableCardSizes[currentCardIndex + 1] 
                : null;
            
            let solutionText = '';
            if (nextCardSize) {
                solutionText = currentLang === 'pt-BR'
                    ? `Use um cartão SD de ${nextCardSize}GB ou maior para atingir o tempo desejado.`
                    : `Use an SD card of ${nextCardSize}GB or larger to achieve the desired time.`;
            } else {
                solutionText = currentLang === 'pt-BR'
                    ? `Use o maior cartão SD disponível (${availableCardSizes[availableCardSizes.length - 1]}GB) ou reduza o tempo desejado de gravação.`
                    : `Use the largest available SD card (${availableCardSizes[availableCardSizes.length - 1]}GB) or reduce the desired recording time.`;
            }
            
            console.log('🔢 [AUTO] Best config time', maxPossibleTime, 'still < desired', totalDesiredHours, '- showing warning modal');
            
            // Show modal instead of alert
            warningModalShown = true; // Mark that modal was shown
            showWarningModal({
                desiredHours: totalDesiredHours,
                desiredDays: totalDesiredHours / 24,
                currentCard: cardSize,
                maxHours: maxPossibleTime,
                maxDays: maxPossibleTime / 24,
                solution: solutionText
            });
            
            return; // Don't proceed with calculation
        }
    }
    
    // Calculate required bitrate for display purposes
    const MB_PER_GB = 1000;
    const availableSpaceMB = cardSize * MB_PER_GB * 0.9;
    const requiredTotalMBh = availableSpaceMB / totalDesiredHours;
    
    // Count only active channels (for JC181/JC400)
    const activeChannelCount = (currentModel.id === 'jc181' || currentModel.id === 'jc400') 
        ? activeChannels.length 
        : numChannels;
    
    const requiredMBhPerChannel = requiredTotalMBh / activeChannelCount;
    const requiredBitratePerChannel = requiredMBhPerChannel / 450;
    
    // Display suggested configurations on the right side
    displaySuggestedConfigs(autoGeneratedConfig, requiredBitratePerChannel, totalDesiredHours);
}

// Display Suggested Configurations
function displaySuggestedConfigs(configs, targetBitrate, desiredHours) {
    console.log('📋 displaySuggestedConfigs() called');
    console.log('   Auto mode: desiredHours =', desiredHours);
    console.log('   targetBitrate =', targetBitrate);
    
    // If warning modal was shown, don't display configurations
    if (warningModalShown) {
        console.log('   ⚠️ Warning modal was shown - skipping configuration display');
        return;
    }
    
    const channelConfigDiv = document.getElementById('channelConfig');
    if (!channelConfigDiv) return;
    
    // Store for recommended alternatives
    lastTargetBitrate = targetBitrate;
    lastDesiredHours = desiredHours;
    
    console.log('   ✅ Stored lastTargetBitrate:', lastTargetBitrate);
    console.log('   ✅ Stored lastDesiredHours:', lastDesiredHours);
    
    channelConfigDiv.innerHTML = '';
    
    // Header with Jimi blue colors
    const header = document.createElement('div');
    header.className = 'mb-4 p-4 text-white rounded-lg';
    header.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
    header.innerHTML = '<h3 class="text-lg font-bold mb-2">' +
        '<i class="fas fa-lightbulb mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Outras Opções' : 'Other Options') +
        '</h3>' +
        '<p class="text-sm opacity-90">' +
        (currentLang === 'pt-BR' 
            ? 'Outras configurações disponíveis para o cartão selecionado' 
            : 'Other available configurations for the selected card') +
        '</p>' +
        '<p class="text-xs mt-1 opacity-80">' +
        (currentLang === 'pt-BR' 
            ? 'Explore diferentes combinações de qualidade e tempo de gravação' 
            : 'Explore different combinations of quality and recording time') +
        '</p>';
    channelConfigDiv.appendChild(header);
    
    // Configuration cards (without GB consumption)
    configs.forEach((config, index) => {
        // Skip null configs (inactive channels)
        if (config === null) return;
        
        const card = document.createElement('div');
        card.className = 'p-4 bg-white rounded-lg shadow-md mb-3';
        card.style.border = '2px solid #0066CC';
        
        const channelName = currentModel.channels && currentModel.channels[index] 
            ? currentModel.channels[index].name 
            : 'Canal ' + (index + 1);
        
        const isFixed = config.fixed || (currentModel.name === 'JC181' && index === 1);
        
        // Get actual config values (handle JC400 presets)
        let resolution, fps, bitrate;
        if (currentModel.name === 'JC400' && config.preset !== undefined) {
            const channelInfo = currentModel.channels[index];
            const presetData = channelInfo.presets[config.preset];
            resolution = presetData.resolution;
            fps = presetData.fps;
            bitrate = presetData.bitrate;
        } else {
            resolution = config.resolution;
            fps = config.fps;
            bitrate = config.bitrate;
        }
        
        // Calculate MB/h consumption
        const consumptionMBh = bitrate * 450; // 1 Mbps = 450 MB/h
        
        card.innerHTML = '<div class="flex items-center justify-between mb-3">' +
            '<h4 class="font-bold text-gray-800">' +
            '<i class="fas fa-video mr-2" style="color: #0066CC;"></i>' +
            channelName +
            '</h4>' +
            (isFixed ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded">' + t('fixed_configuration') + '</span>' : '') +
            '</div>' +
            '<div class="space-y-2 text-sm text-gray-700">' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-image text-blue-500 mr-2"></i>' + t('resolution') + ':</span>' +
            '<strong>' + resolution + 'P</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-tachometer-alt text-green-500 mr-2"></i>FPS:</span>' +
            '<strong>' + fps + ' fps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-signal text-purple-500 mr-2"></i>Bitrate:</span>' +
            '<strong>' + bitrate + ' Mbps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 rounded" style="background-color: #E6F0FF; border: 1px solid #0066CC;">' +
            '<span><i class="fas fa-clock mr-2" style="color: #0066CC;"></i>' + 
            (currentLang === 'pt-BR' ? 'Taxa de gravação:' : 'Recording rate:') + '</span>' +
            '<strong style="color: #0052A3;">' + consumptionMBh.toFixed(0) + ' MB/h</strong>' +
            '</div>' +
            '</div>';
        
        channelConfigDiv.appendChild(card);
    });
    
    // Calculate directly without using applyAutoConfigToUI to avoid showing channel selectors
    console.log('⏰ Calling calculateAutoConfig() directly...');
    console.log('   autoGeneratedConfig:', configs);
    calculateAutoConfig(configs);
}

// Calculate Auto Config directly
function calculateAutoConfig(configs) {
    console.log('🚀 calculateAutoConfig() called');
    console.log('   configs:', configs);
    
    if (!configs || configs.length === 0) {
        console.log('   ❌ Exiting - no configs provided');
        return;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Build channels array from auto-generated configs (filter out null/inactive channels)
    const channels = configs
        .map((config, index) => {
            // Skip null configs (inactive channels)
            if (config === null) return null;
            
            const channelInfo = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index] 
                : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
            
            return {
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: config.resolution.toString(),
                fps: config.fps,
                bitrate: config.bitrate,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: config.fixed || false,
                preset: config.preset
            };
        })
        .filter(ch => ch !== null); // Remove null entries
    
    // Perform calculation (pass dualCard parameter, considering useOneCardOnly)
    let results;
    if (currentModel.name === 'JC450') {
        // Use JC450-specific dual card calculation
        // Ensure calculator knows which model we're calculating for
        calculator.updateConfig({ currentModelId: (currentModel.name || '').toLowerCase() });
        results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
    } else {
        // Use regular calculation for other models
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        // Inform calculator of current model so it applies the unified CBR logic for legacy models
        calculator.updateConfig({ currentModelId: (currentModel.name || '').toLowerCase() });
        results = calculator.calculateTotal(cardSize, channels, useDualCard, { modelId: (currentModel.name || '').toLowerCase() });
    }
    
    currentConfig = { 
        modelName: currentModel.name, 
        results, 
        channels,
        // Add alternatives from auto-config if available
        bestConfig: configAlternatives?.bestConfig,
        alternativeHigher: configAlternatives?.alternativeHigher,
        alternativeLower: configAlternatives?.alternativeLower,
        desiredTime: configAlternatives?.desiredTime
    };
    
    // Display the detailed results after currentConfig is populated
    resultsSection.classList.remove('hidden');
    displayResults(currentConfig.results);
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    console.log('✅ calculateAutoConfig() finished successfully');
}

// Show More Alternatives (Outras Opções)
function showMoreAlternatives() {
    try {
        console.log('🔍 showMoreAlternatives() called');
        console.log('   lastTargetBitrate:', lastTargetBitrate);
        console.log('   lastDesiredHours:', lastDesiredHours);
        
        if (!lastTargetBitrate || !lastDesiredHours) {
            console.log('   ❌ Exiting early - missing required data');
            return;
        }
    } catch (error) {
        console.error('❌ ERROR in showMoreAlternatives():', error);
        console.error('   Stack:', error.stack);
        return;
    }
    
    const moreOptionsSection = document.getElementById('recommendedSection');
    const moreOptionsAlternatives = document.getElementById('recommendedAlternatives');
    
    console.log('   recommendedSection:', moreOptionsSection);
    console.log('   recommendedAlternatives:', moreOptionsAlternatives);
    
    if (!moreOptionsSection || !moreOptionsAlternatives) return;
    
    // Clear previous content
    moreOptionsAlternatives.innerHTML = '';
    
    // Generate alternative configurations
    const alternatives = generateAlternativeConfigs(lastTargetBitrate);
    
    if (alternatives.length === 0) {
        moreOptionsSection.classList.add('hidden');
        return;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Calculate results and remove duplicates
    const alternativesWithResults = [];
    const seenConfigs = new Set();
    
    alternatives.forEach((altConfig) => {
        // Calculate results for this alternative
        const channels = altConfig.configs
            .map((config, index) => {
                // Skip null configs (inactive channels)
                if (config === null) return null;
                
                const channelInfo = currentModel.channels && currentModel.channels[index] 
                    ? currentModel.channels[index] 
                    : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
                
                // Handle JC400 presets
                let resolution, fps, bitrate;
                if (currentModel.name === 'JC400' && config.preset !== undefined) {
                    const presetData = channelInfo.presets[config.preset];
                    resolution = presetData.resolution;
                    fps = presetData.fps;
                    bitrate = presetData.bitrate;
                } else {
                    resolution = config.resolution;
                    fps = config.fps;
                    bitrate = config.bitrate;
                }
                
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: resolution.toString(),
                    fps: fps,
                    bitrate: bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    fixed: config.fixed || false
                };
            })
            .filter(ch => ch !== null); // Remove null entries
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard, { modelId: (currentModel.name || '').toLowerCase() });
        
        // Create a unique key for this configuration
        const configKey = altConfig.configs
            .filter(c => c !== null)
            .map(c => {
                if (c.preset !== undefined) {
                    return `preset${c.preset}`;
                }
                return `${c.resolution}_${c.fps}_${c.bitrate}`;
            }).join('|');
        
        // Only add if not duplicate
        if (!seenConfigs.has(configKey)) {
            seenConfigs.add(configKey);
            alternativesWithResults.push({
                ...altConfig,
                results: results,
                channels: channels
            });
        }
    });
    
    // If no unique alternatives, hide section
    if (alternativesWithResults.length === 0) {
        moreOptionsSection.classList.add('hidden');
        return;
    }
    
    // Select the most useful alternatives (ALWAYS 3 different options):
    const selectedAlternatives = [];
    
    console.log('📊 Total alternatives with results:', alternativesWithResults.length);
    
    // STRATEGY 1: Maximum Quality (ALWAYS first priority)
    console.log('💎 1️⃣ Selecting MAX QUALITY option...');
    let maxQualityAlt = alternativesWithResults.find(alt => alt.strategy === 'max-quality');
    
    if (!maxQualityAlt) {
        // Fallback: highest FPS + highest bitrate
        const sortedByQuality = [...alternativesWithResults].sort((a, b) => {
            const totalFpsA = a.channels.reduce((sum, ch) => sum + (ch.fps || 25), 0);
            const totalFpsB = b.channels.reduce((sum, ch) => sum + (ch.fps || 25), 0);
            if (totalFpsA !== totalFpsB) return totalFpsB - totalFpsA;
            
            const totalBitrateA = a.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
            const totalBitrateB = b.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
            return totalBitrateB - totalBitrateA;
        });
        maxQualityAlt = sortedByQuality[0];
    }
    
    if (maxQualityAlt) {
        selectedAlternatives.push({
            ...maxQualityAlt,
            badge: 'Máxima Qualidade',
            badgeIcon: '💎',
            badgeClass: 'bg-indigo-100 text-indigo-700 border-indigo-300',
            description: 'Maior resolução, FPS e bitrate disponíveis'
        });
        console.log('✅ Added MAX QUALITY:', maxQualityAlt.results.totalTimeHours.toFixed(1) + 'h',
                   'FPS:', maxQualityAlt.channels.map(ch => ch.fps).join(','),
                   'Bitrate:', maxQualityAlt.channels.reduce((s, c) => s + c.bitrate, 0) + 'M');
    }
    
    // STRATEGY 2: Closest to desired time (EXCLUDING max quality)
    console.log('🎯 2️⃣ Selecting CLOSEST to desired time...');
    const sortedByProximity = [...alternativesWithResults]
        .filter(alt => !selectedAlternatives.find(sel => 
            JSON.stringify(sel.configs) === JSON.stringify(alt.configs)
        ))
        .sort((a, b) => {
            return Math.abs(a.results.totalTimeHours - lastDesiredHours) - 
                   Math.abs(b.results.totalTimeHours - lastDesiredHours);
        });
    
    if (sortedByProximity[0]) {
        selectedAlternatives.push({
            ...sortedByProximity[0],
            badge: 'Mais Próximo',
            badgeIcon: '🎯',
            badgeClass: 'bg-green-100 text-green-700 border-green-300',
            description: 'Configuração mais próxima do tempo solicitado'
        });
        console.log('✅ Added CLOSEST:', sortedByProximity[0].results.totalTimeHours.toFixed(1) + 'h',
                   'FPS:', sortedByProximity[0].channels.map(ch => ch.fps).join(','),
                   'Bitrate:', sortedByProximity[0].channels.reduce((s, c) => s + c.bitrate, 0) + 'M');
    }
    
    // STRATEGY 3: Maximum recording time (EXCLUDING previous two)
    console.log('⏱️ 3️⃣ Selecting TRUE MAX TIME (minimum bitrates)...');
    
    // Generate REAL maximum time config (all channels at absolute minimum bitrate)
    const minBitrateConfigs = [];
    for (let i = 0; i < currentModel.channels.length; i++) {
        if (!activeChannels.includes(i)) {
            minBitrateConfigs.push(null);
            continue;
        }
        
        const channel = currentModel.channels[i];
        if (currentModel.name === 'JC400') {
            // JC400: Use preset 3 (lowest bitrate preset)
            const preset = channel.presets[channel.presets.length - 1]; // Last preset = lowest
            minBitrateConfigs.push({
                preset: channel.presets.length - 1,
                resolution: preset.resolution,
                fps: preset.fps,
                bitrate: preset.bitrate,
                codec: 'H.264'
            });
        } else if (currentModel.name === 'JC181' && i === 1) {
            // JC181 CH2 is fixed
            minBitrateConfigs.push({
                resolution: '360',
                fps: 10,
                bitrate: 0.5,
                codec: 'H.264',
                fixed: true
            });
        } else {
            // Find minimum bitrate for this channel
            // For JC371/JC450: resolutions are in currentModel, not in channel
            const resolutions = channel.resolutions || currentModel.resolutions;
            const fps = channel.fps || currentModel.fps;
            
            if (!resolutions || !fps) {
                console.error('No resolutions or fps found for channel', i);
                minBitrateConfigs.push(null);
                continue;
            }
            
            const minRes = resolutions[resolutions.length - 1]; // Last = lowest resolution
            const minBitrate = Math.min(...minRes.bitrates);
            const minFps = Math.min(...fps);
            minBitrateConfigs.push({
                resolution: minRes.value,
                fps: minFps,
                bitrate: minBitrate,
                codec: 'H.264'
            });
        }
    }
    
    // Calculate time for this config
    const channels = minBitrateConfigs.map((cfg, idx) => ({
        ...cfg,
        active: cfg !== null,
        channelId: currentModel.channels[idx].id,
        channelName: currentModel.channels[idx].name
    })).filter(ch => ch.active);
    
    let maxTimeResults;
    if (currentModel.name === 'JC450') {
        maxTimeResults = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
    } else {
        maxTimeResults = calculator.calculateTotal(cardSize, channels, false, { modelId: (currentModel.name || '').toLowerCase() });
    }
    
    const maxTimeAlternative = {
        configs: minBitrateConfigs,
        channels: channels,
        results: maxTimeResults,
        multiplier: 0.5, // Lowest quality = lowest multiplier
        strategy: 'absolute-max-time',
        name: 'Máximo Tempo Possível'
    };
    
    // Only add if it's different from already selected alternatives
    const isDuplicate = selectedAlternatives.find(sel => 
        JSON.stringify(sel.configs) === JSON.stringify(maxTimeAlternative.configs)
    );
    
    if (!isDuplicate) {
        selectedAlternatives.push({
            ...maxTimeAlternative,
            badge: 'Máximo Tempo',
            badgeIcon: '⏱️',
            badgeClass: 'bg-orange-100 text-orange-700 border-orange-300',
            description: 'Máximo tempo de gravação possível no cartão (menor qualidade)'
        });
        console.log('✅ Added TRUE MAX TIME:', maxTimeResults.totalTimeHours.toFixed(1) + 'h',
                   'FPS:', minBitrateConfigs.filter(c => c).map(ch => ch.fps).join(','),
                   'Bitrate:', minBitrateConfigs.filter(c => c).reduce((s, c) => s + c.bitrate, 0) + 'M');
    } else {
        console.log('⚠️ MAX TIME config is duplicate, skipping');
    }
    
    console.log('📋 Total selected alternatives:', selectedAlternatives.length);
    
    // Limit to exactly 3 alternatives
    const finalAlternatives = selectedAlternatives.slice(0, 3);
    
    // If we don't have at least 1 alternative, hide section
    if (finalAlternatives.length === 0) {
        moreOptionsSection.classList.add('hidden');
        return;
    }
    
    // Show section
    moreOptionsSection.classList.remove('hidden');
    
    finalAlternatives.forEach((altConfig, altIndex) => {
        const altCard = document.createElement('div');
        
        // All cards with same styling (no "recommended" special treatment)
        const isRecommended = false; // No recommended highlighting
        altCard.className = 'p-5 bg-white rounded-xl shadow-lg border-2 transition-all cursor-pointer overflow-hidden relative';
        altCard.style.borderColor = '#E5E7EB';
        
        altCard.onmouseenter = function() {
            this.style.borderColor = '#0066CC';
            this.style.transform = 'translateY(-4px)';
            this.style.boxShadow = '0 12px 24px rgba(0, 102, 204, 0.15)';
        };
        altCard.onmouseleave = function() {
            this.style.borderColor = '#E5E7EB';
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '';
        };
        
        const results = altConfig.results;
        
        // Calculate total bitrate and data consumption
        const totalBitrate = altConfig.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
        const totalMBh = totalBitrate * 450; // MB/h
        
        // Use custom badge if provided (from our selection logic)
        let badge = altConfig.badge || '';
        let badgeClass = altConfig.badgeClass || '';
        let badgeIcon = altConfig.badgeIcon || '';
        let description = altConfig.description || '';
        
        const timeDiff = results.totalTimeHours - lastDesiredHours;
        const timeDiffPercent = Math.abs((timeDiff / lastDesiredHours) * 100);
        
        // If no custom badge, determine from strategy/name
        if (!badge) {
            // Use strategy name if available
            if (altConfig.name) {
                badge = altConfig.name;
                
                // Determine icon and color based on strategy
                if (altConfig.strategy === 'balanced' && altConfig.multiplier < 1) {
                    badgeIcon = '💾';
                    badgeClass = 'bg-green-100 text-green-700 border-green-300';
                    description = 'Menor consumo de espaço, maior tempo de gravação';
                } else if (altConfig.strategy === 'balanced' && altConfig.multiplier > 1) {
                    badgeIcon = '⭐';
                    badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                    description = 'Melhor qualidade de imagem em todos os canais';
                } else if (altConfig.strategy === 'mixed-high-ch1' || altConfig.strategy === 'out-priority') {
                    badgeIcon = '🎯';
                    badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                    description = 'Canal principal com alta qualidade, outros otimizados';
                } else if (altConfig.strategy === 'mixed-max-time' || altConfig.strategy === 'max-time') {
                    badgeIcon = '⏱️';
                    badgeClass = 'bg-orange-100 text-orange-700 border-orange-300';
                    description = 'Configuração otimizada para máximo tempo de gravação';
                } else if (altConfig.strategy === 'high-all') {
                    badgeIcon = '💎';
                    badgeClass = 'bg-indigo-100 text-indigo-700 border-indigo-300';
                    description = 'Máxima qualidade em todos os canais';
                } else if (altConfig.strategy === 'balanced-medium') {
                    badgeIcon = '⚖️';
                    badgeClass = 'bg-teal-100 text-teal-700 border-teal-300';
                    description = 'Equilíbrio entre qualidade e tempo de gravação';
                } else {
                    badgeIcon = '📹';
                    badgeClass = 'bg-gray-100 text-gray-700 border-gray-300';
                    description = 'Configuração alternativa';
                }
            } else {
                // Fallback to old logic
                if (timeDiffPercent < 5) {
                    badge = 'Tempo Exato';
                    badgeIcon = '🎯';
                    badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                    description = 'Atinge o tempo desejado com precisão';
                } else if (altConfig.multiplier < 1) {
                    badge = 'Econômico';
                    badgeIcon = '💾';
                    badgeClass = 'bg-green-100 text-green-700 border-green-300';
                    description = 'Menor consumo de espaço, maior tempo de gravação';
                } else {
                    badge = 'Alta Qualidade';
                    badgeIcon = '⭐';
                    badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                    description = 'Melhor qualidade de imagem';
                }
            }
        }
        
        // Build channel summary with icons and better formatting
        let channelsHTML = '';
        altConfig.configs.forEach((config, index) => {
            // Skip null configs (inactive channels)
            if (config === null) return;
            
            const channelName = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index].name 
                : 'Canal ' + (index + 1);
            
            // Get actual values (handle JC400 presets)
            let resolution, fps, bitrate;
            if (currentModel.name === 'JC400' && config.preset !== undefined) {
                const channelInfo = currentModel.channels[index];
                const presetData = channelInfo.presets[config.preset];
                resolution = presetData.resolution;
                fps = presetData.fps;
                bitrate = presetData.bitrate;
            } else {
                resolution = config.resolution;
                fps = config.fps;
                bitrate = config.bitrate;
            }
            
            // Determine quality level for visual indication
            let qualityColor = '#6B7280'; // gray
            if (bitrate >= 6) qualityColor = '#059669'; // green - high
            else if (bitrate >= 3) qualityColor = '#0066CC'; // blue - medium
            else if (bitrate >= 1) qualityColor = '#F59E0B'; // orange - low
            
            channelsHTML += '<div class="flex items-center justify-between p-2 rounded mb-2" style="background-color: #F9FAFB; border-left: 3px solid ' + qualityColor + ';">' +
                '<div class="flex-1">' +
                '<div class="font-semibold text-sm text-gray-800">' +
                '<i class="fas fa-video mr-2" style="color: ' + qualityColor + ';"></i>' +
                channelName +
                '</div>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                '<span class="inline-block mr-3"><i class="fas fa-image mr-1"></i>' + resolution + 'P</span>' +
                '<span class="inline-block mr-3"><i class="fas fa-tachometer-alt mr-1"></i>' + fps + ' fps</span>' +
                '<span class="inline-block"><i class="fas fa-signal mr-1"></i>' + bitrate + ' Mbps</span>' +
                '</div>' +
                '</div>' +
                '</div>';
        });
        
        const timeDiffSign = timeDiff >= 0 ? '+' : '';
        const timeDiffColor = Math.abs(timeDiffPercent) < 10 ? '#059669' : (timeDiff >= 0 ? '#0066CC' : '#EF4444');
        
        altCard.innerHTML = 
            // Recommended ribbon (only for first card)
            (isRecommended ? '<div class="absolute top-0 right-0 bg-gradient-to-r from-green-500 to-green-600 text-white text-xs font-bold px-4 py-2 rounded-bl-lg shadow-lg" style="z-index: 10;"><i class="fas fa-crown mr-1"></i>MELHOR OPÇÃO</div>' : '') +
            
            // Header with badge
            '<div class="flex items-center justify-between mb-4 pb-3 border-b-2 border-gray-100" style="' + (isRecommended ? 'margin-top: 10px;' : '') + '">' +
            '<div>' +
            '<h4 class="font-bold text-lg text-gray-800 mb-1">' +
            (isRecommended ? '⭐ ' : '') + badgeIcon + ' ' + (isRecommended ? 'RECOMENDADO' : 'Opção ' + (altIndex + 1)) +
            '</h4>' +
            '<p class="text-xs text-gray-500 italic">' + description + '</p>' +
            '</div>' +
            '<span class="text-xs px-3 py-1.5 rounded-full border-2 font-bold ' + badgeClass + '">' + badge + '</span>' +
            '</div>' +
            
            // Channel configurations
            '<div class="mb-4">' +
            '<h5 class="text-xs font-bold text-gray-600 uppercase tracking-wide mb-2">' +
            '<i class="fas fa-cog mr-1"></i>Configuração dos Canais' +
            '</h5>' +
            channelsHTML +
            '</div>' +
            
            // Statistics grid
            '<div class="grid grid-cols-2 gap-3 mb-4">' +
            
            // Recording time
            '<div class="col-span-2 p-3 rounded-lg" style="background: linear-gradient(135deg, #E6F0FF 0%, #CCE0FF 100%); border: 2px solid #0066CC;">' +
            '<div class="flex items-center justify-between">' +
            '<div>' +
            '<div class="text-xs text-gray-700 font-semibold mb-1">' +
            '<i class="fas fa-clock mr-1" style="color: #0066CC;"></i>Tempo Total' +
            '</div>' +
            '<div class="font-bold text-2xl" style="color: #0052A3;">' +
            results.totalTimeDays.toFixed(1) + ' dias' +
            '</div>' +
            '<div class="text-sm text-gray-700">' + 
            (currentLang === 'pt-BR' ? 'ou ' : 'or ') +
            hours.toFixed(1) + ' horas' +
            '</div>' +
            '</div>' +
            '<div class="text-center px-3 py-2 bg-white rounded-lg border-2" style="border-color: ' + timeDiffColor + ';">' +
            '<div class="font-bold text-lg" style="color: ' + timeDiffColor + ';">' + timeDiffSign + timeDiffPercent.toFixed(0) + '%</div>' +
            '<div class="text-xs text-gray-600">vs desejado</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // Total bitrate
            '<div class="p-3 rounded-lg bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-200">' +
            '<div class="text-xs text-purple-700 font-semibold mb-1">' +
            '<i class="fas fa-signal mr-1"></i>Bitrate Total' +
            '</div>' +
            '<div class="font-bold text-xl text-purple-800">' + totalBitrate.toFixed(1) + ' Mbps</div>' +
            '</div>' +
            
            // Data consumption
            '<div class="p-3 rounded-lg bg-gradient-to-br from-orange-50 to-orange-100 border-2 border-orange-200">' +
            '<div class="text-xs text-orange-700 font-semibold mb-1">' +
            '<i class="fas fa-database mr-1"></i>Consumo/Hora' +
            '</div>' +
            '<div class="font-bold text-xl text-orange-800">' + (totalMBh / 1000).toFixed(2) + ' GB/h</div>' +
            '</div>' +
            
            '</div>' +
            
            // Action button
            '<button class="w-full text-white py-3 px-4 rounded-lg transition-all text-sm font-bold shadow-md hover:shadow-xl transform hover:scale-105" style="background: linear-gradient(135deg, #0066CC 0%, #0052A3 100%);">' +
            '<i class="fas fa-check-circle mr-2"></i>Usar Esta Configuração' +
            '</button>';
        
        const useBtn = altCard.querySelector('button');
        useBtn.onclick = function() {
            autoGeneratedConfig = altConfig.configs;
            calculateAutoConfig(altConfig.configs);
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        };
        
        moreOptionsAlternatives.appendChild(altCard);
    });
    
    // Show the section
    moreOptionsSection.classList.remove('hidden');
}

// Get Channel Priority Order for Free Mode
// Returns array where index is priority level (0 = highest), value is channel index
function getChannelPriorityOrder() {
    if (currentModel.name === 'JC371') {
        // JC371: CH2 (index 1) -> CH1 (index 0) -> CH3 (index 2)
        return [1, 0, 2];
    } else if (currentModel.name === 'JC450') {
        // JC450: CH3 (index 2) -> CH1 (index 0) -> CH2 (index 1) -> CH4 (index 3) -> CH5 (index 4)
        return [2, 0, 1, 3, 4];
    } else if (currentModel.name === 'JC400') {
        // JC400: IN (index 1) -> OUT (index 0)
        return [1, 0];
    }
    // Default: sequential order
    return Array.from({ length: currentModel.channels?.length || 4 }, (_, i) => i);
}

// Calculate priority score for a configuration in free mode
function calculateFreeModeScore(configSet, timeDifference, debugMode = false) {
    const priorityOrder = getChannelPriorityOrder();
    let bitrateScore = 0;
    
    // JC371-specific enhanced weights for better priority enforcement
    // CH2 (USB) gets highest weight, followed by CH1 (Road), then CH3 (DMS)
    let weights;
    if (currentModel.name === 'JC371') {
        // Enhanced weights: CH2=100, CH1=85, CH3=65
        // Stronger differentiation to enforce priority clearly
        weights = [100, 85, 65];
        
        // BALANCE BONUS: Give extra points when bitrates are more evenly distributed
        // This prevents extreme scenarios like 8M/0.5M/0.5M
        const bitrates = configSet.configs.map(c => c?.bitrate || 0);
        const avgBitrate = bitrates.reduce((a, b) => a + b, 0) / bitrates.length;
        const variance = bitrates.reduce((sum, br) => sum + Math.pow(br - avgBitrate, 2), 0) / bitrates.length;
        const balanceBonus = 800 / (1 + variance); // Higher bonus for balanced configs
        
        // PROXIMITY BONUS: Extra points when CH2 and CH1 are close in bitrate
        const ch2Bitrate = configSet.configs[1]?.bitrate || 0; // CH2 index=1
        const ch1Bitrate = configSet.configs[0]?.bitrate || 0; // CH1 index=0
        const bitrateDiff = Math.abs(ch2Bitrate - ch1Bitrate);
        const proximityBonus = Math.max(0, 300 - (bitrateDiff * 50)); // Max 300 points when diff ≤ 2M
        
        bitrateScore += balanceBonus + proximityBonus;
        
        if (debugMode) {
            console.log(`   🎨 JC371 Scoring: Balance Bonus=${balanceBonus.toFixed(0)}, Proximity Bonus=${proximityBonus.toFixed(0)}`);
        }
    } else {
        // Default weights for other models
        weights = [10, 7, 5, 3.5, 2.5, 1.5];
    }
    
    priorityOrder.forEach((channelIndex, priorityLevel) => {
        if (configSet.configs[channelIndex] && configSet.configs[channelIndex] !== null) {
            const bitrate = configSet.configs[channelIndex].bitrate || 0;
            const weight = weights[priorityLevel] || 1;
            const channelScore = bitrate * weight;
            bitrateScore += channelScore;
            
            if (debugMode) {
                const chName = currentModel.channels[channelIndex]?.name || `CH${channelIndex}`;
                console.log(`   📊 ${chName}: ${bitrate}M × weight ${weight} = ${channelScore.toFixed(1)} points`);
            }
        }
    });
    
    // Time score: strongly prefer configs closer to desired time
    const timeScore = 50000 / (1 + Math.abs(timeDifference));
    
    if (debugMode) {
        console.log(`   ⏱️ Time score: ${timeScore.toFixed(0)} (diff: ${timeDifference.toFixed(1)}h)`);
        console.log(`   ✅ Total score: ${(timeScore + bitrateScore).toFixed(0)}`);
    }
    
    // Combined score: time is primary, quality hierarchy is secondary influence
    return timeScore + bitrateScore;
}

// Generate All Possible Configurations
function generateAllPossibleConfigs(numChannels) {
    const allConfigs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: Only CH1 is configurable, CH2 is fixed
        const ch1Channel = currentModel.channels[0];
        const ch2Fixed = {
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        };
        
        // Check which channels are active
        const ch1Active = activeChannels.includes(0);
        const ch2Active = activeChannels.includes(1);
        
        if (ch1Channel.resolutions) {
            ch1Channel.resolutions.forEach(res => {
                res.bitrates.forEach(bitrate => {
                    const defaultFps = ch1Channel.fps ? (Array.isArray(ch1Channel.fps) ? ch1Channel.fps[0] : ch1Channel.fps) : 25;
                    
                    const configs = [];
                    
                    // Add CH1 config if active
                    if (ch1Active) {
                        configs.push({
                            resolution: res.value,
                            fps: defaultFps,
                            bitrate: bitrate
                        });
                    } else {
                        configs.push(null); // Placeholder for inactive channel
                    }
                    
                    // Add CH2 config if active
                    if (ch2Active) {
                        configs.push(ch2Fixed);
                    } else {
                        configs.push(null); // Placeholder for inactive channel
                    }
                    
                    allConfigs.push({ configs });
                });
            });
        }
    } else if (currentModel.name === 'JC400') {
        // JC400: Generate combinations of presets
        const outPresets = currentModel.channels[0].presets || [];
        const inPresets = currentModel.channels[1].presets || [];
        
        // Check which channels are active
        const outActive = activeChannels.includes(0);
        const inActive = activeChannels.includes(1);
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        console.log('🎯 JC400 Priority Config:');
        console.log('   selectedPriorityChannel:', selectedPriorityChannel);
        console.log('   priorityChannelIndex:', priorityChannelIndex);
        console.log('   Active channels:', activeChannels);
        
        if (priorityChannelIndex === -1) {
            // User wants all channels equal - only generate combinations where bitrates are similar
            // Allow small differences (within 20%) for flexibility
            outPresets.forEach((outPreset, outIndex) => {
                inPresets.forEach((inPreset, inIndex) => {
                    // Calculate bitrate difference percentage
                    const bitrateDiff = Math.abs(outPreset.bitrate - inPreset.bitrate);
                    const avgBitrate = (outPreset.bitrate + inPreset.bitrate) / 2;
                    const diffPercent = (bitrateDiff / avgBitrate) * 100;
                    
                    // Only include if bitrates are within 20% of each other (approximately equal)
                    if (diffPercent <= 20) {
                        const configs = [];
                        
                        // Add OUT preset if active (include full preset data)
                        if (outActive) {
                            configs.push({ 
                                preset: outIndex,
                                resolution: outPreset.resolution,
                                fps: outPreset.fps,
                                bitrate: outPreset.bitrate
                            });
                        } else {
                            configs.push(null);
                        }
                        
                        // Add IN preset if active (include full preset data)
                        if (inActive) {
                            configs.push({ 
                                preset: inIndex,
                                resolution: inPreset.resolution,
                                fps: inPreset.fps,
                                bitrate: inPreset.bitrate
                            });
                        } else {
                            configs.push(null);
                        }
                        
                        allConfigs.push({ configs });
                    }
                });
            });
        } else {
            // User wants a specific channel prioritized
            if (priorityChannelIndex === 0) {
                // Prioritize OUT camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if OUT has same or better quality than IN
                        if (outPreset.bitrate >= inPreset.bitrate) {
                            const configs = [];
                            
                            if (outActive) {
                                configs.push({ 
                                    preset: outIndex,
                                    resolution: outPreset.resolution,
                                    fps: outPreset.fps,
                                    bitrate: outPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            if (inActive) {
                                configs.push({ 
                                    preset: inIndex,
                                    resolution: inPreset.resolution,
                                    fps: inPreset.fps,
                                    bitrate: inPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            allConfigs.push({ configs });
                        }
                    });
                });
            } else {
                // Prioritize IN camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if IN has same or better quality than OUT
                        if (inPreset.bitrate >= outPreset.bitrate) {
                            const configs = [];
                            
                            if (outActive) {
                                configs.push({ 
                                    preset: outIndex,
                                    resolution: outPreset.resolution,
                                    fps: outPreset.fps,
                                    bitrate: outPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            if (inActive) {
                                configs.push({ 
                                    preset: inIndex,
                                    resolution: inPreset.resolution,
                                    fps: inPreset.fps,
                                    bitrate: inPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            allConfigs.push({ configs });
                        }
                    });
                });
            }
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // For simplicity, generate a subset of common configurations
        // instead of ALL combinations (which would be too many)
        
        // Get all available bitrates from model resolutions
        const allBitrates = currentModel.resolutions 
            ? currentModel.resolutions.flatMap(res => res.bitrates)
            : [];
        
        // Get unique bitrates and sort
        const uniqueBitrates = [...new Set(allBitrates)].sort((a, b) => a - b);
        
        const numChannels = currentModel.channels ? currentModel.channels.length : 2;
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        
        console.log('🎯 JC371/JC450 Priority Config:');
        console.log('   selectedPriorityChannel:', selectedPriorityChannel);
        console.log('   priorityChannelIndex:', priorityChannelIndex);
        console.log('   Active channels:', activeChannels);
        
        if (priorityChannelIndex === -2) {
            // FREE MODE: Generate all possible bitrate combinations
            console.log('🎨 FREE MODE: Generating all bitrate combinations...');
            
            // Helper function to generate all combinations recursively
            function generateCombinations(channelIndex, currentCombination) {
                if (channelIndex >= numChannels) {
                    // All channels assigned, add this configuration
                    const channelConfigs = [];
                    let hasActiveChannel = false;
                    
                    for (let i = 0; i < numChannels; i++) {
                        if (activeChannels.includes(i)) {
                            const bitrate = currentCombination[i];
                            const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                            if (config) {
                                channelConfigs.push(config);
                                hasActiveChannel = true;
                            } else {
                                channelConfigs.push(null);
                            }
                        } else {
                            channelConfigs.push(null); // Inactive channel
                        }
                    }
                    
                    if (hasActiveChannel) {
                        allConfigs.push({
                            configs: channelConfigs
                        });
                    }
                    return;
                }
                
                // Try each bitrate for this channel
                uniqueBitrates.forEach(bitrate => {
                    currentCombination[channelIndex] = bitrate;
                    generateCombinations(channelIndex + 1, [...currentCombination]);
                });
            }
            
            // Start recursive generation
            generateCombinations(0, []);
            console.log(`   Generated ${allConfigs.length} free configurations`);
            
        } else if (priorityChannelIndex === -1) {
            // User wants all channels with equal quality
            uniqueBitrates.forEach(bitrate => {
                const channelConfigs = [];
                for (let i = 0; i < numChannels; i++) {
                    // Check if this channel is active
                    if (activeChannels.includes(i)) {
                        const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                        if (config) {
                            channelConfigs.push(config);
                        } else {
                            channelConfigs.push(null);
                        }
                    } else {
                        channelConfigs.push(null); // Inactive channel
                    }
                }
                
                // At least one channel must be active
                if (channelConfigs.some(c => c !== null)) {
                    allConfigs.push({
                        configs: channelConfigs
                    });
                }
            });
        } else {
            // User wants a specific channel prioritized
            uniqueBitrates.forEach(bitratePriority => {
                uniqueBitrates.forEach(bitrateOthers => {
                    if (bitratePriority >= bitrateOthers) { // Priority channel has same or higher bitrate
                        const channelConfigs = [];
                        
                        for (let i = 0; i < numChannels; i++) {
                            // Check if this channel is active
                            if (activeChannels.includes(i)) {
                                const bitrate = (i === priorityChannelIndex) ? bitratePriority : bitrateOthers;
                                const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                                if (config) {
                                    channelConfigs.push(config);
                                } else {
                                    channelConfigs.push(null);
                                }
                            } else {
                                channelConfigs.push(null); // Inactive channel
                            }
                        }
                        
                        // At least one channel must be active
                        if (channelConfigs.some(c => c !== null)) {
                            allConfigs.push({
                                configs: channelConfigs
                            });
                        }
                    }
                });
            });
        }
    }
    
    return allConfigs;
}

// Find Best Config for Specific Bitrate (helper function)
function findBestConfigForBitrate(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                if (bitrate === targetBitrate) {
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    // If exact match not found, find closest
    if (!bestConfig && channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                if (difference < minDifference) {
                    minDifference = difference;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig;
}

// Find Best Resolution for Specific Bitrate (for models with resolutions at model level)
function findBestResolutionForBitrate(targetBitrate, resolutions) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    if (!resolutions) return null;
    
    // First try exact match
    resolutions.forEach(res => {
        if (res.bitrates && res.bitrates.includes(targetBitrate)) {
            bestConfig = {
                resolution: res.value,
                fps: 25, // default
                bitrate: targetBitrate
            };
        }
    });
    
    // If exact match not found, find closest
    if (!bestConfig) {
        resolutions.forEach(res => {
            if (res.bitrates) {
                res.bitrates.forEach(bitrate => {
                    const difference = Math.abs(bitrate - targetBitrate);
                    if (difference < minDifference) {
                        minDifference = difference;
                        bestConfig = {
                            resolution: res.value,
                            fps: 25,
                            bitrate: bitrate
                        };
                    }
                });
            }
        });
    }
    
    return bestConfig;
}

// Generate Alternative Configurations
function generateAlternativeConfigs(targetBitrate) {
    const alternatives = [];
    const numChannels = currentModel.channels ? currentModel.channels.length : 1;
    const cardSize = parseInt(cardSizeSelect.value);
    const useDualCard = currentModel.dualCard && !useOneCardOnly;
    
    console.log('🔧 generateAlternativeConfigs called');
    console.log('   Model:', currentModel.name);
    console.log('   Num channels:', numChannels);
    
    // Strategy 0: MAXIMUM QUALITY (highest bitrate possible for all channels)
    const maxQualityConfigs = generateMaxQualityConfig(numChannels);
    console.log('   💎 Max quality configs:', maxQualityConfigs);
    if (maxQualityConfigs && maxQualityConfigs.length > 0) {
        alternatives.push({
            configs: maxQualityConfigs,
            multiplier: 999, // Very high to ensure it's maximum
            strategy: 'max-quality',
            name: '💎 Qualidade Máxima'
        });
        console.log('   ✅ Added MAX QUALITY strategy');
    } else {
        console.log('   ❌ No max quality configs generated');
    }
    
    // Strategy 1: Balanced quality (all channels similar)
    const balancedVariations = [0.6, 0.8, 1.2, 1.4]; // -40%, -20%, +20%, +40%
    balancedVariations.forEach(multiplier => {
        const adjustedBitrate = targetBitrate * multiplier;
        const configs = generateConfigForModel(adjustedBitrate, numChannels);
        if (configs && configs.length > 0) {
            alternatives.push({ 
                configs, 
                multiplier,
                strategy: 'balanced',
                name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
            });
        }
    });
    
    // Strategy 2: For multi-channel models, create mixed quality options
    if (numChannels > 1 && (currentModel.name === 'JC371' || currentModel.name === 'JC450')) {
        // High priority on CH1, lower on others
        const mixedConfigs1 = generateMixedQualityConfig(targetBitrate * 1.5, targetBitrate * 0.7, 0);
        if (mixedConfigs1) {
            alternatives.push({
                configs: mixedConfigs1,
                multiplier: 1.0,
                strategy: 'mixed-high-ch1',
                name: 'CH1 Priorizado'
            });
        }
        
        // Medium CH1, very low others (maximum recording time)
        const mixedConfigs2 = generateMixedQualityConfig(targetBitrate * 0.8, targetBitrate * 0.4, 0);
        if (mixedConfigs2) {
            alternatives.push({
                configs: mixedConfigs2,
                multiplier: 0.6,
                strategy: 'mixed-max-time',
                name: 'Máximo Tempo'
            });
        }
        
        // High quality all main channels
        const highConfigs = generateMixedQualityConfig(targetBitrate * 1.3, targetBitrate * 1.3, -1);
        if (highConfigs) {
            alternatives.push({
                configs: highConfigs,
                multiplier: 1.3,
                strategy: 'high-all',
                name: 'Máxima Qualidade'
            });
        }
    }
    
    // Strategy 3: For JC400, create smart preset combinations
    if (currentModel.name === 'JC400') {
        // OUT high, IN medium
        alternatives.push({
            configs: [{ preset: 0 }, { preset: 1 }], // 1080P@8M, 720P@3M
            multiplier: 1.1,
            strategy: 'out-priority',
            name: 'OUT Priorizado'
        });
        
        // Both medium
        alternatives.push({
            configs: [{ preset: 1 }, { preset: 1 }], // 720P@4M, 720P@3M
            multiplier: 0.7,
            strategy: 'balanced-medium',
            name: 'Qualidade Média'
        });
        
        // Maximum time
        alternatives.push({
            configs: [{ preset: 3 }, { preset: 3 }], // 360P@0.5M, 360P@0.5M
            multiplier: 0.1,
            strategy: 'max-time',
            name: 'Máximo Tempo'
        });
    }
    
    // Strategy 4: For JC181, vary CH1 quality
    if (currentModel.name === 'JC181') {
        const ch1Variations = [0.5, 0.75, 1.25, 1.5];
        ch1Variations.forEach(multiplier => {
            const ch1Config = findBestConfig(targetBitrate * multiplier, currentModel.channels[0]);
            if (ch1Config) {
                alternatives.push({
                    configs: [
                        ch1Config,
                        { resolution: '360', fps: 25, bitrate: 0.5, fixed: true }
                    ],
                    multiplier,
                    strategy: 'ch1-variation',
                    name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
                });
            }
        });
    }
    
    console.log('📊 Total alternatives before deduplication:', alternatives.length);
    
    // Remove alternatives that result in the same configuration as the main one
    //and sort by how close they are to the desired time
    const filtered = alternatives.filter((alt, index, self) => {
        // Remove duplicates based on actual bitrate
        const altKey = alt.configs.map(c => 
            c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
        ).join('|');
        
        return index === self.findIndex(t => {
            const tKey = t.configs.map(c => 
                c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
            ).join('|');
            return tKey === altKey;
        });
    });
    
    console.log('📊 Total alternatives after deduplication:', filtered.length);
    console.log('   Strategies:', filtered.map(a => a.strategy).join(', '));
    
    return filtered;
}

// Generate Maximum Quality Configuration (highest bitrate for all channels)
function generateMaxQualityConfig(numChannels) {
    const configs = [];
    
    console.log('🔍 generateMaxQualityConfig called for model:', currentModel.name);
    
    if (currentModel.name === 'JC181') {
        // JC181: CH1 at ABSOLUTE MAX (1080P@30fps@8Mbps), CH2 FIXED at 360P@10fps@0.5Mbps
        const maxConfig = [
            {
                resolution: '1080',
                fps: 30,  // MAXIMUM FPS for CH1
                bitrate: 8,  // MAXIMUM BITRATE
                codec: 'H.264',
                channelName: 'CH1 - Main Camera'
            },
            {
                resolution: '360',  // FIXED - Cannot be changed
                fps: 10,  // FIXED - Internal camera only supports 10fps
                bitrate: 0.5,  // FIXED - Cannot be changed
                codec: 'H.264',
                channelName: 'CH2 - Internal Camera (Fixed: 360P@0.5M@10fps)',
                fixed: true
            }
        ];
        console.log('   ✅ JC181 MAX QUALITY configs:', maxConfig);
        return maxConfig;
    }
    
    if (currentModel.name === 'JC400') {
        // JC400: Both at preset 0 (1080P@8Mbps OUT, 720P@4Mbps IN) - MÁXIMO SEGUNDO ESPECIFICAÇÃO
        const maxConfig = [
            { preset: 0, fps: 25 }, // OUT: 1080P@8Mbps@25fps
            { preset: 0, fps: 25 }  // IN: 720P@4Mbps@25fps (CORRIGIDO: máximo é 4M, não 6M)
        ];
        console.log('   ✅ JC400 MAX QUALITY configs:', maxConfig);
        return maxConfig;
    }
    
    if (currentModel.name === 'JC371') {
        // JC371: All 3 channels at ABSOLUTE maximum (1080P@25fps@8Mbps) - CH1 default 25fps, CH2/CH3 default 15fps
        const maxConfig = [
            {
                resolution: '1080',
                fps: 25,  // CH1 default FPS
                bitrate: 8,  // MAXIMUM BITRATE
                codec: 'H.264',
                channelName: 'CH1 - Road Facing'
            },
            {
                resolution: '1080',
                fps: 15,  // CH2 default FPS
                bitrate: 8,  // MAXIMUM BITRATE
                codec: 'H.264',
                channelName: 'CH2 - USB Camera'
            },
            {
                resolution: '720',  // CH3 máximo é 720P
                fps: 15,  // CH3 default FPS
                bitrate: 8,  // MAXIMUM BITRATE
                codec: 'H.264',
                channelName: 'CH3 - DMS Camera'
            }
        ];
        console.log('   ✅ JC371 MAX QUALITY configs:', maxConfig);
        return maxConfig;
    }
    
    if (currentModel.name === 'JC450') {
        // JC450: Maximum is 1080P@25fps@4Mbps for customize cameras, 720P@25fps@4Mbps standard
        // Using conservative 720P@4M for all channels to ensure compatibility
        const maxConfig = [
            {
                resolution: '720',
                fps: 25,  // CH1 default FPS
                bitrate: 4,  // MAXIMUM BITRATE (convertido de 4096 Kbps)
                codec: 'H.264',
                channelName: 'CH1 - Road Facing/ADAS'
            },
            {
                resolution: '720',
                fps: 15,  // CH2-5 default FPS
                bitrate: 4,
                codec: 'H.264',
                channelName: 'CH2 - USB Camera'
            },
            {
                resolution: '720',
                fps: 15,
                bitrate: 4,
                codec: 'H.264',
                channelName: 'CH3 - DMS Camera'
            },
            {
                resolution: '720',
                fps: 15,
                bitrate: 4,
                codec: 'H.264',
                channelName: 'CH4 - Camera 4'
            },
            {
                resolution: '720',
                fps: 15,
                bitrate: 4,
                codec: 'H.264',
                channelName: 'CH5 - Camera 5 (PRO only)'
            }
        ];
        console.log('   ✅ JC450 MAX QUALITY configs:', maxConfig);
        return maxConfig;
    }
    
    // Generic fallback: use highest resolution available
    if (currentModel.resolutions) {
        for (let i = 0; i < numChannels; i++) {
            const maxBitrate = Math.max(...currentModel.resolutions.flatMap(r => r.bitrates));
            const config = findBestResolutionForBitrate(maxBitrate * 10, currentModel.resolutions);
            if (config) {
                configs.push(config);
            }
        }
    }
    
    return configs.length === numChannels ? configs : null;
}

// Helper function to generate mixed quality configurations
function generateMixedQualityConfig(priorityBitrate, othersBitrate, priorityChannelIndex) {
    if (!currentModel.resolutions) return null;
    
    const numChannels = currentModel.channels ? currentModel.channels.length : 2;
    const configs = [];
    
    for (let i = 0; i < numChannels; i++) {
        const bitrate = (priorityChannelIndex === -1 || i === priorityChannelIndex) 
            ? priorityBitrate 
            : othersBitrate;
        const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
        if (config) {
            configs.push(config);
        }
    }
    
    return configs.length === numChannels ? configs : null;
}

// Generate Configuration For Model
function generateConfigForModel(targetBitrate, numChannels) {
    const configs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: CH1 configurable, CH2 fixed
        configs.push(findBestConfig(targetBitrate, currentModel.channels[0]));
        configs.push({
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        });
    } else if (currentModel.name === 'JC400') {
        // JC400: OUT and IN cameras with presets
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            const preset = findBestPresetJC400(targetBitrate, channel);
            configs.push(preset);
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // JC371 and JC450: Flexible configuration
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            configs.push(findBestConfig(targetBitrate, channel));
        }
    }
    
    return configs;
}

// Find Best Config for Channel
function findBestConfig(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    // Get default FPS from channel
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                
                // Prefer configurations that are closer to target
                // If difference is similar, prefer slightly lower bitrate (longer recording time)
                // to avoid exceeding storage too quickly
                let penalty = 0;
                if (bitrate < targetBitrate) {
                    // Lower bitrate = longer recording time (good)
                    penalty = difference * 0.8; // 20% preference for lower bitrate
                } else {
                    // Higher bitrate = shorter recording time (less preferred)
                    penalty = difference * 1.2; // 20% penalty for higher bitrate
                }
                
                if (penalty < minDifference) {
                    minDifference = penalty;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig || {
        resolution: '720',
        fps: defaultFps,
        bitrate: 2
    };
}

// Find Best Preset for JC400
function findBestPresetJC400(targetBitrate, channel) {
    if (!channel.presets) {
        return { preset: 0 };
    }
    
    let bestPreset = 0;
    let minDifference = Infinity;
    
    channel.presets.forEach((preset, index) => {
        const difference = Math.abs(preset.bitrate - targetBitrate);
        
        // Apply same logic: prefer slightly lower bitrate for longer recording
        let penalty = 0;
        if (preset.bitrate < targetBitrate) {
            penalty = difference * 0.8; // Prefer lower bitrate
        } else {
            penalty = difference * 1.2; // Penalize higher bitrate
        }
        
        if (penalty < minDifference) {
            minDifference = penalty;
            bestPreset = index;
        }
    });
    
    return { preset: bestPreset };
}

// Apply Auto Config to UI
function applyAutoConfigToUI(configs) {
    if (!configs || configs.length === 0) return;
    
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, index) => {
        if (index >= configs.length) return;
        
        const config = configs[index];
        
        if (config.fixed) {
            // CH2 of JC181 is fixed, skip
            return;
        }
        
        if (currentModel.name === 'JC400') {
            // Set preset
            const presetSelect = div.querySelector('.channel-preset');
            if (presetSelect && config.preset !== undefined) {
                presetSelect.value = config.preset;
            }
        } else {
            // Set resolution, fps, and bitrate
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            
            if (resolutionSelect && config.resolution) {
                resolutionSelect.value = config.resolution;
            }
            
            if (fpsSelect && config.fps) {
                fpsSelect.value = config.fps;
            }
            
            if (bitrateSelect && config.bitrate) {
                // For JC181, need to update bitrates first
                if (currentModel.name === 'JC181' && index === 0) {
                    updateJC181Bitrates(0);
                }
                bitrateSelect.value = config.bitrate;
            }
        }
    });
    
    // Add visual indicator
    channelDivs.forEach(div => {
        div.style.borderColor = '#10b981';
        div.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.2)';
        setTimeout(() => {
            div.style.borderColor = '';
            div.style.boxShadow = '';
        }, 2000);
    });
}

// Show Notification
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 z-50 px-6 py-4 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full';
    
    if (type === 'success') {
        notification.className += ' bg-green-500 text-white';
        notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>' + message;
    } else if (type === 'error') {
        notification.className += ' bg-red-500 text-white';
        notification.innerHTML = '<i class="fas fa-exclamation-circle mr-2"></i>' + message;
    } else {
        notification.className += ' bg-blue-500 text-white';
        notification.innerHTML = '<i class="fas fa-info-circle mr-2"></i>' + message;
    }
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(120%)';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 4000);
}

// Calculate Recording
function calculateRecording() {
    console.log('========================================');
    console.log('🔢 [CALC] Calculate button clicked');
    console.log('🔢 [CALC] Current Model:', currentModel ? currentModel.name : 'NONE');
    
    if (!currentModel) {
        console.log('🔢 [CALC] ❌ No current model, returning');
        console.log('========================================');
        return;
    }
    
    // Clear previous results to prevent stale data
    resultsSection.classList.add('hidden');
    currentConfig = null;
    
    // Handle mode-specific logic
    const isAutoMode = !document.getElementById('autoModePanel').classList.contains('hidden');
    if (isAutoMode) {
        console.log('🔢 [CALC] Mode: AUTO');
        // Auto mode: always regenerate configs to reflect any parameter changes
        generateAutoConfig();
        // If generation failed or user cancelled, stop
        if (warningModalShown) {
            console.log('========================================');
            return;
        }
        console.log('========================================');
        return; // generateAutoConfig handles the full calculation flow
    } else {
        console.log('🔢 [CALC] Mode: MANUAL');
        // Manual mode: clear auto-config alternatives
        configAlternatives = null;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    const channels = collectChannelData();
    
    console.log('🔢 [CALC] Card size:', cardSize, 'GB');
    console.log('🔢 [CALC] Channels collected:', channels.length);
    
    if (!isAutoMode && channels.length === 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, configure pelo menos um canal.' 
            : 'Please configure at least one channel.');
        console.log('========================================');
        return;
    }
    
    // Calculate total desired hours based on daily usage
    const dailyUsageHours = parseFloat(dailyUsageHoursInput.value) || 24;
    const desiredDays = parseFloat(desiredDaysInput.value) || 0;
    const desiredHours = parseFloat(desiredHoursInput.value) || 0;
    const totalDesiredHours = (desiredDays * dailyUsageHours) + desiredHours;
    
    console.log('🔢 [CALC] Desired time:', totalDesiredHours, 'hours');

    // Special handling for JC450 dual card
    let results;
    if (currentModel.name === 'JC450') {
        console.log('🔢 [CALC] Using JC450-specific calculation');
        // Use JC450-specific dual card calculation
        results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
    } else {
        console.log('🔢 [CALC] Using standard calculation');
        // Use regular calculation for other models
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        results = calculator.calculateTotal(cardSize, channels, useDualCard, { modelId: (currentModel.name || '').toLowerCase() });
    }
    
    currentConfig = { modelName: currentModel.name, results, channels };
    
    // Display results
    displayResults(results);
    
    // Show results section
    resultsSection.classList.remove('hidden');
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    saveState();
    console.log('========================================');
}

// Calculate Reverse Mode
// Collect Channel Data
function collectChannelData() {
    const channels = [];
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, divIndex) => {
        // Get the actual channel index from the div's ID or data attribute
        const channelIndexMatch = div.querySelector('[id^="channel-"]');
        let actualChannelIndex = divIndex;
        
        if (channelIndexMatch) {
            const idMatch = channelIndexMatch.id.match(/channel-(\d+)/);
            if (idMatch) {
                actualChannelIndex = parseInt(idMatch[1]);
            }
        }
        
        // For models with activeChannels tracking, verify this channel is active
        // For other models, all rendered channels are active
        if (currentModel.id === 'jc181' || currentModel.id === 'jc400') {
            if (!activeChannels.includes(actualChannelIndex)) {
                return;
            }
        }
        
        const channelInfo = currentModel.channels 
            ? currentModel.channels[actualChannelIndex] 
            : { id: `CH${actualChannelIndex + 1}`, name: `Channel ${actualChannelIndex + 1}` };
        
        // JC181 - CH2 is fixed
        if (currentModel.name === 'JC181' && actualChannelIndex === 1) {
            channels.push({
                active: true,
                channelId: 'CH2',
                channelName: 'CH2 - Internal Camera',
                resolution: '360',
                fps: 10,  // FIXED - Internal camera only supports 10fps
                bitrate: 0.5,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: true
            });
            return;
        }
        
        if (currentModel.name === 'JC400') {
            const presetSelect = div.querySelector('.channel-preset');
            const selectedOption = presetSelect.options[presetSelect.selectedIndex];
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                preset: presetSelect.value,
                resolution: selectedOption.dataset.resolution,
                fps: parseInt(selectedOption.dataset.fps),
                bitrate: parseFloat(selectedOption.dataset.bitrate),
                codec: 'H.264',
                codecMultiplier: 1
            });
        } else {
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            const codecSelect = div.querySelector('.channel-codec');
            
            // Skip if elements not found (fixed channel)
            if (!resolutionSelect || !fpsSelect || !bitrateSelect) {
                return;
            }
            
            // Bitrate is already in Mbps from models.js
            let bitrate = parseFloat(bitrateSelect.value);
            
            let codecMultiplier = 1;
            let codecName = 'H.264';
            if (codecSelect) {
                const selectedCodec = codecSelect.options[codecSelect.selectedIndex];
                codecMultiplier = parseFloat(selectedCodec.dataset.multiplier);
                codecName = selectedCodec.textContent;
            }
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: resolutionSelect.value,
                fps: parseInt(fpsSelect.value),
                bitrate: bitrate,
                codec: codecName,
                codecMultiplier: codecMultiplier
            });
        }
    });
    
    return channels;
}

// Display Results
function displayResults(results) {
    const isPt = currentLang === 'pt-BR';
    // Helper function to get model accent class
    function getModelAccentClass(modelName) {
        const accents = {
            'JC450': 'border-l-blue-500',
            'JC181': 'border-l-green-500',
            'JC371': 'border-l-purple-500',
            'JC400': 'border-l-orange-500'
        };
        return accents[modelName] || 'border-l-gray-400';
    }

    // Get daily usage hours from the global input (works for both auto and manual modes)
    let dailyUsageHours = 24; // Default: 24 hours
    
    if (dailyUsageHoursInput) {
        dailyUsageHours = parseFloat(dailyUsageHoursInput.value) || 24;
    }
    
    console.log('📊 [DISPLAY] Daily usage hours:', dailyUsageHours);
    console.log('📊 [DISPLAY] Results total time hours:', results.totalTimeHours);
    
    // Calculate real days based on daily usage
    const realDaysOfRecording = results.totalTimeHours / dailyUsageHours;
    // MB per GB used by calculator (keep display units consistent)
    const mbPerGB = calculator && calculator.config && calculator.config.useDecimalUnits ? 1000 : 1024;
    
    // Create configuration summary (REORGANIZED ORDER)
    const configSummaryDiv = document.getElementById('configSummary');
    configSummaryDiv.innerHTML = '';

    // Show notice if any channel used an estimated calibration multiplier
    let usedEstimated = false;
    const scanForEstimated = (obj) => {
        if (!obj) return;
        if (Array.isArray(obj)) {
            obj.forEach(item => scanForEstimated(item));
            return;
        }
        if (obj.multiplierEstimated) usedEstimated = true;
        if (obj.channelResults) scanForEstimated(obj.channelResults);
    };
    scanForEstimated(results.channelResults);
    // JC450 dual-card structure
    if (results.sd1 && results.sd1.channelResults) scanForEstimated(results.sd1.channelResults);
    if (results.sd2 && results.sd2.channelResults) scanForEstimated(results.sd2.channelResults);

    if (usedEstimated) {
        const estWarning = document.createElement('div');
        estWarning.className = 'mb-4 p-3 bg-yellow-50 border-l-4 border-yellow-400 rounded';
        estWarning.innerHTML = '';
        configSummaryDiv.appendChild(estWarning);
    }

    // Populate per-channel multiplier info in the UI (if present)
    try {
        const populateMultipliers = (channelResults) => {
            if (!channelResults || !channelResults.length) return;
            channelResults.forEach((ch, i) => {
                const el = document.querySelector(`.channel-multiplier[data-channel="${i}"]`);
                if (el) {
                    const mult = ch.outputMultiplier || 1;
                    const reason = ch.multiplierReason || ch.multiplier_reason || ch.multiplierReason || 'n/a';
                    const est = ch.multiplierEstimated ? ' (estimado)' : '';
                    el.textContent = `Multiplicador: x${mult.toFixed(3)} ${est} — motivo: ${reason}`;
                    el.style.color = ch.multiplierEstimated ? '#92400E' : '#065F46';
                }
            });
        };

        // Handle JC450 dual-card structure
        if (results.sd1 && results.sd1.channelResults) {
            populateMultipliers(results.sd1.channelResults);
        } else if (results.channelResults) {
            populateMultipliers(results.channelResults);
        }
    } catch (e) {
        console.warn('Could not populate per-channel multiplier UI:', e);
    }
    
    // 2.2 - ESTIMATIVA COM FATORES REALISTAS (improved card styling)
    try {
        const estDiv = document.createElement('div');
        estDiv.className = 'mb-6 bg-white rounded-xl shadow-lg p-6 border border-gray-100';
        estDiv.innerHTML = `
            <div class="flex items-start mb-3">
                <i class="fas fa-info-circle text-3xl text-indigo-600 mr-4"></i>
                <div class="flex-1">
                    <h4 class="font-bold text-gray-800 text-lg">
                        ${isPt ? 'Estimativa com Fatores Realistas' : 'Estimate with Realistic Factors'}
                    </h4>
                    <p class="text-sm text-gray-600 mt-1">
                        ${isPt ? 'Esta é uma previsão aproximada do bitrate efetivo e do consumo. Valores reais podem variar — abaixo estão os motivos mais comuns dessas variações.' : 'This is an approximate prediction of effective bitrate and consumption. Actual values may vary — below are the most common reasons for these variations.'}
                    </p>
                </div>
            </div>
            <div class="text-sm text-gray-700">
                <ul class="ml-4 mt-2 list-disc space-y-2">
                    <li><strong>Movimento na cena:</strong> cenas com muito movimento aumentam o bitrate.</li>
                    <li><strong>Áudio ativo:</strong> gravação com áudio (voz, diálogo) acrescenta dados ao arquivo.</li>
                    <li><strong>Bitrate variável (VBR):</strong> alguns vídeos usam taxas que mudam conforme a cena.</li>
                    <li><strong>Overhead do arquivo:</strong> contêiner, índices e blocos do sistema de arquivos adicionam espaço extra.</li>
                    <li><strong>Codec, resolução e FPS:</strong> codecs mais eficientes (ex.: H.265) usam menos Mbps; resolução e frames por segundo também afetam o tamanho.</li>
                </ul>
                <div class="mt-3 text-xs text-gray-500">Use o valor estimado como referência prática — para planejamento, considere até ~10% de variação para cima ou para baixo dependendo das condições.</div>
            </div>
        `;
        configSummaryDiv.appendChild(estDiv);
    } catch (e) {
        console.warn('Could not build Estimativa com Fatores Realistas section:', e);
    }
    
    // TEMPO TOTAL - Card redesenhado no mesmo padrão dos outros
    const timeExplanationSection = document.createElement('div');
    timeExplanationSection.className = 'mb-6 bg-white rounded-lg border border-gray-200 shadow-sm border-l-4 border-emerald-500';
    
    const centerHours = Number(results.totalTimeHours) || 0;
    const minHours = centerHours * 0.9;
    const maxHours = centerHours * 1.1;
    
    // Detectar modo do JC450
    const isJC450Mirror = currentModel.name === 'JC450' && currentModel.dualCard && !useOneCardOnly && !results.isDualCardSplit;
    const isJC450DualSplit = currentModel.name === 'JC450' && results.isDualCardSplit;
    const theoreticalTotalHours = isJC450Mirror ? centerHours * 2 : centerHours;
    
    timeExplanationSection.innerHTML = `
        <div class="flex items-start p-4">
            <i class="fas fa-clock text-emerald-600 text-2xl mr-3"></i>
            <div class="flex-1">
                <h4 class="font-bold text-gray-800 text-lg mb-3">
                    ${isPt ? 'Tempo de Gravação' : 'Recording Time'}${isJC450Mirror ? ' <span class="text-sm font-normal text-blue-600">(Modo Espelho Ativo)</span>' : ''}
                </h4>
                
                <!-- Tempo Principal -->
                <div class="mb-4 p-4 bg-emerald-50 rounded-lg border border-emerald-200">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-sm text-gray-600 mb-1">${isPt ? 'Tempo Útil' : 'Usable Time'}</div>
                            <div class="text-4xl font-bold text-emerald-700">${centerHours.toFixed(1)} <span class="text-xl text-gray-600">horas</span></div>
                        </div>
                        <div class="text-right">
                            <div class="text-sm text-gray-600 mb-1">${isPt ? 'Dias de Gravação' : 'Recording Days'}</div>
                            <div class="text-3xl font-bold text-emerald-600">${(centerHours/dailyUsageHours).toFixed(1)} <span class="text-lg text-gray-500">dias</span></div>
                            <div class="text-xs text-gray-500 mt-1">(${dailyUsageHours.toFixed(1)}h/dia de uso)</div>
                        </div>
                    </div>
                </div>
                
                ${isJC450Mirror ? `
                <!-- Explicação do Modo Mirror (apenas para JC450 Dual Card) -->
                <div class="mb-4 p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                    <div class="flex items-start gap-2 mb-3">
                        <i class="fas fa-copy text-blue-600 mt-0.5"></i>
                        <div>
                            <h5 class="font-semibold text-blue-900 text-sm mb-2">
                                ${isPt ? 'Entenda o cálculo do Modo Espelho:' : 'Understand Mirror Mode calculation:'}
                            </h5>
                            <div class="space-y-2 text-xs text-blue-800">
                                <div class="flex items-center justify-between p-2 bg-white rounded border border-blue-200">
                                    <span class="flex items-center gap-2">
                                        <i class="fas fa-database text-blue-500"></i>
                                        ${isPt ? 'Capacidade Total (2 Cartões):' : 'Total Capacity (2 Cards):'}
                                    </span>
                                    <strong class="text-blue-700">~${theoreticalTotalHours.toFixed(1)}h</strong>
                                </div>
                                <div class="flex items-center justify-between p-2 bg-white rounded border border-blue-200">
                                    <span class="flex items-center gap-2">
                                        <i class="fas fa-shield-alt text-orange-500"></i>
                                        ${isPt ? 'Redundância (Backup):' : 'Redundancy (Backup):'}
                                    </span>
                                    <strong class="text-orange-700">-${centerHours.toFixed(1)}h</strong>
                                </div>
                                <div class="flex items-center justify-between p-2 bg-emerald-50 rounded border-2 border-emerald-500">
                                    <span class="flex items-center gap-2 font-semibold">
                                        <i class="fas fa-check-circle text-emerald-600"></i>
                                        ${isPt ? 'Tempo Útil Real:' : 'Real Usable Time:'}
                                    </span>
                                    <strong class="text-emerald-700">${centerHours.toFixed(1)}h</strong>
                                </div>
                            </div>
                            <p class="text-xs text-blue-700 mt-3 italic">
                                <i class="fas fa-info-circle"></i>
                                ${isPt 
                                    ? 'No modo Espelho, o segundo cartão grava uma cópia exata do primeiro para segurança, não aumentando o tempo total de gravação.' 
                                    : 'In Mirror mode, the second card records an exact copy of the first for security, not increasing total recording time.'}
                            </p>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                ${isJC450DualSplit ? `
                <!-- Detalhamento por Cartão (JC450 Dual Card - Divisão Física) -->
                <div class="mb-4 p-4 bg-amber-50 rounded-lg border-l-4 border-amber-500">
                    <div class="flex items-start gap-2 mb-3">
                        <i class="fas fa-sd-card text-amber-600 mt-0.5"></i>
                        <div class="flex-1">
                            <h5 class="font-semibold text-amber-900 text-sm mb-2">
                                ${isPt ? 'Detalhamento por Cartão:' : 'Breakdown by Card:'}
                            </h5>
                            <div class="space-y-2 text-xs text-amber-800">
                                <div class="flex items-center justify-between p-2 bg-white rounded border border-amber-200">
                                    <span class="flex items-center gap-2">
                                        <i class="fas fa-sd-card text-blue-500"></i>
                                        <strong>Cartão 1 (SD1)</strong>
                                        <span class="text-xs text-gray-600">(Câmeras ${results.sd1.channels})</span>
                                    </span>
                                    <strong class="text-blue-700">${results.sd1.timeHours.toFixed(1)}h</strong>
                                </div>
                                <div class="flex items-center justify-between p-2 bg-white rounded border border-amber-200">
                                    <span class="flex items-center gap-2">
                                        <i class="fas fa-sd-card text-purple-500"></i>
                                        <strong>Cartão 2 (SD2)</strong>
                                        <span class="text-xs text-gray-600">(Câmeras ${results.sd2.channels})</span>
                                    </span>
                                    <strong class="text-purple-700">${results.sd2.timeHours.toFixed(1)}h</strong>
                                </div>
                                <div class="flex items-center justify-between p-2 bg-emerald-50 rounded border-2 border-emerald-500">
                                    <span class="flex items-center gap-2 font-semibold">
                                        <i class="fas fa-clock text-emerald-600"></i>
                                        ${isPt ? 'Retenção Mínima (Sistema):' : 'Minimum Retention (System):'}
                                    </span>
                                    <strong class="text-emerald-700">${centerHours.toFixed(1)}h</strong>
                                </div>
                            </div>
                            <p class="text-xs text-amber-700 mt-3 italic">
                                <i class="fas fa-info-circle"></i>
                                ${isPt 
                                    ? 'As câmeras são gravadas em cartões separados. O tempo acima indica quando o primeiro cartão começará a sobrescrever as imagens antigas.' 
                                    : 'Cameras are recorded on separate cards. The time above indicates when the first card will start overwriting old footage.'}
                            </p>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <!-- Faixa de Variação -->
                <div class="mb-4">
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-sm font-semibold text-gray-700">${isPt ? 'Faixa de Variação' : 'Variation Range'}</span>
                        <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs font-semibold">±10%</span>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-3 mb-3">
                        <div class="bg-orange-50 border border-orange-200 rounded-lg p-3">
                            <div class="text-xs text-orange-700 font-semibold mb-1 flex items-center gap-1">
                                <i class="fas fa-arrow-down"></i> Mínimo
                            </div>
                            <div class="text-2xl font-bold text-orange-700">${minHours.toFixed(1)}<span class="text-sm">h</span></div>
                        </div>
                        <div class="bg-green-50 border border-green-200 rounded-lg p-3">
                            <div class="text-xs text-green-700 font-semibold mb-1 flex items-center gap-1">
                                <i class="fas fa-arrow-up"></i> Máximo
                            </div>
                            <div class="text-2xl font-bold text-green-700">${maxHours.toFixed(1)}<span class="text-sm">h</span></div>
                        </div>
                    </div>
                    
                    <div class="h-2 bg-gray-200 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-orange-400 via-emerald-500 to-green-400"></div>
                    </div>
                    <div class="flex justify-between mt-1 text-xs text-gray-500">
                        <span>${minHours.toFixed(1)}h</span>
                        <span class="font-semibold text-emerald-600">${centerHours.toFixed(1)}h</span>
                        <span>${maxHours.toFixed(1)}h</span>
                    </div>
                </div>
                
                <!-- Nota Informativa -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <div class="flex gap-2">
                        <i class="fas fa-info-circle text-blue-600 mt-0.5 text-sm"></i>
                        <p class="text-xs text-blue-900">
                            <strong>${isPt ? 'Importante:' : 'Important:'}</strong> ${isPt ? 'O tempo total de gravação é fixo, mas o número de dias varia conforme as horas diárias de uso do veículo.' : 'Total recording time is fixed, but the number of days varies based on daily vehicle usage hours.'}
                        </p>
                    </div>
                </div>
            </div>
        </div>
    `;
    configSummaryDiv.appendChild(timeExplanationSection);

    // Add listener to update days when daily usage hours changes
    if (dailyUsageHoursInput) {
        const daysSpan = timeExplanationSection.querySelector('.text-lg.font-bold.text-blue-900');
        if (daysSpan) {
            dailyUsageHoursInput.addEventListener('input', () => {
                const newDaily = parseFloat(dailyUsageHoursInput.value) || 24;
                daysSpan.textContent = (centerHours / newDaily).toFixed(1);
                const hoursSpan = timeExplanationSection.querySelector('.text-sm');
                if (hoursSpan) {
                    hoursSpan.textContent = `dias (com ${newDaily.toFixed(1)}h/dia)`;
                }
            });
        }
    }
    
    // 2.1 - COMANDO DO DISPOSITIVO
    const commandSection = document.createElement('div');
    commandSection.className = 'mb-4 p-4 bg-white rounded-lg border border-gray-200 shadow-sm border-l-4 ' + getModelAccentClass(currentModel.name);
    
    const commands = currentModel.commandFormat(currentConfig);
    
    commandSection.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-terminal text-gray-700 text-2xl mr-3"></i>' +
        '<div class="flex-1">' +
        '<h4 class="font-bold text-gray-800 text-lg mb-3">' +
        'Comando do Dispositivo' +
        '</h4>' +
        '<div class="bg-gray-900 text-green-400 p-4 rounded-lg font-mono text-sm overflow-x-auto">' +
        commands.split('\n').map(cmd => '<div class="mb-1">' + cmd + '</div>').join('') +
        '</div>' +
        '<div class="mt-2 text-xs text-gray-600">' +
        '<i class="fas fa-info-circle mr-1"></i>Copie e cole este comando no dispositivo para aplicar as configurações' +
        '</div>' +
        '</div>' +
        '</div>';
    
    configSummaryDiv.appendChild(commandSection);
    
    // 2.2 - ESTIMATIVA COM FATORES REALISTAS
    // Duplicate/secondary realistic info boxes were removed to keep a single
    // comprehensive "Estimativa com Fatores Realistas" section (the detailed
    // block is rendered earlier). This avoids repeating the same information
    // in the Results view.
    
    // 2.3 - CAPACIDADE DO CARTÃO
    const cardInfo = document.createElement('div');
    cardInfo.className = 'mb-4 p-4 bg-white rounded-lg border border-gray-200 shadow-sm border-l-4 ' + getModelAccentClass(currentModel.name);
    
    // Handle different result structures (JC450 vs other models)
    // FIXED JC450: Don't sum spaces - show per-card space correctly
    let availableSpace, cardCapacityText;
    if (results.sd1 && results.sd2) {
        // JC450 dual card mode
        if (useOneCardOnly) {
            // Single card mode: show only one card's space
            availableSpace = results.sd1.availableSpaceMB;
            cardCapacityText = results.cardSizeGB + ' GB';
        } else {
            // Dual card mode: show space per card (not summed)
            availableSpace = results.sd1.availableSpaceMB; // Each card has the same space
            cardCapacityText = results.cardSizeGB + ' GB';
        }
    } else {
        // Other models
        availableSpace = results.availableSpaceMB;
        cardCapacityText = results.cardSizeGB + ' GB';
    }
    const usablePercent = results.usablePercentage || 90;
    
    // Show both per-card and total combined capacity for JC450 dual-card mode to avoid confusion
    let combinedCapacityHtml = '';
    if (currentModel && currentModel.name === 'JC450' && results.sd1 && results.sd2 && !useOneCardOnly) {
        const combinedGB = (results.combinedAvailableSpaceMB / mbPerGB).toFixed(1);
        combinedCapacityHtml = '<div class="text-xs text-gray-600 mt-2">Espaço combinado (2×cartão × ' + (results.usablePercentage || 90) + '%): <strong>' + combinedGB + ' GB</strong></div>';
    }

    cardInfo.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-sd-card text-blue-600 mr-2"></i>' +
        '<strong>' + t('cardCapacity') + ':</strong> ' + results.cardSizeGB + ' GB' +
        (currentModel && currentModel.name === 'JC450' && !useOneCardOnly ? ' (cada cartão)' : '') +
        '</div>' +
        '<div class="text-sm text-gray-600">' +
        '<i class="fas fa-check-circle text-green-500 mr-1"></i>' +
        t('usableCapacity') + ': ' + (availableSpace ? availableSpace.toFixed(0) : '0') + ' MB' +
        (currentModel && currentModel.name === 'JC450' && !useOneCardOnly ? ' (por cartão)' : '') +
        ' (' + usablePercent.toFixed(0) + '%)' +
        '</div>';
    configSummaryDiv.appendChild(cardInfo);
    
    // 🔧 JC450 Dual Card Information (if applicable)
    // FIXED: Only show dual card info when NOT in single card mode
    if (currentModel && currentModel.name === 'JC450' && results.sd1 && results.sd2 && !useOneCardOnly) {
        const dualCardInfo = document.createElement('div');
        dualCardInfo.className = 'mb-4 p-4 bg-white rounded-lg border border-gray-200 shadow-sm border-l-4 ' + getModelAccentClass(currentModel.name);
        dualCardInfo.innerHTML = 
            '<div class="flex items-start">' +
            '<i class="fas fa-hdd text-blue-600 text-2xl mr-3"></i>' +
            '<div class="flex-1">' +
            '<h4 class="font-bold text-blue-900 text-lg mb-3">' +
            '<i class="fas fa-server mr-2"></i>' +
            (currentLang === 'pt-BR' ? 'Configuração Dual Card (JC450)' : 'Dual Card Configuration (JC450)') +
            '</h4>' +
            
            // SD1 and SD2 side-by-side
            '<div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">' +
            
            // SD1 Card
            '<div class="bg-white rounded-lg p-3 border-2 ' + 
            (results.limitingCard === 'SD1' ? 'border-red-400' : 'border-gray-300') + '">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h5 class="font-bold text-gray-800">' +
            '<i class="fas fa-sd-card text-blue-600 mr-1"></i> SD1' +
            '</h5>' +
            (results.limitingCard === 'SD1' ? 
                '<span class="text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>LIMITANTE' +
                '</span>' : '') +
            '</div>' +
            '<div class="text-xs text-gray-600 mb-2">' +
            '<i class="fas fa-video mr-1"></i> ' + results.sd1.channels +
            '</div>' +
            '<div class="space-y-1 text-sm">' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Canais ativos:</span>' +
            '<span class="font-semibold">' + results.sd1.channelCount + '</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Bitrate total:</span>' +
            '<span class="font-semibold text-blue-700">' + results.sd1.totalBitrate.toFixed(1) + ' Mbps</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Consumo/hora:</span>' +
            '<span class="font-semibold">' + results.sd1.totalRateGBh.toFixed(2) + ' GB/h</span>' +
            '</div>' +
            '<div class="flex justify-between border-t border-gray-200 pt-1 mt-1">' +
            '<span class="text-gray-800 font-semibold">Tempo SD1:</span>' +
            '<span class="font-bold text-green-700">' + results.sd1.timeHours.toFixed(1) + ' h</span>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // SD2 Card
            '<div class="bg-white rounded-lg p-3 border-2 ' + 
            (results.limitingCard === 'SD2' ? 'border-red-400' : 'border-gray-300') + '">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h5 class="font-bold text-gray-800">' +
            '<i class="fas fa-sd-card text-purple-600 mr-1"></i> SD2' +
            '</h5>' +
            (results.limitingCard === 'SD2' ? 
                '<span class="text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>LIMITANTE' +
                '</span>' : '') +
            '</div>' +
            '<div class="text-xs text-gray-600 mb-2">' +
            '<i class="fas fa-video mr-1"></i> ' + results.sd2.channels +
            '</div>' +
            '<div class="space-y-1 text-sm">' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Canais ativos:</span>' +
            '<span class="font-semibold">' + results.sd2.channelCount + '</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Bitrate total:</span>' +
            '<span class="font-semibold text-purple-700">' + results.sd2.totalBitrate.toFixed(1) + ' Mbps</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Consumo/hora:</span>' +
            '<span class="font-semibold">' + results.sd2.totalRateGBh.toFixed(2) + ' GB/h</span>' +
            '</div>' +
            '<div class="flex justify-between border-t border-gray-200 pt-1 mt-1">' +
            '<span class="text-gray-800 font-semibold">Tempo SD2:</span>' +
            '<span class="font-bold text-green-700">' + results.sd2.timeHours.toFixed(1) + ' h</span>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            '</div>' +
            
            // System totals
            '<div class="bg-gradient-to-r from-gray-100 to-gray-50 rounded-lg p-3 border border-gray-300 mb-3">' +
            '<div class="grid grid-cols-2 gap-3 text-sm">' +
            '<div>' +
            '<div class="text-gray-600 text-xs mb-1">Total Sistema:</div>' +
            '<div class="font-bold text-lg text-gray-900">' + results.totalBitrate.toFixed(1) + ' Mbps</div>' +
            '</div>' +
            '<div>' +
            '<div class="text-gray-600 text-xs mb-1">Consumo Total:</div>' +
            '<div class="font-bold text-lg text-gray-900">' + results.totalRateGBh.toFixed(2) + ' GB/h</div>' +
            '</div>' +
            '</div>' +
            (results.bitrateWarning ? 
                '<div class="mt-2 p-2 bg-red-100 border border-red-300 rounded text-xs text-red-800">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>' + results.bitrateWarning +
                '</div>' : '') +
            '</div>' +
            
            // Real days explanation for JC450
            '<div class="bg-gradient-to-r from-green-50 to-green-100 rounded-lg p-3 border-2 border-green-300 mb-3">' +
            '<div class="text-xs text-gray-700 mb-2">' +
            '<i class="fas fa-car text-green-600 mr-1"></i><strong>Dias Reais de Gravação:</strong>' +
            '</div>' +
            '<div class="grid grid-cols-2 gap-2 text-sm">' +
            '<div>' +
            '<span class="text-gray-600">24h/dia:</span> ' +
            '<span class="font-bold text-gray-800">' + results.totalTimeDays.toFixed(1) + ' dias</span>' +
            '</div>' +
            '<div>' +
            '<span class="text-gray-600">' + dailyUsageHours.toFixed(1) + 'h/dia:</span> ' +
            '<span class="font-bold text-green-700">' + realDaysOfRecording.toFixed(1) + ' dias</span>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // Important note
            '<div class="bg-yellow-50 border-l-4 border-yellow-400 p-3 rounded">' +
            '<div class="flex items-start">' +
            '<i class="fas fa-info-circle text-yellow-600 mr-2 mt-0.5"></i>' +
            '<div class="text-xs text-gray-700">' +
            '<strong>' + (currentLang === 'pt-BR' ? 'Importante:' : 'Important:') + '</strong> ' +
            (results.note || 'O JC450 usa dois cartões SD independentes. O tempo total é limitado pelo cartão que enche primeiro.') +
            '</div>' +
            '</div>' +
            '</div>' +
            
            '</div>' +
            '</div>';
        
        configSummaryDiv.appendChild(dualCardInfo);
    }
    
    // 🔧 Realistic Calculation Info Box
    // Removed duplicate simplified realistic box; the detailed
    // "Estimativa com Fatores Realistas" section is rendered earlier
    // (keeps a single comprehensive explanatory block in Results).
    
    // Channels info
    const channelsDiv = document.createElement('div');
    channelsDiv.className = 'mt-3 space-y-2';
    
    const channelHeader = document.createElement('div');
    channelHeader.className = 'font-bold text-gray-700 mb-2';
    channelHeader.innerHTML = '<i class="fas fa-video text-blue-500 mr-2"></i>' + 
        t('activeChannelsCount') + ': ' + results.activeChannels;
    channelsDiv.appendChild(channelHeader);
    
    // (Removed duplicate channel rendering and redundant consumption summary - kept the earlier, consolidated blocks)
    
    // [Removed: 'Sobre a Precisão desta Estimativa' card — user requested removal]
    
    // 2.6 - CONSUMO TOTAL
    // O valor de 'Dados Gravados' deve refletir o espaço utilizável disponível
    // (ou seja, quanto será efetivamente gravado até o cartão encher). Em alguns
    // caminhos de cálculo (ex.: JC450) o tempo é baseado em uma soma nominal de
    // bitrates, portanto precisamos usar `availableSpaceMB` como fonte da verdade
    // para o volume total gravado.
    const totalConsumptionGB = ((results.availableSpaceMB || 0) / mbPerGB); // GB
    const totalRateMBh = results.totalRateMBh || 0;

    console.log('🔍 [DEBUG] Cálculo de Consumo Total:');
    console.log('   - Taxa total:', totalRateMBh.toFixed(2), 'MB/h');
    console.log('   - Tempo de gravação:', (results.totalTimeHours || 0).toFixed(2), 'horas');
    console.log('   - Dados gravados (espaço utilizável):', totalConsumptionGB.toFixed(2), 'GB');
    console.log('   - Espaço disponível:', ((results.availableSpaceMB || 0) / mbPerGB).toFixed(2), 'GB');

    const consumptionSummary = document.createElement('div');
    consumptionSummary.className = 'mb-4 p-4 bg-white rounded-lg border border-gray-200 shadow-sm border-l-4 ' + getModelAccentClass(currentModel.name);
    consumptionSummary.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-chart-pie text-purple-600 text-2xl mr-3"></i>' +
        '<div class="flex-1">' +
        '<h4 class="font-bold text-gray-800 text-lg mb-3">' +
        'Consumo Total' +
        '</h4>' +
        '<div class="grid grid-cols-2 gap-3">' +
        '<div class="p-3 bg-purple-100 rounded-lg border border-purple-300">' +
        '<div class="text-xs text-purple-700 mb-1">Dados Gravados (espaço utilizável)</div>' +
        '<div class="font-bold text-2xl text-purple-800">' + totalConsumptionGB.toFixed(2) + ' GB</div>' +
        '<div class="text-xs text-gray-500 mt-1">(inclui margem utilizável: ' + (results.usablePercentage || 90) + '%)</div>' +
        '</div>' +
        '<div class="p-3 bg-blue-100 rounded-lg border border-blue-300">' +
        '<div class="text-xs text-blue-700 mb-1">Taxa Média</div>' +
        '<div class="font-bold text-xl text-blue-800">' + totalRateMBh.toFixed(0) + ' MB/h</div>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>';
    configSummaryDiv.appendChild(consumptionSummary);
}

// State Management
function saveState() {
    if (!currentModel) return;
    
    const state = {
        modelName: currentModel.name,
        cardSize: cardSizeSelect.value,
        activeChannels: activeChannels
    };
    
    localStorage.setItem('dvrCalculatorState', JSON.stringify(state));
}

function loadSavedState() {
    const savedState = localStorage.getItem('dvrCalculatorState');
    if (savedState) {
        try {
            const state = JSON.parse(savedState);
            if (state.modelName && isValidModel(state.modelName)) {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    selectModel(state.modelName);
                    if (state.cardSize && cardSizeSelect) {
                        cardSizeSelect.value = state.cardSize;
                    }
                    if (state.activeChannels) {
                        activeChannels = state.activeChannels;
                    }
                    if (currentModel) {
                        updateChannelConfig();
                    }
                }, 100);
            }
        } catch (e) {
            console.error('Error loading saved state:', e);
            // Clear invalid state
            localStorage.removeItem('dvrCalculatorState');
        }
    }
}

// Initialize on load
// Select a model and prepare UI
function selectModel(modelName) {
    const model = getModelConfig(modelName);
    if (!model) return;
    currentModel = model;

    // Highlight selected card
    try {
        modelCards.forEach(card => {
            if (card.dataset && card.dataset.model === modelName) card.classList.add('active');
            else card.classList.remove('active');
        });
    } catch (e) {
        // ignore if modelCards not ready
    }

    // Show configuration section and populate card sizes
    if (configSection) configSection.classList.remove('hidden');
    if (resultsSection) resultsSection.classList.add('hidden');

    if (cardSizeSelect && model.cardSizes && model.cardSizes.length) {
        cardSizeSelect.innerHTML = '';
        model.cardSizes.forEach(size => {
            const opt = document.createElement('option');
            opt.value = size;
            opt.textContent = size + ' GB';
            cardSizeSelect.appendChild(opt);
        });
    }

    // JC450 dual-card selector
    const cardCountSelector = document.getElementById('cardCountSelector');
    if (cardCountSelector) {
        if (model.dualCard) cardCountSelector.classList.remove('hidden');
        else cardCountSelector.classList.add('hidden');
    }

    // Prepare channel UI
    try {
        updateChannelPriorityOptions();
        updateChannelConfig();
        setupManualConfiguration();
    } catch (e) {
        console.warn('selectModel helper failed:', e);
    }

    // Reveal calculate/reset controls
    const calcSection = document.getElementById('calculateButtonSection');
    if (calcSection) calcSection.classList.remove('hidden');
}

// Initialize application (wire UI handlers)
function init() {
    // Wire model card clicks
    try {
        modelCards.forEach(card => {
            card.addEventListener('click', () => {
                const modelName = card.dataset && card.dataset.model;
                if (modelName) selectModel(modelName);
            });
        });
    } catch (e) {
        console.warn('Could not attach model card listeners:', e);
    }

    // Card count buttons for JC450
    const oneBtn = document.getElementById('oneCardBtn');
    const twoBtn = document.getElementById('twoCardsBtn');
    if (oneBtn && twoBtn) {
        oneBtn.addEventListener('click', () => {
            useOneCardOnly = true;
            oneBtn.classList.add('active');
            twoBtn.classList.remove('active');
        });
        twoBtn.addEventListener('click', () => {
            useOneCardOnly = false;
            twoBtn.classList.add('active');
            oneBtn.classList.remove('active');
        });
    }

    // Reset calculator function
    function resetCalculator() {
        console.log('🔄 Resetting calculator...');
        
        // Reset state
        currentConfig = null;
        configAlternatives = null;
        autoGeneratedConfig = null;
        lastTargetBitrate = null;
        lastDesiredHours = null;
        warningModalShown = false;
        
        // Hide results
        if (resultsSection) resultsSection.classList.add('hidden');
        
        // Reset card size to default
        if (cardSizeSelect) cardSizeSelect.value = '128';
        
        // Reset desired time inputs
        if (desiredDaysInput) desiredDaysInput.value = '0';
        if (desiredHoursInput) desiredHoursInput.value = '24';
        if (dailyUsageHoursInput) dailyUsageHoursInput.value = '24';
        
        // Update total desired time display
        updateTotalDesiredTime();
        
        // Reset channel configuration to defaults if manual mode
        if (currentModel && channelConfigDiv) {
            updateChannelConfig();
        }
        
        console.log('✅ Calculator reset complete');
    }

    // Calculate and reset buttons
    const calcBtn = document.getElementById('calculateBtn');
    const resetBtn = document.getElementById('resetBtn');
    if (calcBtn) calcBtn.addEventListener('click', calculateRecording);
    if (resetBtn) resetBtn.addEventListener('click', resetCalculator);

    // Reset config when card size changes
    if (cardSizeSelect) cardSizeSelect.addEventListener('change', () => {
        console.log('🔄 Card size changed, resetting configAlternatives and currentConfig');
        configAlternatives = null;
        currentConfig = null;
    });

    // Auto mode panel toggle
    const manualModeBtn = document.getElementById('manualModeBtn');
    const autoModeBtn = document.getElementById('autoModeBtn');
    if (manualModeBtn && autoModeBtn) {
        manualModeBtn.addEventListener('click', () => {
            document.getElementById('autoModePanel').classList.add('hidden');
            manualModeBtn.classList.add('active');
            autoModeBtn.classList.remove('active');
        });
        autoModeBtn.addEventListener('click', () => {
            document.getElementById('autoModePanel').classList.remove('hidden');
            autoModeBtn.classList.add('active');
            manualModeBtn.classList.remove('active');
            
            // Clear channel config div when switching to auto mode
            const channelConfigDiv = document.getElementById('channelConfig');
            if (channelConfigDiv) {
                channelConfigDiv.innerHTML = '';
            }
            
            // Hide results section
            if (resultsSection) {
                resultsSection.classList.add('hidden');
            }
        });
    }

    // Update total desired time when days/hours change
    if (desiredDaysInput) {
        desiredDaysInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (desiredHoursInput) {
        desiredHoursInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (dailyUsageHoursInput) {
        dailyUsageHoursInput.addEventListener('input', updateTotalDesiredTime);
    }
    
    // Initialize total desired time display
    updateTotalDesiredTime();

    // Load saved state if any
    try { loadSavedState(); } catch (e) { console.warn('loadSavedState failed:', e); }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', init);

