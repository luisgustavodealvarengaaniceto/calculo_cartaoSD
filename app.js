// Main Application Logic
let currentModel = null;
let currentConfig = null;
let recordingChart = null;
const currentLang = 'pt-BR'; // Fixed to Portuguese

// Simple translation function (Portuguese only)
function t(key) {
    const translations = {
        'configuration': 'Configuração',
        'fixed_configuration': 'Configuração Fixa',
        'resolution': 'Resolução',
        'fps': 'FPS (Quadros/seg)',
        'bitrate': 'Bitrate (Mbps)',
        'codec': 'Codec',
        'hours': 'horas',
        'days': 'dias',
        'cardCapacity': 'Capacidade do Cartão',
        'usableCapacity': 'Espaço Útil',
        'activeChannelsCount': 'Canais Ativos'
    };
    return translations[key] || key;
}

// DOM Elements
const modelCards = document.querySelectorAll('.model-card');
const configSection = document.getElementById('configSection');
const resultsSection = document.getElementById('resultsSection');
const cardSizeSelect = document.getElementById('cardSize');
const channelCountInput = document.getElementById('channelCount');
const channelConfigDiv = document.getElementById('channelConfig');
const calculateBtn = document.getElementById('calculateBtn');
const resetBtn = document.getElementById('resetBtn');
const presetSection = document.getElementById('presetSection');
const presetsContainer = document.getElementById('presetsContainer');
const customConfigBtn = document.getElementById('customConfigBtn');
const manualConfigSection = document.getElementById('manualConfigSection');
const manualModeBtn = document.getElementById('manualModeBtn');
const autoModeBtn = document.getElementById('autoModeBtn');
const autoModePanel = document.getElementById('autoModePanel');
const manualConfigPanel = document.getElementById('manualConfigPanel');
const desiredDaysInput = document.getElementById('desiredDays');
const desiredHoursInput = document.getElementById('desiredHours');
const totalDesiredTimeSpan = document.getElementById('totalDesiredTime');
const generateConfigBtn = document.getElementById('generateConfigBtn');
const cardCountSelector = document.getElementById('cardCountSelector');
const oneCardBtn = document.getElementById('oneCardBtn');
const twoCardsBtn = document.getElementById('twoCardsBtn');
const recommendedSection = document.getElementById('recommendedSection');
const recommendedAlternatives = document.getElementById('recommendedAlternatives');
const channelPriorityDiv = document.getElementById('channelPriorityDiv');
const channelPrioritySelect = document.getElementById('channelPriority');

// State
let isReverseCalcMode = false;
let autoGeneratedConfig = null;
let lastTargetBitrate = null; // Store for recommended alternatives
let lastDesiredHours = null; // Store for recommended alternatives
let useOneCardOnly = false; // For JC450: default is 2 cards
let selectedPriorityChannel = 'free'; // Default: free mode (different bitrates allowed)
let activeChannels = []; // For JC181/JC400: which channels are recording
let updatingCheckboxes = false; // Flag to prevent checkbox sync loops
let configAlternatives = null; // Store alternative configurations from auto mode

// Initialize Application
function init() {
    console.log('Initializing DVR Calculator...');
    attachEventListeners();
    
    // Don't load saved state on first init - let user select model
    // loadSavedState();
    
    console.log('DVR Calculator initialized successfully');
}

// Attach Event Listeners
function attachEventListeners() {
    modelCards.forEach(card => {
        card.addEventListener('click', () => selectModel(card.dataset.model));
    });
    
    if (calculateBtn) calculateBtn.addEventListener('click', calculateRecording);
    if (resetBtn) resetBtn.addEventListener('click', resetCalculator);
    
    // channelCountInput removed - using checkboxes instead
    
    if (cardSizeSelect) {
        cardSizeSelect.addEventListener('change', saveState);
    }
    
    // Mode toggle buttons
    if (manualModeBtn) {
        manualModeBtn.addEventListener('click', () => switchToManualMode());
    }
    if (autoModeBtn) {
        autoModeBtn.addEventListener('click', () => switchToAutoMode());
    }
    
    // Auto mode inputs
    if (desiredDaysInput) {
        desiredDaysInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (desiredHoursInput) {
        desiredHoursInput.addEventListener('input', updateTotalDesiredTime);
    }
    if (generateConfigBtn) {
        console.log('Generate config button found, attaching listener...');
        generateConfigBtn.addEventListener('click', generateAutoConfig);
    } else {
        console.warn('Generate config button NOT found!');
    }
    
    // Card count buttons for JC450
    if (oneCardBtn) {
        oneCardBtn.addEventListener('click', () => selectCardCount(1));
    }
    if (twoCardsBtn) {
        twoCardsBtn.addEventListener('click', () => selectCardCount(2));
    }
    
    // Channel priority selector
    if (channelPrioritySelect) {
        channelPrioritySelect.addEventListener('change', (e) => {
            selectedPriorityChannel = e.target.value;
            console.log('Channel priority changed to:', selectedPriorityChannel);
        });
    }
    
    // Realistic Corrections checkbox
    const realisticCorrectionsCheckbox = document.getElementById('realisticCorrectionsCheckbox');
    if (realisticCorrectionsCheckbox) {
        realisticCorrectionsCheckbox.addEventListener('change', (e) => {
            calculator.updateConfig({ useRealisticCorrections: e.target.checked });
            console.log('Realistic Corrections:', e.target.checked ? 'ENABLED ✅' : 'DISABLED (theoretical only)');
            
            // Recalculate if there's an active configuration
            if (currentConfig && currentConfig.results) {
                const cardSize = parseInt(cardSizeSelect.value);
                const useDualCard = currentModel && currentModel.dualCard && !useOneCardOnly;
                const results = calculator.calculateTotal(cardSize, currentConfig.channels, useDualCard);
                currentConfig.results = results;
                displayResults(results);
            }
        });
    }
    
    console.log('Event listeners attached');
}

// Update Active Channels Checkboxes (for all models)
function updateActiveChannelsCheckboxes() {
    const activeChannelsDiv = document.getElementById('activeChannelsDiv');
    const activeChannelsCheckboxes = document.getElementById('activeChannelsCheckboxes');
    const activeChannelsDivManual = document.getElementById('activeChannelsDivManual');
    const activeChannelsCheckboxesManual = document.getElementById('activeChannelsCheckboxesManual');
    
    if (!currentModel) return;
    
    // Show for all multi-channel models
    if (!currentModel.channels || currentModel.channels.length < 2) {
        if (activeChannelsDiv) activeChannelsDiv.classList.add('hidden');
        if (activeChannelsDivManual) activeChannelsDivManual.classList.add('hidden');
        return;
    }
    
    // Show both divs
    if (activeChannelsDiv) activeChannelsDiv.classList.remove('hidden');
    if (activeChannelsDivManual) activeChannelsDivManual.classList.remove('hidden');
    
    // Clear existing checkboxes
    if (activeChannelsCheckboxes) activeChannelsCheckboxes.innerHTML = '';
    if (activeChannelsCheckboxesManual) activeChannelsCheckboxesManual.innerHTML = '';
    
    // Get channel names based on model
    let channelNames = [];
    if (currentModel.id === 'jc400') {
        channelNames = ['OUT (Canal Externo)', 'IN (Canal Interno)'];
    } else if (currentModel.id === 'jc181') {
        channelNames = ['CH1 (Canal 1)', 'CH2 (Canal 2)'];
    } else if (currentModel.id === 'jc371') {
        channelNames = ['CH1 (Canal 1)', 'CH2 (Canal 2)', 'CH3 (Canal 3)'];
    } else if (currentModel.id === 'jc450') {
        channelNames = ['CH1 (Canal 1)', 'CH2 (Canal 2)', 'CH3 (Canal 3)', 'CH4 (Canal 4)', 'CH5 (Canal 5)'];
    } else {
        // Fallback for any other model
        channelNames = currentModel.channels.map((ch, idx) => ch.name || `Canal ${idx + 1}`);
    }
    
    // Initialize all channels as active if empty
    if (activeChannels.length === 0) {
        activeChannels = currentModel.channels.map((_, idx) => idx);
    }
    
    // Set flag to prevent change events during initialization
    updatingCheckboxes = true;
    
    // Create checkbox for each channel (for both auto and manual modes)
    currentModel.channels.forEach((channel, idx) => {
        const isChecked = activeChannels.includes(idx);
        
        // Create for auto mode
        if (activeChannelsCheckboxes) {
            const checkboxDiv = createChannelCheckbox(idx, channelNames[idx], isChecked);
            activeChannelsCheckboxes.appendChild(checkboxDiv);
        }
        
        // Create for manual mode
        if (activeChannelsCheckboxesManual) {
            const checkboxDivManual = createChannelCheckbox(idx, channelNames[idx], isChecked);
            activeChannelsCheckboxesManual.appendChild(checkboxDivManual);
        }
    });
    
    // Reset flag AFTER all pending change events have been processed
    // Use setTimeout to ensure events triggered by setting checked=true are ignored
    setTimeout(() => {
        updatingCheckboxes = false;
    }, 0);
}

// Create Channel Checkbox
function createChannelCheckbox(idx, channelName, isChecked) {
    const checkboxDiv = document.createElement('div');
    checkboxDiv.className = 'flex items-center p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors';
    checkboxDiv.innerHTML = `
        <input type="checkbox" 
               id="channel_${idx}_${Math.random()}" 
               data-channel="${idx}"
               class="channel-checkbox w-5 h-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 cursor-pointer">
        <label for="channel_${idx}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer flex-1">
            ${channelName}
        </label>
    `;
    
    const checkbox = checkboxDiv.querySelector('input[type="checkbox"]');
    
    // Set checked state BEFORE adding event listener to avoid triggering change event
    console.log(`🔧 Setting checkbox ${idx} checked property to ${isChecked}`);
    checkbox.checked = isChecked;
    
    // Add MutationObserver to detect who is modifying the checkbox
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'checked') {
                console.log(`� MutationObserver: checkbox ${idx} 'checked' attribute changed!`);
                console.log('   New value:', checkbox.checked);
                console.trace('   Stack trace:');
            }
        });
    });
    
    observer.observe(checkbox, { 
        attributes: true, 
        attributeFilter: ['checked'] 
    });
    
    checkbox.addEventListener('change', (e) => {
        // Log stack trace to see where this is coming from
        console.log('🔔 Checkbox change event triggered!');
        console.log('   Stack trace:', new Error().stack);
        console.log(`   Channel ${parseInt(e.target.dataset.channel)}, Checked: ${e.target.checked}`);
        console.log('   updatingCheckboxes flag:', updatingCheckboxes);
        
        // Ignore change events during programmatic updates
        if (updatingCheckboxes) {
            console.log('⏭️  Skipping checkbox change (programmatic update)');
            return;
        }
        
        const channelIdx = parseInt(e.target.dataset.channel);
        console.log('   Before change - activeChannels:', [...activeChannels]);
        
        if (e.target.checked) {
            if (!activeChannels.includes(channelIdx)) {
                activeChannels.push(channelIdx);
            }
        } else {
            activeChannels = activeChannels.filter(ch => ch !== channelIdx);
        }
        
        console.log('   After change - activeChannels:', [...activeChannels]);
        
        // Ensure at least one channel is active
        if (activeChannels.length === 0) {
            e.target.checked = true;
            activeChannels.push(channelIdx);
            alert('Pelo menos um canal deve estar ativo para gravação.');
        }
        
        // Update all checkboxes with same channel index (set flag to prevent loops)
        console.log('🔒 Setting updatingCheckboxes = true (syncing checkboxes for channel', channelIdx, ')');
        updatingCheckboxes = true;
        document.querySelectorAll(`input[data-channel="${channelIdx}"]`).forEach(cb => {
            cb.checked = activeChannels.includes(channelIdx);
        });
        console.log('🔓 Setting updatingCheckboxes = false (sync complete)');
        updatingCheckboxes = false;
        
        // Update manual configuration visibility
        updateManualConfigVisibility();
        
        console.log('Active channels:', activeChannels);
    });
    
    return checkboxDiv;
}

// Update Manual Config Visibility based on active channels
function updateManualConfigVisibility() {
    if (!currentModel || !channelConfigDiv) return;
    
    // Initialize active channels if empty
    if (activeChannels.length === 0 && currentModel.channels) {
        activeChannels = currentModel.channels.map((_, idx) => idx);
        console.log('Initialized active channels:', activeChannels);
    }
    
    // Get all channel config cards
    const channelCards = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    console.log('Updating visibility - Active channels:', activeChannels, 'Total cards:', channelCards.length);
    
    channelCards.forEach((card, index) => {
        if (activeChannels.includes(index)) {
            card.classList.remove('hidden');
            card.style.display = 'block';
        } else {
            card.classList.add('hidden');
            card.style.display = 'none';
        }
    });
}

// Select Card Count (for JC450)
function selectCardCount(cardCount) {
    useOneCardOnly = (cardCount === 1);
    
    // Update button states
    if (oneCardBtn && twoCardsBtn) {
        if (cardCount === 1) {
            oneCardBtn.classList.add('active');
            twoCardsBtn.classList.remove('active');
        } else {
            oneCardBtn.classList.remove('active');
            twoCardsBtn.classList.add('active');
        }
    }
    
    // Update card size options display
    updateCardSizeDisplay();
}

// Update Card Size Display
function updateCardSizeDisplay() {
    if (!currentModel) return;
    
    const cardSizeLabel = document.getElementById('cardSizeLabel');
    const cardSizeHint = document.getElementById('cardSizeHint');
    
    // Repopulate card sizes with updated labels
    cardSizeSelect.innerHTML = '';
    currentModel.cardSizes.forEach(size => {
        const option = document.createElement('option');
        option.value = size;
        
        if (currentModel.dualCard && !useOneCardOnly) {
            option.textContent = `${size} GB × 2 = ${size * 2} GB total`;
        } else {
            option.textContent = `${size} GB`;
        }
        cardSizeSelect.appendChild(option);
    });
    
    // Update label
    if (currentModel.dualCard) {
        if (useOneCardOnly) {
            if (cardSizeLabel) cardSizeLabel.textContent = 'Tamanho do Cartão SD (1 cartão)';
            if (cardSizeHint) {
                cardSizeHint.textContent = 'ℹ️ Usando apenas 1 cartão SD.';
                cardSizeHint.classList.remove('hidden');
            }
        } else {
            if (cardSizeLabel) cardSizeLabel.textContent = 'Capacidade por Cartão SD (2 cartões)';
            if (cardSizeHint) {
                cardSizeHint.textContent = '⚠️ JC450 utiliza 2 cartões SD. Selecione a capacidade de CADA cartão.';
                cardSizeHint.classList.remove('hidden');
            }
        }
    } else {
        if (cardSizeLabel) cardSizeLabel.textContent = 'Tamanho do Cartão SD';
        if (cardSizeHint) cardSizeHint.classList.add('hidden');
    }
}

// Warning Modal Functions
function showWarningModal(data) {
    const modal = document.getElementById('warningModal');
    const modalContent = document.getElementById('warningModalContent');
    const closeBtn = document.getElementById('warningModalClose');
    const changeCardBtn = document.getElementById('warningModalChangeCard');
    
    if (!modal || !modalContent) return;
    
    // Update modal content
    document.getElementById('warningDesiredTime').textContent = `${data.desiredHours.toFixed(1)} horas`;
    document.getElementById('warningDesiredDays').textContent = `(${data.desiredDays.toFixed(1)} dias)`;
    document.getElementById('warningCurrentCard').textContent = `${data.currentCard} GB`;
    document.getElementById('warningMaxTime').textContent = `${data.maxHours.toFixed(1)} horas`;
    document.getElementById('warningMaxDays').textContent = `(${data.maxDays.toFixed(1)} dias)`;
    document.getElementById('warningSolution').textContent = data.solution;
    
    // Show modal with animation
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    
    setTimeout(() => {
        modalContent.style.transform = 'scale(1)';
        modalContent.style.opacity = '1';
    }, 10);
    
    // Close button
    closeBtn.onclick = () => closeWarningModal();
    
    // Change card button - scroll to card size selector
    changeCardBtn.onclick = () => {
        closeWarningModal();
        cardSizeSelect.focus();
        cardSizeSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
    };
    
    // Close on backdrop click
    modal.onclick = (e) => {
        if (e.target === modal) {
            closeWarningModal();
        }
    };
}

function closeWarningModal() {
    const modal = document.getElementById('warningModal');
    const modalContent = document.getElementById('warningModalContent');
    
    if (!modal || !modalContent) return;
    
    modalContent.style.transform = 'scale(0.95)';
    modalContent.style.opacity = '0';
    
    setTimeout(() => {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }, 200);
}

// Switch to Manual Mode
function switchToManualMode() {
    isReverseCalcMode = false;
    
    // Update button states
    if (manualModeBtn) {
        manualModeBtn.classList.add('active');
    }
    if (autoModeBtn) {
        autoModeBtn.classList.remove('active');
    }
    
    // Show/hide panels
    if (autoModePanel) {
        autoModePanel.classList.add('hidden');
    }
    if (manualConfigPanel) {
        manualConfigPanel.classList.remove('hidden');
    }
    
    // Re-setup manual configuration when switching back from auto mode
    if (currentModel && channelConfigDiv) {
        channelConfigDiv.style.display = 'block';
        setupManualConfiguration();
    }
    
    // Show calculate button in manual mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection && currentModel) {
        calculateButtonSection.classList.remove('hidden');
    }
    
    // Update active channels checkboxes (for all models)
    updateActiveChannelsCheckboxes();
    
    // Clear results
    resultsSection.classList.add('hidden');
}

// Switch to Auto Mode
function switchToAutoMode() {
    isReverseCalcMode = true;
    
    // Update button states
    if (manualModeBtn) {
        manualModeBtn.classList.remove('active');
    }
    if (autoModeBtn) {
        autoModeBtn.classList.add('active');
    }
    
    // Show/hide panels
    if (autoModePanel) {
        autoModePanel.classList.remove('hidden');
    }
    if (manualConfigPanel) {
        manualConfigPanel.classList.add('hidden');
    }
    if (channelConfigDiv) {
        channelConfigDiv.style.display = 'block'; // Show to display suggestions
        channelConfigDiv.innerHTML = '<div class="text-center text-gray-500 p-8">' +
            '<i class="fas fa-arrow-left text-4xl mb-4"></i>' +
            '<p>' + (currentLang === 'pt-BR' 
                ? 'Configure o tempo desejado e clique em "Gerar Configurações Automáticas"' 
                : 'Set desired time and click "Generate Automatic Configurations"') +
            '</p></div>';
    }
    
    // Hide calculate button in auto mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection) {
        calculateButtonSection.classList.add('hidden');
    }
    
    // Clear results
    resultsSection.classList.add('hidden');
    
    // Update active channels checkboxes (for JC181/JC400)
    updateActiveChannelsCheckboxes();
    
    // Update total time display
    updateTotalDesiredTime();
}

// Select Model
function selectModel(modelName) {
    console.log('selectModel called with:', modelName);
    
    if (!isValidModel(modelName)) {
        console.error('Invalid model:', modelName);
        return;
    }
    
    currentModel = getModelConfig(modelName);
    console.log('Current model set to:', currentModel);
    
    // Reset active channels when changing model
    activeChannels = [];
    
    // Update UI
    modelCards.forEach(card => {
        card.classList.remove('active');
        if (card.dataset.model === modelName) {
            card.classList.add('active');
        }
    });
    
    // Show configuration section
    configSection.classList.remove('hidden');
    resultsSection.classList.add('hidden');
    
    // Initialize in manual mode by default
    switchToManualMode();
    
    // Initialize configuration
    initializeConfiguration();
    saveState();
}

// Initialize Configuration
function initializeConfiguration() {
    console.log('initializeConfiguration called');
    console.log('currentModel:', currentModel);
    console.log('cardSizeSelect:', cardSizeSelect);
    
    // Reset to default (2 cards for JC450)
    useOneCardOnly = false;
    
    // Show/hide card count selector for JC450
    if (cardCountSelector) {
        if (currentModel.dualCard) {
            cardCountSelector.classList.remove('hidden');
            // Reset buttons to 2 cards (default)
            if (oneCardBtn) oneCardBtn.classList.remove('active');
            if (twoCardsBtn) twoCardsBtn.classList.add('active');
        } else {
            cardCountSelector.classList.add('hidden');
        }
    }
    
    // Update card size display
    updateCardSizeDisplay();
    
    // Set max card size as default
    cardSizeSelect.value = currentModel.maxCapacity <= Math.max(...currentModel.cardSizes) 
        ? currentModel.maxCapacity 
        : Math.max(...currentModel.cardSizes);
    
    console.log('cardSizeSelect.value set to:', cardSizeSelect.value);
    
    // Update channel priority options
    updateChannelPriorityOptions();
    
    // Note: updateActiveChannelsCheckboxes() is already called by switchToManualMode()
    // No need to call it again here to avoid duplicating checkboxes
    
    // Always setup manual configuration (no presets)
    setupManualConfiguration();
    
    // Show calculate button since we're in manual mode
    const calculateButtonSection = document.getElementById('calculateButtonSection');
    if (calculateButtonSection) {
        calculateButtonSection.classList.remove('hidden');
    }
}

// Update Channel Priority Options
function updateChannelPriorityOptions() {
    if (!channelPrioritySelect || !channelPriorityDiv || !currentModel) return;
    
    // Clear existing options
    channelPrioritySelect.innerHTML = '';
    
    // Add "free" option (default)
    const freeOption = document.createElement('option');
    freeOption.value = 'free';
    freeOption.textContent = '🎨 Livre - Bitrates diferentes (mais próximo do tempo)';
    channelPrioritySelect.appendChild(freeOption);
    
    // Add "equal quality" option
    const equalOption = document.createElement('option');
    equalOption.value = 'equal';
    equalOption.textContent = '🎥 Todas as câmeras com mesma qualidade';
    channelPrioritySelect.appendChild(equalOption);
    
    // Add option for each channel (if model has multiple channels)
    if (currentModel.channels && currentModel.channels.length > 1) {
        currentModel.channels.forEach((channel, index) => {
            const option = document.createElement('option');
            option.value = index.toString();
            option.textContent = `⭐ Priorizar ${channel.name || `Canal ${index + 1}`}`;
            channelPrioritySelect.appendChild(option);
        });
        
        // Show the priority selector
        channelPriorityDiv.classList.remove('hidden');
    } else {
        // Hide if only one channel
        channelPriorityDiv.classList.add('hidden');
    }
    
    // Reset selection to free (default)
    selectedPriorityChannel = 'free';
    channelPrioritySelect.value = 'free';
}

// Render Preset Cards
// Preset functions removed - always use manual configuration

// Setup Manual Configuration (always active now)

// Setup Manual Configuration
function setupManualConfiguration() {
    console.log('Setting up manual configuration for:', currentModel.name);
    
    // Simply update channel config - no need for channel count input anymore
    updateChannelConfig();
    console.log('Manual configuration setup complete');
    
    // Update visibility based on active channels
    updateManualConfigVisibility();
}

// Update Channel Configuration
function updateChannelConfig() {
    if (!channelConfigDiv || !currentModel) {
        console.warn('Cannot update channel config: missing elements or model');
        return;
    }
    
    channelConfigDiv.innerHTML = '';
    
    // Create cards only for active channels
    const numChannels = currentModel.channels ? currentModel.channels.length : currentModel.maxChannels;
    
    console.log(`Creating ${activeChannels.length} channel cards for ${currentModel.name} (from ${numChannels} total)`);
    
    // Create a card for each channel index (show all, but they'll be hidden/shown by visibility function)
    for (let i = 0; i < numChannels; i++) {
        const channelCard = createChannelCard(i);
        channelConfigDiv.appendChild(channelCard);
    }
    
    saveState();
}

// Create Channel Configuration Card
function createChannelCard(index) {
    const card = document.createElement('div');
    card.className = 'channel-config-card';
    
    const channelInfo = currentModel.channels 
        ? currentModel.channels[index] 
        : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
    
    card.innerHTML = `
        <h4 class="font-bold text-gray-800 mb-3">
            <i class="fas fa-video text-blue-500"></i> ${channelInfo.name}
        </h4>
        <div class="space-y-3" id="channel-${index}">
            ${generateChannelInputs(index, channelInfo)}
        </div>
    `;
    
    return card;
}

// Generate Channel Inputs based on Model
function generateChannelInputs(index, channelInfo) {
    if (currentModel.name === 'JC400') {
        return generateJC400Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC181') {
        return generateJC181Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC371') {
        return generateJC371Inputs(index, channelInfo);
    } else if (currentModel.name === 'JC450') {
        return generateJC450Inputs(index, channelInfo);
    }
    return '';
}

// JC400 Preset Selection
function generateJC400Inputs(index, channelInfo) {
    console.log('JC400 Channel', index, 'Info:', channelInfo);
    
    if (!channelInfo || !channelInfo.presets) {
        console.error('No presets found for JC400 channel', index);
        return '<p class="text-red-500">Erro: Presets não encontrados</p>';
    }
    
    const presets = channelInfo.presets.map(preset => 
        `<option value="${preset.value}" data-resolution="${preset.resolution}" data-bitrate="${preset.bitrate}" data-fps="${preset.fps}">
            ${preset.label}
        </option>`
    ).join('');
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('configuration')}</label>
            <select class="channel-preset w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${presets}
            </select>
        </div>
    `;
}

// JC181 Inputs
function generateJC181Inputs(index, channelInfo) {
    console.log('JC181 Channel', index, 'Info:', channelInfo);
    
    // Get the specific channel configuration from the model
    const channelConfig = currentModel.channels[index];
    
    console.log('JC181 Channel Config:', channelConfig);
    
    // Check if this channel is fixed (CH2 is always 360P@0.5M)
    if (channelConfig.fixed) {
        return `
            <div class="bg-yellow-50/20 border border-yellow-300 rounded-lg p-3">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-lock"></i> <strong>${t('fixed_configuration')}:</strong><br>
                    360P (640×360) @ 0.5 Mbps, 25 FPS
                </p>
            </div>
        `;
    }
    
    // CH1 is configurable
    const resolutionOptions = channelConfig.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    // Get default FPS and bitrates from first resolution
    const defaultFps = channelConfig.fps || [15, 25, 30];
    const defaultBitrates = channelConfig.resolutions[0].bitrates || [1, 2, 4];
    
    return `
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
            <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}" onchange="updateJC181Bitrates(${index})">
                ${resolutionOptions}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('fps')}</label>
            <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultFps.map(fps => `<option value="${fps}">${fps} FPS</option>`).join('')}
            </select>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">${t('bitrate')}</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${defaultBitrates.map(br => `<option value="${br}">${br} Mbps</option>`).join('')}
            </select>
        </div>
    `;
}

// Update JC181 bitrates when resolution changes
window.updateJC181Bitrates = function(channelIndex) {
    const channelConfig = currentModel.channels[channelIndex];
    const resolutionSelect = document.querySelector(`.channel-resolution[data-channel="${channelIndex}"]`);
    const bitrateSelect = document.querySelector(`.channel-bitrate[data-channel="${channelIndex}"]`);
    
    if (!resolutionSelect || !bitrateSelect) return;
    
    const selectedResolution = resolutionSelect.value;
    const resConfig = channelConfig.resolutions.find(r => r.value === selectedResolution);
    
    if (resConfig && resConfig.bitrates) {
        bitrateSelect.innerHTML = resConfig.bitrates.map(br => 
            `<option value="${br}">${br}</option>`
        ).join('');
    }
}

// JC371 Inputs
function generateJC371Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    const codecOptions = currentModel.codecs.map(codec => 
        `<option value="${codec.value}" data-multiplier="${codec.multiplier}">${codec.label}</option>`
    ).join('');
    
    // Get all unique bitrates across all resolutions (0.5-8 Mbps)
    const allBitrates = [...new Set(currentModel.resolutions.flatMap(r => r.bitrates))].sort((a, b) => a - b);
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">Bitrate (Mbps)</label>
                <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${allBitrates.map(br => `<option value="${br}">${br}</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('codec')}</label>
                <select class="channel-codec w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${codecOptions}
                </select>
            </div>
        </div>
    `;
}

// JC450 Inputs
function generateJC450Inputs(index, channelInfo) {
    const resolutionOptions = currentModel.resolutions.map(res => 
        `<option value="${res.value}">${res.label}</option>`
    ).join('');
    
    return `
        <div class="grid grid-cols-2 gap-2">
            <div>
                <label class="block text-xs text-gray-600 mb-1">${t('resolution')}</label>
                <select class="channel-resolution w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${resolutionOptions}
                </select>
            </div>
            <div>
                <label class="block text-xs text-gray-600 mb-1">FPS</label>
                <select class="channel-fps w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                    ${currentModel.fps.map(fps => `<option value="${fps}">${fps}</option>`).join('')}
                </select>
            </div>
        </div>
        <div>
            <label class="block text-xs text-gray-600 mb-1">Bitrate</label>
            <select class="channel-bitrate w-full px-3 py-2 text-sm border border-gray-300 rounded bg-white text-gray-800" data-channel="${index}">
                ${currentModel.resolutions[0].bitrates.map(br => `<option value="${br}">${br}M</option>`).join('')}
            </select>
        </div>
    `;
}

// Update Total Desired Time Display
function updateTotalDesiredTime() {
    if (!desiredDaysInput || !desiredHoursInput || !totalDesiredTimeSpan) return;
    
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    const totalHours = (days * 24) + hours;
    
    const hoursText = t('hours');
    totalDesiredTimeSpan.textContent = totalHours + ' ' + hoursText + ' (' + days + 'd ' + hours + 'h)';
}

// Generate Auto Configuration
function generateAutoConfig() {
    console.log('=== Generate Auto Config Called ===');
    console.log('Current Model:', currentModel);
    
    if (!currentModel) {
        console.error('No model selected!');
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, selecione um modelo primeiro.' 
            : 'Please select a model first.');
        return;
    }
    
    // Read current priority selection (in case it wasn't captured by event listener)
    if (channelPrioritySelect) {
        selectedPriorityChannel = channelPrioritySelect.value;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    const days = parseInt(desiredDaysInput.value) || 0;
    const hours = parseInt(desiredHoursInput.value) || 0;
    const totalDesiredHours = (days * 24) + hours;
    
    console.log('Card Size:', cardSize, 'GB');
    console.log('Desired Time:', totalDesiredHours, 'hours', '(' + days + 'd ' + hours + 'h)');
    
    if (totalDesiredHours <= 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, informe um tempo desejado maior que zero.' 
            : 'Please enter a desired time greater than zero.');
        return;
    }
    
    // Get number of channels for this model
    const numChannels = currentModel.channels ? currentModel.channels.length : currentModel.maxChannels || 1;
    
    // Generate ALL possible configurations
    const allPossibleConfigs = generateAllPossibleConfigs(numChannels);
    
    console.log('Generated', allPossibleConfigs.length, 'possible configurations');
    if (allPossibleConfigs.length > 0) {
        console.log('Sample configs:', allPossibleConfigs.slice(0, 3).map(c => 
            c.configs.filter(ch => ch !== null).map(ch => `${ch.resolution}P@${ch.bitrate}M`).join(', ')
        ));
    }
    console.log('🎯 Priority setting:', 
        selectedPriorityChannel === 'free' ? 'FREE MODE (different bitrates allowed)' :
        selectedPriorityChannel === 'equal' ? 'EQUAL (all same)' : 
        `CHANNEL ${selectedPriorityChannel} gets higher quality`);
    
    if (selectedPriorityChannel === 'free') {
        const priorityOrder = getChannelPriorityOrder();
        const channelNames = priorityOrder.map(chIdx => {
            const ch = currentModel.channels?.[chIdx];
            return ch ? (ch.name || `CH${chIdx + 1}`) : `CH${chIdx + 1}`;
        });
        console.log('   📊 Channel priority order (highest to lowest):', channelNames.join(' > '));
    }
    
    if (allPossibleConfigs.length === 0) {
        alert(currentLang === 'pt-BR'
            ? 'Erro ao gerar configurações. Verifique se o modelo está configurado corretamente.'
            : 'Error generating configurations. Check if the model is configured correctly.');
        return;
    }
    
    // Calculate actual recording time for each configuration and find the closest
    // Priority: configurations that meet or exceed the desired time
    let bestConfig = null;
    let minTimeDifference = Infinity;
    
    // First pass: try to find configs that meet or exceed the desired time
    const validConfigs = [];
    
    allPossibleConfigs.forEach(configSet => {
        const channels = configSet.configs
            .map((config, index) => {
                // Skip null configs (inactive channels)
                if (config === null) return null;
                
                const channelInfo = currentModel.channels && currentModel.channels[index] 
                    ? currentModel.channels[index] 
                    : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
                
                // Handle JC400 preset-based configuration
                if (currentModel.name === 'JC400' && config.preset !== undefined) {
                    const presetData = channelInfo.presets[config.preset];
                    return {
                        active: true,
                        channelId: channelInfo.id,
                        channelName: channelInfo.name,
                        resolution: presetData.resolution.toString(),
                        fps: presetData.fps,
                        bitrate: presetData.bitrate,
                        codec: 'H.264',
                        codecMultiplier: 1,
                        preset: config.preset
                    };
                }
                
                // Handle standard resolution/fps/bitrate configuration
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: config.resolution.toString(),
                    fps: config.fps,
                    bitrate: config.bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    fixed: config.fixed || false
                };
            })
            .filter(ch => ch !== null); // Remove null entries
        
        // Calculate recording time based on model type
        let results;
        if (currentModel.name === 'JC450') {
            // Use JC450-specific dual card calculation
            results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
        } else {
            // Use regular calculation for other models
            const useDualCard = currentModel.dualCard && !useOneCardOnly;
            results = calculator.calculateTotal(cardSize, channels, useDualCard);
        }
        
        configSet.calculatedTime = results.totalTimeHours;
        configSet.channels = channels;
        
        // Store all configs for later analysis
        if (results.totalTimeHours >= totalDesiredHours) {
            validConfigs.push(configSet);
        }
    });
    
    // If no configs meet the requirement, accept configs within 20% below desired
    if (validConfigs.length === 0) {
        const tolerance = totalDesiredHours * 0.2; // 20% below
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime >= totalDesiredHours - tolerance) {
                validConfigs.push(configSet);
            }
        });
        if (validConfigs.length > 0) {
            console.log(`⚠️ No configs >= ${totalDesiredHours}h. Accepting configs within 20% (>= ${(totalDesiredHours - tolerance).toFixed(1)}h)`);
        }
    }
    
    // If we have configs that meet the requirement, pick the closest one
    if (validConfigs.length > 0) {
        const sortedValid = validConfigs.map(c => c.calculatedTime).sort((a, b) => a - b);
        console.log(`✅ Found ${validConfigs.length} configs >= ${totalDesiredHours}h:`, sortedValid.map(t => t.toFixed(1) + 'h').join(', '));
        console.log(`   Selecting closest to ${totalDesiredHours}h...`);
        
        // Find the closest config to desired time
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        
        if (priorityChannelIndex === -2) {
            // FREE MODE: Use channel priority order (JC371: CH2->CH1->CH3, JC450: CH3->CH1->CH2->CH4->CH5, JC400: IN->OUT)
            let bestScore = -Infinity;
            validConfigs.forEach(configSet => {
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive = above desired
                const totalScore = calculateFreeModeScore(configSet, timeDifference);
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            });
            console.log('   🎨 Free mode: Selected config with priority order score');
        } else if (priorityChannelIndex >= 0) {
            // Priority mode: find config >= desired time with best score (close to time + high priority bitrate)
            let bestScore = -Infinity;
            validConfigs.forEach(configSet => {
                // Penalize configs that are far from desired time
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive = above desired
                const priorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                
                // Score: prefer closer to desired time, then higher priority bitrate
                // Use exponential penalty for time difference to strongly prefer closer times
                const timeScore = 10000 / (1 + timeDifference); // Closer = higher score
                const bitrateScore = priorityBitrate * 100; // Higher bitrate = higher score
                const totalScore = timeScore + bitrateScore;
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            });
        } else {
            // No priority - just pick the one closest to (but >= ) desired time
            let minDiff = Infinity;
            validConfigs.forEach(configSet => {
                const timeDifference = configSet.calculatedTime - totalDesiredHours; // Positive value
                if (timeDifference < minDiff) {
                    minDiff = timeDifference;
                    bestConfig = configSet;
                }
            });
        }
    } else {
        // No config meets the requirement - find the one closest to target
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        let bestScore = -Infinity;
        
        allPossibleConfigs.forEach(configSet => {
            // Find config closest to desired time
            const timeDifference = Math.abs(configSet.calculatedTime - totalDesiredHours);
            
            if (priorityChannelIndex === -2) {
                // FREE MODE: Use channel priority order
                const totalScore = calculateFreeModeScore(configSet, timeDifference);
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            } else if (priorityChannelIndex >= 0 && configSet.configs[priorityChannelIndex]) {
                const priorityBitrate = configSet.configs[priorityChannelIndex].bitrate || 0;
                
                // Prioritize time proximity, then bitrate
                const timeScore = 1000 / (1 + timeDifference); // Closer time = higher score
                const bitrateScore = priorityBitrate * 10;
                const totalScore = timeScore + bitrateScore;
                
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestConfig = configSet;
                }
            } else {
                // No priority - pick closest to time
                const score = 1000 / (1 + timeDifference);
                if (score > bestScore) {
                    bestScore = score;
                    bestConfig = configSet;
                }
            }
        });
    }
    
    // Use the best configuration found
    autoGeneratedConfig = bestConfig ? bestConfig.configs : generateConfigForModel(0, numChannels);
    
    // Find alternative configurations (one above, one below)
    let alternativeHigher = null;
    let alternativeLower = null;
    
    if (bestConfig) {
        const bestTime = bestConfig.calculatedTime;
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        // Find configuration with higher time (closer to desired if below, or slightly above)
        let minHigherDiff = Infinity;
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime > bestTime) {
                const diff = configSet.calculatedTime - bestTime;
                if (diff < minHigherDiff) {
                    // If priority enabled, check if priority channel has same or higher bitrate
                    if (priorityChannelIndex >= 0) {
                        const bestPriorityBitrate = bestConfig.configs[priorityChannelIndex]?.bitrate || 0;
                        const altPriorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                        if (altPriorityBitrate >= bestPriorityBitrate * 0.8) { // Allow 20% lower
                            minHigherDiff = diff;
                            alternativeHigher = configSet;
                        }
                    } else {
                        minHigherDiff = diff;
                        alternativeHigher = configSet;
                    }
                }
            }
        });
        
        // Find configuration with lower time
        let minLowerDiff = Infinity;
        allPossibleConfigs.forEach(configSet => {
            if (configSet.calculatedTime < bestTime) {
                const diff = bestTime - configSet.calculatedTime;
                if (diff < minLowerDiff) {
                    // If priority enabled, prefer higher priority bitrate
                    if (priorityChannelIndex >= 0) {
                        const altPriorityBitrate = configSet.configs[priorityChannelIndex]?.bitrate || 0;
                        const currentAltBitrate = alternativeLower?.configs[priorityChannelIndex]?.bitrate || 0;
                        if (altPriorityBitrate >= currentAltBitrate) {
                            minLowerDiff = diff;
                            alternativeLower = configSet;
                        }
                    } else {
                        minLowerDiff = diff;
                        alternativeLower = configSet;
                    }
                }
            }
        });
    }
    
    // Log selected configuration and alternatives
    if (bestConfig) {
        console.log('✅ Selected configuration:');
        bestConfig.configs.forEach((config, i) => {
            if (config) {
                const isPriority = (selectedPriorityChannel !== 'equal' && i === parseInt(selectedPriorityChannel));
                console.log(`   CH${i}: ${config.resolution || config.preset}@${config.fps || 0}fps, ${config.bitrate}M ${isPriority ? '← PRIORITY' : ''}`);
            }
        });
        console.log(`   Total time: ${bestConfig.calculatedTime.toFixed(1)} hours (desired: ${totalDesiredHours.toFixed(1)}h)`);
        
        if (alternativeHigher) {
            console.log('📈 Alternative (higher time): ' + alternativeHigher.calculatedTime.toFixed(1) + 'h');
        }
        if (alternativeLower) {
            console.log('📉 Alternative (lower time): ' + alternativeLower.calculatedTime.toFixed(1) + 'h');
        }
    }
    
    // Store alternatives temporarily (will be added to currentConfig later)
    configAlternatives = {
        bestConfig: bestConfig,
        alternativeHigher: alternativeHigher,
        alternativeLower: alternativeLower,
        desiredTime: totalDesiredHours
    };
    
    // Check if the best configuration can achieve the desired time
    if (bestConfig && bestConfig.calculatedTime) {
        const maxPossibleTime = bestConfig.calculatedTime;
        const timeDifferencePercent = ((totalDesiredHours - maxPossibleTime) / totalDesiredHours) * 100;
        
        // If the best possible configuration is still far from the target (more than 30% less)
        if (maxPossibleTime < totalDesiredHours && timeDifferencePercent > 30) {
            const availableCardSizes = currentModel.cardSizes || [16, 32, 64, 128, 256];
            const currentCardIndex = availableCardSizes.indexOf(cardSize);
            const nextCardSize = currentCardIndex < availableCardSizes.length - 1 
                ? availableCardSizes[currentCardIndex + 1] 
                : null;
            
            let solutionText = '';
            if (nextCardSize) {
                solutionText = currentLang === 'pt-BR'
                    ? `Use um cartão SD de ${nextCardSize}GB ou maior para atingir o tempo desejado.`
                    : `Use an SD card of ${nextCardSize}GB or larger to achieve the desired time.`;
            } else {
                solutionText = currentLang === 'pt-BR'
                    ? `Use o maior cartão SD disponível (${availableCardSizes[availableCardSizes.length - 1]}GB) ou reduza o tempo desejado de gravação.`
                    : `Use the largest available SD card (${availableCardSizes[availableCardSizes.length - 1]}GB) or reduce the desired recording time.`;
            }
            
            // Show modal instead of alert
            showWarningModal({
                desiredHours: totalDesiredHours,
                desiredDays: totalDesiredHours / 24,
                currentCard: cardSize,
                maxHours: maxPossibleTime,
                maxDays: maxPossibleTime / 24,
                solution: solutionText
            });
            
            return; // Don't proceed with calculation
        }
    }
    
    // Calculate required bitrate for display purposes
    const MB_PER_GB = 1000;
    const availableSpaceMB = cardSize * MB_PER_GB * 0.9;
    const requiredTotalMBh = availableSpaceMB / totalDesiredHours;
    
    // Count only active channels (for JC181/JC400)
    const activeChannelCount = (currentModel.id === 'jc181' || currentModel.id === 'jc400') 
        ? activeChannels.length 
        : numChannels;
    
    const requiredMBhPerChannel = requiredTotalMBh / activeChannelCount;
    const requiredBitratePerChannel = requiredMBhPerChannel / 450;
    
    // Display suggested configurations on the right side
    displaySuggestedConfigs(autoGeneratedConfig, requiredBitratePerChannel, totalDesiredHours);
}

// Display Suggested Configurations
function displaySuggestedConfigs(configs, targetBitrate, desiredHours) {
    const channelConfigDiv = document.getElementById('channelConfig');
    if (!channelConfigDiv) return;
    
    // Store for recommended alternatives
    lastTargetBitrate = targetBitrate;
    lastDesiredHours = desiredHours;
    
    channelConfigDiv.innerHTML = '';
    
    // Header with Jimi blue colors
    const header = document.createElement('div');
    header.className = 'mb-4 p-4 text-white rounded-lg';
    header.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
    header.innerHTML = '<h3 class="text-lg font-bold mb-2">' +
        '<i class="fas fa-lightbulb mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Outras Opções' : 'Other Options') +
        '</h3>' +
        '<p class="text-sm opacity-90">' +
        (currentLang === 'pt-BR' 
            ? 'Outras configurações disponíveis para o cartão selecionado' 
            : 'Other available configurations for the selected card') +
        '</p>' +
        '<p class="text-xs mt-1 opacity-80">' +
        (currentLang === 'pt-BR' 
            ? 'Explore diferentes combinações de qualidade e tempo de gravação' 
            : 'Explore different combinations of quality and recording time') +
        '</p>';
    channelConfigDiv.appendChild(header);
    
    // Configuration cards (without GB consumption)
    configs.forEach((config, index) => {
        // Skip null configs (inactive channels)
        if (config === null) return;
        
        const card = document.createElement('div');
        card.className = 'p-4 bg-white rounded-lg shadow-md mb-3';
        card.style.border = '2px solid #0066CC';
        
        const channelName = currentModel.channels && currentModel.channels[index] 
            ? currentModel.channels[index].name 
            : 'Canal ' + (index + 1);
        
        const isFixed = config.fixed || (currentModel.name === 'JC181' && index === 1);
        
        // Get actual config values (handle JC400 presets)
        let resolution, fps, bitrate;
        if (currentModel.name === 'JC400' && config.preset !== undefined) {
            const channelInfo = currentModel.channels[index];
            const presetData = channelInfo.presets[config.preset];
            resolution = presetData.resolution;
            fps = presetData.fps;
            bitrate = presetData.bitrate;
        } else {
            resolution = config.resolution;
            fps = config.fps;
            bitrate = config.bitrate;
        }
        
        // Calculate MB/h consumption
        const consumptionMBh = bitrate * 450; // 1 Mbps = 450 MB/h
        
        card.innerHTML = '<div class="flex items-center justify-between mb-3">' +
            '<h4 class="font-bold text-gray-800">' +
            '<i class="fas fa-video mr-2" style="color: #0066CC;"></i>' +
            channelName +
            '</h4>' +
            (isFixed ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded">' + t('fixed_configuration') + '</span>' : '') +
            '</div>' +
            '<div class="space-y-2 text-sm text-gray-700">' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-image text-blue-500 mr-2"></i>' + t('resolution') + ':</span>' +
            '<strong>' + resolution + 'P</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-tachometer-alt text-green-500 mr-2"></i>FPS:</span>' +
            '<strong>' + fps + ' fps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 bg-gray-50 rounded">' +
            '<span><i class="fas fa-signal text-purple-500 mr-2"></i>Bitrate:</span>' +
            '<strong>' + bitrate + ' Mbps</strong>' +
            '</div>' +
            '<div class="flex items-center justify-between p-2 rounded" style="background-color: #E6F0FF; border: 1px solid #0066CC;">' +
            '<span><i class="fas fa-clock mr-2" style="color: #0066CC;"></i>' + 
            (currentLang === 'pt-BR' ? 'Taxa de gravação:' : 'Recording rate:') + '</span>' +
            '<strong style="color: #0052A3;">' + consumptionMBh.toFixed(0) + ' MB/h</strong>' +
            '</div>' +
            '</div>';
        
        channelConfigDiv.appendChild(card);
    });
    
    // Info box
    const infoBox = document.createElement('div');
    infoBox.className = 'mt-4 p-3 bg-green-50 border border-green-200 rounded-lg text-sm text-green-800';
    infoBox.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-info-circle text-green-600 mr-2 mt-1"></i>' +
        '<div>' +
        '<strong>' + (currentLang === 'pt-BR' ? 'Esta é a configuração mais próxima do seu objetivo' : 'This is the configuration closest to your goal') + '</strong><br>' +
        '<span class="text-xs">' + 
        (currentLang === 'pt-BR' 
            ? 'Aguarde o cálculo dos resultados detalhados abaixo.' 
            : 'Wait for detailed results calculation below.') +
        '</span>' +
        '</div>' +
        '</div>';
    channelConfigDiv.appendChild(infoBox);
    
    // Calculate directly without using applyAutoConfigToUI to avoid showing channel selectors
    setTimeout(function() {
        calculateAutoConfig(autoGeneratedConfig);
    }, 100);
}

// Calculate Auto Config directly
function calculateAutoConfig(configs) {
    if (!configs || configs.length === 0) return;
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Build channels array from auto-generated configs (filter out null/inactive channels)
    const channels = configs
        .map((config, index) => {
            // Skip null configs (inactive channels)
            if (config === null) return null;
            
            const channelInfo = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index] 
                : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
            
            return {
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: config.resolution.toString(),
                fps: config.fps,
                bitrate: config.bitrate,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: config.fixed || false,
                preset: config.preset
            };
        })
        .filter(ch => ch !== null); // Remove null entries
    
    // Perform calculation (pass dualCard parameter, considering useOneCardOnly)
    let results;
    if (currentModel.name === 'JC450') {
        // Use JC450-specific dual card calculation
        results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
    } else {
        // Use regular calculation for other models
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        results = calculator.calculateTotal(cardSize, channels, useDualCard);
    }
    
    currentConfig = { 
        modelName: currentModel.name, 
        results, 
        channels,
        // Add alternatives from auto-config if available
        bestConfig: configAlternatives?.bestConfig,
        alternativeHigher: configAlternatives?.alternativeHigher,
        alternativeLower: configAlternatives?.alternativeLower,
        desiredTime: configAlternatives?.desiredTime
    };
    
    // Display results
    displayResults(results);
    resultsSection.classList.remove('hidden');
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    // Show recommended alternatives
    showRecommendedAlternatives();
    
    saveState();
}

// Show Recommended Alternatives
function showRecommendedAlternatives() {
    if (!lastTargetBitrate || !lastDesiredHours) return;
    
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedAlternatives = document.getElementById('recommendedAlternatives');
    
    if (!recommendedSection || !recommendedAlternatives) return;
    
    // Clear previous content
    recommendedAlternatives.innerHTML = '';
    
    // Generate alternative configurations
    const alternatives = generateAlternativeConfigs(lastTargetBitrate);
    
    if (alternatives.length === 0) {
        recommendedSection.classList.add('hidden');
        return;
    }
    
    const cardSize = parseInt(cardSizeSelect.value);
    
    // Calculate results and remove duplicates
    const alternativesWithResults = [];
    const seenConfigs = new Set();
    
    alternatives.forEach((altConfig) => {
        // Calculate results for this alternative
        const channels = altConfig.configs
            .map((config, index) => {
                // Skip null configs (inactive channels)
                if (config === null) return null;
                
                const channelInfo = currentModel.channels && currentModel.channels[index] 
                    ? currentModel.channels[index] 
                    : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
                
                // Handle JC400 presets
                let resolution, fps, bitrate;
                if (currentModel.name === 'JC400' && config.preset !== undefined) {
                    const presetData = channelInfo.presets[config.preset];
                    resolution = presetData.resolution;
                    fps = presetData.fps;
                    bitrate = presetData.bitrate;
                } else {
                    resolution = config.resolution;
                    fps = config.fps;
                    bitrate = config.bitrate;
                }
                
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: resolution.toString(),
                    fps: fps,
                    bitrate: bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    fixed: config.fixed || false
                };
            })
            .filter(ch => ch !== null); // Remove null entries
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard);
        
        // Create a unique key for this configuration
        const configKey = altConfig.configs
            .filter(c => c !== null)
            .map(c => {
                if (c.preset !== undefined) {
                    return `preset${c.preset}`;
                }
                return `${c.resolution}_${c.fps}_${c.bitrate}`;
            }).join('|');
        
        // Only add if not duplicate
        if (!seenConfigs.has(configKey)) {
            seenConfigs.add(configKey);
            alternativesWithResults.push({
                ...altConfig,
                results: results,
                channels: channels
            });
        }
    });
    
    // If no unique alternatives, hide section
    if (alternativesWithResults.length === 0) {
        recommendedSection.classList.add('hidden');
        return;
    }
    
    // Select the most useful alternatives (limit to 3):
    const selectedAlternatives = [];
    
    // 1. Closest to desired time (even if below)
    const sortedByProximity = [...alternativesWithResults].sort((a, b) => {
        return Math.abs(a.results.totalTimeHours - lastDesiredHours) - Math.abs(b.results.totalTimeHours - lastDesiredHours);
    });
    if (sortedByProximity[0]) {
        selectedAlternatives.push({
            ...sortedByProximity[0],
            badge: 'Mais Próximo',
            badgeIcon: '🎯',
            badgeClass: 'bg-purple-100 text-purple-700 border-purple-300',
            description: 'Configuração mais próxima do tempo solicitado'
        });
    }
    
    // 2. Maximum recording time
    const sortedByMaxTime = [...alternativesWithResults].sort((a, b) => {
        return b.results.totalTimeHours - a.results.totalTimeHours;
    });
    if (sortedByMaxTime[0] && !selectedAlternatives.find(alt => 
        JSON.stringify(alt.configs) === JSON.stringify(sortedByMaxTime[0].configs)
    )) {
        selectedAlternatives.push({
            ...sortedByMaxTime[0],
            badge: 'Máximo Tempo',
            badgeIcon: '⏱️',
            badgeClass: 'bg-orange-100 text-orange-700 border-orange-300',
            description: 'Máximo tempo de gravação possível no cartão'
        });
    }
    
    // 3. Maximum quality (highest bitrate)
    const sortedByQuality = [...alternativesWithResults].sort((a, b) => {
        const totalBitrateA = a.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
        const totalBitrateB = b.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
        return totalBitrateB - totalBitrateA;
    });
    if (sortedByQuality[0] && !selectedAlternatives.find(alt => 
        JSON.stringify(alt.configs) === JSON.stringify(sortedByQuality[0].configs)
    ) && selectedAlternatives.length < 3) {
        selectedAlternatives.push({
            ...sortedByQuality[0],
            badge: 'Máxima Qualidade',
            badgeIcon: '💎',
            badgeClass: 'bg-indigo-100 text-indigo-700 border-indigo-300',
            description: 'Melhor qualidade de imagem possível'
        });
    }
    
    // Limit to exactly 3 alternatives
    const finalAlternatives = selectedAlternatives.slice(0, 3);
    
    // If we don't have at least 1 alternative, hide section
    if (finalAlternatives.length === 0) {
        recommendedSection.classList.add('hidden');
        return;
    }
    
    // Show section
    recommendedSection.classList.remove('hidden');
    
    finalAlternatives.forEach((altConfig, altIndex) => {
        const altCard = document.createElement('div');
        altCard.className = 'p-5 bg-white rounded-xl shadow-lg border-2 transition-all cursor-pointer overflow-hidden';
        altCard.style.borderColor = '#E5E7EB';
        
        altCard.onmouseenter = function() {
            this.style.borderColor = '#0066CC';
            this.style.transform = 'translateY(-4px)';
            this.style.boxShadow = '0 12px 24px rgba(0, 102, 204, 0.15)';
        };
        altCard.onmouseleave = function() {
            this.style.borderColor = '#E5E7EB';
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '';
        };
        
        const results = altConfig.results;
        
        // Calculate total bitrate and data consumption
        const totalBitrate = altConfig.channels.reduce((sum, ch) => sum + ch.bitrate, 0);
        const totalMBh = totalBitrate * 450; // MB/h
        
        // Use custom badge if provided (from our selection logic)
        let badge = altConfig.badge || '';
        let badgeClass = altConfig.badgeClass || '';
        let badgeIcon = altConfig.badgeIcon || '';
        let description = altConfig.description || '';
        
        const timeDiff = results.totalTimeHours - lastDesiredHours;
        const timeDiffPercent = Math.abs((timeDiff / lastDesiredHours) * 100);
        
        // If no custom badge, determine from strategy/name
        if (!badge) {
            // Use strategy name if available
            if (altConfig.name) {
                badge = altConfig.name;
                
                // Determine icon and color based on strategy
                if (altConfig.strategy === 'balanced' && altConfig.multiplier < 1) {
                    badgeIcon = '💾';
                    badgeClass = 'bg-green-100 text-green-700 border-green-300';
                    description = 'Menor consumo de espaço, maior tempo de gravação';
                } else if (altConfig.strategy === 'balanced' && altConfig.multiplier > 1) {
                    badgeIcon = '⭐';
                    badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                    description = 'Melhor qualidade de imagem em todos os canais';
                } else if (altConfig.strategy === 'mixed-high-ch1' || altConfig.strategy === 'out-priority') {
                    badgeIcon = '🎯';
                    badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                    description = 'Canal principal com alta qualidade, outros otimizados';
                } else if (altConfig.strategy === 'mixed-max-time' || altConfig.strategy === 'max-time') {
                    badgeIcon = '⏱️';
                    badgeClass = 'bg-orange-100 text-orange-700 border-orange-300';
                    description = 'Configuração otimizada para máximo tempo de gravação';
                } else if (altConfig.strategy === 'high-all') {
                    badgeIcon = '💎';
                    badgeClass = 'bg-indigo-100 text-indigo-700 border-indigo-300';
                    description = 'Máxima qualidade em todos os canais';
                } else if (altConfig.strategy === 'balanced-medium') {
                    badgeIcon = '⚖️';
                    badgeClass = 'bg-teal-100 text-teal-700 border-teal-300';
                    description = 'Equilíbrio entre qualidade e tempo de gravação';
                } else {
                    badgeIcon = '📹';
                    badgeClass = 'bg-gray-100 text-gray-700 border-gray-300';
                    description = 'Configuração alternativa';
                }
            } else {
                // Fallback to old logic
                if (timeDiffPercent < 5) {
                    badge = 'Tempo Exato';
                    badgeIcon = '🎯';
                    badgeClass = 'bg-purple-100 text-purple-700 border-purple-300';
                    description = 'Atinge o tempo desejado com precisão';
                } else if (altConfig.multiplier < 1) {
                    badge = 'Econômico';
                    badgeIcon = '💾';
                    badgeClass = 'bg-green-100 text-green-700 border-green-300';
                    description = 'Menor consumo de espaço, maior tempo de gravação';
                } else {
                    badge = 'Alta Qualidade';
                    badgeIcon = '⭐';
                    badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                    description = 'Melhor qualidade de imagem';
                }
            }
        }
        
        // Build channel summary with icons and better formatting
        let channelsHTML = '';
        altConfig.configs.forEach((config, index) => {
            // Skip null configs (inactive channels)
            if (config === null) return;
            
            const channelName = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index].name 
                : 'Canal ' + (index + 1);
            
            // Get actual values (handle JC400 presets)
            let resolution, fps, bitrate;
            if (currentModel.name === 'JC400' && config.preset !== undefined) {
                const channelInfo = currentModel.channels[index];
                const presetData = channelInfo.presets[config.preset];
                resolution = presetData.resolution;
                fps = presetData.fps;
                bitrate = presetData.bitrate;
            } else {
                resolution = config.resolution;
                fps = config.fps;
                bitrate = config.bitrate;
            }
            
            // Determine quality level for visual indication
            let qualityColor = '#6B7280'; // gray
            if (bitrate >= 6) qualityColor = '#059669'; // green - high
            else if (bitrate >= 3) qualityColor = '#0066CC'; // blue - medium
            else if (bitrate >= 1) qualityColor = '#F59E0B'; // orange - low
            
            channelsHTML += '<div class="flex items-center justify-between p-2 rounded mb-2" style="background-color: #F9FAFB; border-left: 3px solid ' + qualityColor + ';">' +
                '<div class="flex-1">' +
                '<div class="font-semibold text-sm text-gray-800">' +
                '<i class="fas fa-video mr-2" style="color: ' + qualityColor + ';"></i>' +
                channelName +
                '</div>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                '<span class="inline-block mr-3"><i class="fas fa-image mr-1"></i>' + resolution + 'P</span>' +
                '<span class="inline-block mr-3"><i class="fas fa-tachometer-alt mr-1"></i>' + fps + ' fps</span>' +
                '<span class="inline-block"><i class="fas fa-signal mr-1"></i>' + bitrate + ' Mbps</span>' +
                '</div>' +
                '</div>' +
                '</div>';
        });
        
        const timeDiffSign = timeDiff >= 0 ? '+' : '';
        const timeDiffColor = Math.abs(timeDiffPercent) < 10 ? '#059669' : (timeDiff >= 0 ? '#0066CC' : '#EF4444');
        
        altCard.innerHTML = 
            // Header with badge
            '<div class="flex items-center justify-between mb-4 pb-3 border-b-2 border-gray-100">' +
            '<div>' +
            '<h4 class="font-bold text-lg text-gray-800 mb-1">' +
            badgeIcon + ' Opção ' + (altIndex + 1) +
            '</h4>' +
            '<p class="text-xs text-gray-500 italic">' + description + '</p>' +
            '</div>' +
            '<span class="text-xs px-3 py-1.5 rounded-full border-2 font-bold ' + badgeClass + '">' + badge + '</span>' +
            '</div>' +
            
            // Channel configurations
            '<div class="mb-4">' +
            '<h5 class="text-xs font-bold text-gray-600 uppercase tracking-wide mb-2">' +
            '<i class="fas fa-cog mr-1"></i>Configuração dos Canais' +
            '</h5>' +
            channelsHTML +
            '</div>' +
            
            // Statistics grid
            '<div class="grid grid-cols-2 gap-3 mb-4">' +
            
            // Recording time
            '<div class="col-span-2 p-3 rounded-lg" style="background: linear-gradient(135deg, #E6F0FF 0%, #CCE0FF 100%); border: 2px solid #0066CC;">' +
            '<div class="flex items-center justify-between">' +
            '<div>' +
            '<div class="text-xs text-gray-700 font-semibold mb-1">' +
            '<i class="fas fa-clock mr-1" style="color: #0066CC;"></i>Tempo Total' +
            '</div>' +
            '<div class="font-bold text-2xl" style="color: #0052A3;">' +
            results.totalTimeDays.toFixed(1) + ' dias' +
            '</div>' +
            '<div class="text-sm text-gray-700">' + results.totalTimeHours.toFixed(1) + ' horas</div>' +
            '</div>' +
            '<div class="text-center px-3 py-2 bg-white rounded-lg border-2" style="border-color: ' + timeDiffColor + ';">' +
            '<div class="font-bold text-lg" style="color: ' + timeDiffColor + ';">' + timeDiffSign + timeDiffPercent.toFixed(0) + '%</div>' +
            '<div class="text-xs text-gray-600">vs desejado</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // Total bitrate
            '<div class="p-3 rounded-lg bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-200">' +
            '<div class="text-xs text-purple-700 font-semibold mb-1">' +
            '<i class="fas fa-signal mr-1"></i>Bitrate Total' +
            '</div>' +
            '<div class="font-bold text-xl text-purple-800">' + totalBitrate.toFixed(1) + ' Mbps</div>' +
            '</div>' +
            
            // Data consumption
            '<div class="p-3 rounded-lg bg-gradient-to-br from-orange-50 to-orange-100 border-2 border-orange-200">' +
            '<div class="text-xs text-orange-700 font-semibold mb-1">' +
            '<i class="fas fa-database mr-1"></i>Consumo/Hora' +
            '</div>' +
            '<div class="font-bold text-xl text-orange-800">' + (totalMBh / 1000).toFixed(2) + ' GB/h</div>' +
            '</div>' +
            
            '</div>' +
            
            // Action button
            '<button class="w-full text-white py-3 px-4 rounded-lg transition-all text-sm font-bold shadow-md hover:shadow-xl transform hover:scale-105" style="background: linear-gradient(135deg, #0066CC 0%, #0052A3 100%);">' +
            '<i class="fas fa-check-circle mr-2"></i>Usar Esta Configuração' +
            '</button>';
        
        const useBtn = altCard.querySelector('button');
        useBtn.onclick = function() {
            autoGeneratedConfig = altConfig.configs;
            calculateAutoConfig(altConfig.configs);
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        };
        
        recommendedAlternatives.appendChild(altCard);
    });
    
    // Show the section
    recommendedSection.classList.remove('hidden');
}

// Show More Alternatives
function showMoreAlternatives(targetBitrate, desiredHours) {
    const channelConfigDiv = document.getElementById('channelConfig');
    if (!channelConfigDiv) return;
    
    // Clear current content
    channelConfigDiv.innerHTML = '';
    
    // Header with Jimi colors
    const header = document.createElement('div');
    header.className = 'mb-4 p-4 text-white rounded-lg';
    header.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
    header.innerHTML = '<h3 class="text-lg font-bold mb-2">' +
        '<i class="fas fa-layer-group mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Configurações Alternativas' : 'Alternative Configurations') +
        '</h3>' +
        '<p class="text-sm opacity-90">' +
        (currentLang === 'pt-BR' 
            ? 'Outras opções que também atendem sua solicitação de <strong>' + desiredHours.toFixed(1) + ' horas</strong>' 
            : 'Other options that also meet your request of <strong>' + desiredHours.toFixed(1) + ' hours</strong>') +
        '</p>';
    channelConfigDiv.appendChild(header);
    
    // Generate multiple alternative configurations
    const alternatives = generateAlternativeConfigs(targetBitrate);
    
    alternatives.forEach((altConfig, altIndex) => {
        const altCard = document.createElement('div');
        altCard.className = 'mb-4 p-4 bg-white rounded-lg shadow-md border-2 transition-all';
        altCard.style.borderColor = '#0066CC';
        altCard.style.cursor = 'pointer';
        altCard.onmouseenter = function() {
            this.style.borderColor = '#0052A3';
            this.style.boxShadow = '0 4px 12px rgba(0, 102, 204, 0.3)';
        };
        altCard.onmouseleave = function() {
            this.style.borderColor = '#0066CC';
            this.style.boxShadow = '';
        };
        
        const cardSize = parseInt(cardSizeSelect.value);
        const channels = altConfig.configs
            .map((config, index) => {
                // Skip null configs (inactive channels)
                if (config === null) return null;
                
                const channelInfo = currentModel.channels && currentModel.channels[index] 
                    ? currentModel.channels[index] 
                    : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
                
                return {
                    active: true,
                    channelId: channelInfo.id,
                    channelName: channelInfo.name,
                    resolution: config.resolution.toString(),
                    fps: config.fps,
                    bitrate: config.bitrate,
                    codec: 'H.264',
                    codecMultiplier: 1,
                    fixed: config.fixed || false
                };
            })
            .filter(ch => ch !== null); // Remove null entries
        
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        const results = calculator.calculateTotal(cardSize, channels, useDualCard);
        
        // Determine badge based on multiplier
        let badge = '';
        let badgeClass = '';
        if (altConfig.multiplier < 1) {
            badge = currentLang === 'pt-BR' ? '💾 Mais Econômico' : '💾 More Economical';
            badgeClass = 'bg-green-100 text-green-700 border-green-300';
        } else {
            badge = currentLang === 'pt-BR' ? '⭐ Melhor Qualidade' : '⭐ Better Quality';
            badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
        }
        
        let channelsHTML = '';
        altConfig.configs.forEach((config, index) => {
            // Skip null configs (inactive channels)
            if (config === null) return;
            
            const channelName = currentModel.channels && currentModel.channels[index] 
                ? currentModel.channels[index].name 
                : 'Canal ' + (index + 1);
            const isFixed = config.fixed || (currentModel.name === 'JC181' && index === 1);
            
            channelsHTML += '<div class="mb-2 p-2 bg-gray-50 rounded">' +
                '<div class="flex items-center justify-between">' +
                '<strong class="text-sm" style="color: #0066CC;">' + channelName + ':</strong> ' +
                (isFixed ? '<span class="text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded ml-2">' + t('fixed_configuration') + '</span>' : '') +
                '</div>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                config.resolution + 'P @ ' + config.fps + 'fps - ' + config.bitrate + ' Mbps' +
                '</div>' +
                '</div>';
        });
        
        const timeDiff = results.totalTimeHours - desiredHours;
        const timeDiffPercent = ((timeDiff / desiredHours) * 100).toFixed(0);
        
        altCard.innerHTML = '<div class="mb-3">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h4 class="font-bold text-gray-800">' +
            '<i class="fas fa-star mr-2" style="color: #0066CC;"></i>' +
            (currentLang === 'pt-BR' ? 'Alternativa ' : 'Alternative ') + (altIndex + 1) +
            '</h4>' +
            '<span class="text-xs px-2 py-1 rounded border font-semibold ' + badgeClass + '">' + badge + '</span>' +
            '</div>' +
            channelsHTML +
            '</div>' +
            '<div class="mt-3 pt-3 border-t border-gray-200">' +
            '<div class="grid grid-cols-3 gap-2 text-xs mb-2">' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + results.totalTimeDays.toFixed(1) + '</div>' +
            '<div class="text-gray-600">' + t('days') + '</div>' +
            '</div>' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + results.totalTimeHours.toFixed(1) + '</div>' +
            '<div class="text-gray-600">' + t('hours') + '</div>' +
            '</div>' +
            '<div class="text-center p-2 rounded" style="background-color: #E6F0FF;">' +
            '<div class="font-bold text-lg" style="color: #0066CC;">' + (timeDiff >= 0 ? '+' : '') + timeDiffPercent + '%</div>' +
            '<div class="text-gray-600 text-xs">' + (currentLang === 'pt-BR' ? 'Diferença' : 'Difference') + '</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<button class="w-full mt-3 text-white py-2 px-3 rounded transition text-sm font-semibold shadow-md hover:shadow-lg" style="background: linear-gradient(135deg, #0066CC 0%, #0052A3 100%);">' +
            '<i class="fas fa-check-circle mr-2"></i>' +
            (currentLang === 'pt-BR' ? 'Usar Esta Configuração' : 'Use This Configuration') +
            '</button>';
        
        const useBtn = altCard.querySelector('button');
        useBtn.onclick = function() {
            autoGeneratedConfig = altConfig.configs;
            calculateAutoConfig(altConfig.configs);
        };
        useBtn.onmouseenter = function() {
            this.style.background = 'linear-gradient(135deg, #0052A3 0%, #003d7a 100%)';
        };
        useBtn.onmouseleave = function() {
            this.style.background = 'linear-gradient(135deg, #0066CC 0%, #0052A3 100%)';
        };
        
        channelConfigDiv.appendChild(altCard);
    });
    
    // Back button
    const backBtn = document.createElement('button');
    backBtn.className = 'w-full mt-4 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition';
    backBtn.innerHTML = '<i class="fas fa-arrow-left mr-2"></i>' +
        (currentLang === 'pt-BR' ? 'Voltar para Recomendação Principal' : 'Back to Main Recommendation');
    backBtn.onclick = function() {
        const days = parseInt(desiredDaysInput.value) || 0;
        const hours = parseInt(desiredHoursInput.value) || 0;
        const totalHours = (days * 24) + hours;
        generateAutoConfig();
    };
    channelConfigDiv.appendChild(backBtn);
}

// Get Channel Priority Order for Free Mode
// Returns array where index is priority level (0 = highest), value is channel index
function getChannelPriorityOrder() {
    if (currentModel.name === 'JC371') {
        // JC371: CH2 (index 1) -> CH1 (index 0) -> CH3 (index 2)
        return [1, 0, 2];
    } else if (currentModel.name === 'JC450') {
        // JC450: CH3 (index 2) -> CH1 (index 0) -> CH2 (index 1) -> CH4 (index 3) -> CH5 (index 4)
        return [2, 0, 1, 3, 4];
    } else if (currentModel.name === 'JC400') {
        // JC400: IN (index 1) -> OUT (index 0)
        return [1, 0];
    }
    // Default: sequential order
    return Array.from({ length: currentModel.channels?.length || 4 }, (_, i) => i);
}

// Calculate priority score for a configuration in free mode
function calculateFreeModeScore(configSet, timeDifference) {
    const priorityOrder = getChannelPriorityOrder();
    let bitrateScore = 0;
    
    // Weights more balanced - reducing difference between levels
    // This encourages better distribution across all channels
    // 1st: 10, 2nd: 7, 3rd: 5, 4th: 3.5, 5th: 2.5
    // Much closer together to avoid extreme concentration on first channel
    const weights = [10, 7, 5, 3.5, 2.5, 1.5];
    
    priorityOrder.forEach((channelIndex, priorityLevel) => {
        if (configSet.configs[channelIndex] && configSet.configs[channelIndex] !== null) {
            const bitrate = configSet.configs[channelIndex].bitrate || 0;
            const weight = weights[priorityLevel] || 1;
            bitrateScore += bitrate * weight;
        }
    });
    
    // Time score: strongly prefer configs closer to desired time
    // Increased weight on time to prioritize matching the desired duration
    const timeScore = 50000 / (1 + Math.abs(timeDifference));
    
    // Combined score: time is primary, quality hierarchy is secondary influence
    return timeScore + bitrateScore;
}

// Generate All Possible Configurations
function generateAllPossibleConfigs(numChannels) {
    const allConfigs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: Only CH1 is configurable, CH2 is fixed
        const ch1Channel = currentModel.channels[0];
        const ch2Fixed = {
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        };
        
        // Check which channels are active
        const ch1Active = activeChannels.includes(0);
        const ch2Active = activeChannels.includes(1);
        
        if (ch1Channel.resolutions) {
            ch1Channel.resolutions.forEach(res => {
                res.bitrates.forEach(bitrate => {
                    const defaultFps = ch1Channel.fps ? (Array.isArray(ch1Channel.fps) ? ch1Channel.fps[0] : ch1Channel.fps) : 25;
                    
                    const configs = [];
                    
                    // Add CH1 config if active
                    if (ch1Active) {
                        configs.push({
                            resolution: res.value,
                            fps: defaultFps,
                            bitrate: bitrate
                        });
                    } else {
                        configs.push(null); // Placeholder for inactive channel
                    }
                    
                    // Add CH2 config if active
                    if (ch2Active) {
                        configs.push(ch2Fixed);
                    } else {
                        configs.push(null); // Placeholder for inactive channel
                    }
                    
                    allConfigs.push({ configs });
                });
            });
        }
    } else if (currentModel.name === 'JC400') {
        // JC400: Generate combinations of presets
        const outPresets = currentModel.channels[0].presets || [];
        const inPresets = currentModel.channels[1].presets || [];
        
        // Check which channels are active
        const outActive = activeChannels.includes(0);
        const inActive = activeChannels.includes(1);
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel);
        
        console.log('🎯 JC400 Priority Config:');
        console.log('   selectedPriorityChannel:', selectedPriorityChannel);
        console.log('   priorityChannelIndex:', priorityChannelIndex);
        console.log('   Active channels:', activeChannels);
        
        if (priorityChannelIndex === -1) {
            // User wants all channels equal - only generate combinations where bitrates are similar
            // Allow small differences (within 20%) for flexibility
            outPresets.forEach((outPreset, outIndex) => {
                inPresets.forEach((inPreset, inIndex) => {
                    // Calculate bitrate difference percentage
                    const bitrateDiff = Math.abs(outPreset.bitrate - inPreset.bitrate);
                    const avgBitrate = (outPreset.bitrate + inPreset.bitrate) / 2;
                    const diffPercent = (bitrateDiff / avgBitrate) * 100;
                    
                    // Only include if bitrates are within 20% of each other (approximately equal)
                    if (diffPercent <= 20) {
                        const configs = [];
                        
                        // Add OUT preset if active (include full preset data)
                        if (outActive) {
                            configs.push({ 
                                preset: outIndex,
                                resolution: outPreset.resolution,
                                fps: outPreset.fps,
                                bitrate: outPreset.bitrate
                            });
                        } else {
                            configs.push(null);
                        }
                        
                        // Add IN preset if active (include full preset data)
                        if (inActive) {
                            configs.push({ 
                                preset: inIndex,
                                resolution: inPreset.resolution,
                                fps: inPreset.fps,
                                bitrate: inPreset.bitrate
                            });
                        } else {
                            configs.push(null);
                        }
                        
                        allConfigs.push({ configs });
                    }
                });
            });
        } else {
            // User wants a specific channel prioritized
            if (priorityChannelIndex === 0) {
                // Prioritize OUT camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if OUT has same or better quality than IN
                        if (outPreset.bitrate >= inPreset.bitrate) {
                            const configs = [];
                            
                            if (outActive) {
                                configs.push({ 
                                    preset: outIndex,
                                    resolution: outPreset.resolution,
                                    fps: outPreset.fps,
                                    bitrate: outPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            if (inActive) {
                                configs.push({ 
                                    preset: inIndex,
                                    resolution: inPreset.resolution,
                                    fps: inPreset.fps,
                                    bitrate: inPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            allConfigs.push({ configs });
                        }
                    });
                });
            } else {
                // Prioritize IN camera
                outPresets.forEach((outPreset, outIndex) => {
                    inPresets.forEach((inPreset, inIndex) => {
                        // Only add if IN has same or better quality than OUT
                        if (inPreset.bitrate >= outPreset.bitrate) {
                            const configs = [];
                            
                            if (outActive) {
                                configs.push({ 
                                    preset: outIndex,
                                    resolution: outPreset.resolution,
                                    fps: outPreset.fps,
                                    bitrate: outPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            if (inActive) {
                                configs.push({ 
                                    preset: inIndex,
                                    resolution: inPreset.resolution,
                                    fps: inPreset.fps,
                                    bitrate: inPreset.bitrate
                                });
                            } else {
                                configs.push(null);
                            }
                            
                            allConfigs.push({ configs });
                        }
                    });
                });
            }
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // For simplicity, generate a subset of common configurations
        // instead of ALL combinations (which would be too many)
        
        // Get all available bitrates from model resolutions
        const allBitrates = currentModel.resolutions 
            ? currentModel.resolutions.flatMap(res => res.bitrates)
            : [];
        
        // Get unique bitrates and sort
        const uniqueBitrates = [...new Set(allBitrates)].sort((a, b) => a - b);
        
        const numChannels = currentModel.channels ? currentModel.channels.length : 2;
        
        // Check if user wants a specific channel prioritized
        const priorityChannelIndex = selectedPriorityChannel === 'free' ? -2 : (selectedPriorityChannel === 'equal' ? -1 : parseInt(selectedPriorityChannel));
        
        console.log('🎯 JC371/JC450 Priority Config:');
        console.log('   selectedPriorityChannel:', selectedPriorityChannel);
        console.log('   priorityChannelIndex:', priorityChannelIndex);
        console.log('   Active channels:', activeChannels);
        
        if (priorityChannelIndex === -2) {
            // FREE MODE: Generate all possible bitrate combinations
            console.log('🎨 FREE MODE: Generating all bitrate combinations...');
            
            // Helper function to generate all combinations recursively
            function generateCombinations(channelIndex, currentCombination) {
                if (channelIndex >= numChannels) {
                    // All channels assigned, add this configuration
                    const channelConfigs = [];
                    let hasActiveChannel = false;
                    
                    for (let i = 0; i < numChannels; i++) {
                        if (activeChannels.includes(i)) {
                            const bitrate = currentCombination[i];
                            const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                            if (config) {
                                channelConfigs.push(config);
                                hasActiveChannel = true;
                            } else {
                                channelConfigs.push(null);
                            }
                        } else {
                            channelConfigs.push(null); // Inactive channel
                        }
                    }
                    
                    if (hasActiveChannel) {
                        allConfigs.push({
                            configs: channelConfigs
                        });
                    }
                    return;
                }
                
                // Try each bitrate for this channel
                uniqueBitrates.forEach(bitrate => {
                    currentCombination[channelIndex] = bitrate;
                    generateCombinations(channelIndex + 1, [...currentCombination]);
                });
            }
            
            // Start recursive generation
            generateCombinations(0, []);
            console.log(`   Generated ${allConfigs.length} free configurations`);
            
        } else if (priorityChannelIndex === -1) {
            // User wants all channels with equal quality
            uniqueBitrates.forEach(bitrate => {
                const channelConfigs = [];
                for (let i = 0; i < numChannels; i++) {
                    // Check if this channel is active
                    if (activeChannels.includes(i)) {
                        const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                        if (config) {
                            channelConfigs.push(config);
                        } else {
                            channelConfigs.push(null);
                        }
                    } else {
                        channelConfigs.push(null); // Inactive channel
                    }
                }
                
                // At least one channel must be active
                if (channelConfigs.some(c => c !== null)) {
                    allConfigs.push({
                        configs: channelConfigs
                    });
                }
            });
        } else {
            // User wants a specific channel prioritized
            uniqueBitrates.forEach(bitratePriority => {
                uniqueBitrates.forEach(bitrateOthers => {
                    if (bitratePriority >= bitrateOthers) { // Priority channel has same or higher bitrate
                        const channelConfigs = [];
                        
                        for (let i = 0; i < numChannels; i++) {
                            // Check if this channel is active
                            if (activeChannels.includes(i)) {
                                const bitrate = (i === priorityChannelIndex) ? bitratePriority : bitrateOthers;
                                const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
                                if (config) {
                                    channelConfigs.push(config);
                                } else {
                                    channelConfigs.push(null);
                                }
                            } else {
                                channelConfigs.push(null); // Inactive channel
                            }
                        }
                        
                        // At least one channel must be active
                        if (channelConfigs.some(c => c !== null)) {
                            allConfigs.push({
                                configs: channelConfigs
                            });
                        }
                    }
                });
            });
        }
    }
    
    return allConfigs;
}

// Find Best Config for Specific Bitrate (helper function)
function findBestConfigForBitrate(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                if (bitrate === targetBitrate) {
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    // If exact match not found, find closest
    if (!bestConfig && channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                if (difference < minDifference) {
                    minDifference = difference;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig;
}

// Find Best Resolution for Specific Bitrate (for models with resolutions at model level)
function findBestResolutionForBitrate(targetBitrate, resolutions) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    if (!resolutions) return null;
    
    // First try exact match
    resolutions.forEach(res => {
        if (res.bitrates && res.bitrates.includes(targetBitrate)) {
            bestConfig = {
                resolution: res.value,
                fps: 25, // default
                bitrate: targetBitrate
            };
        }
    });
    
    // If exact match not found, find closest
    if (!bestConfig) {
        resolutions.forEach(res => {
            if (res.bitrates) {
                res.bitrates.forEach(bitrate => {
                    const difference = Math.abs(bitrate - targetBitrate);
                    if (difference < minDifference) {
                        minDifference = difference;
                        bestConfig = {
                            resolution: res.value,
                            fps: 25,
                            bitrate: bitrate
                        };
                    }
                });
            }
        });
    }
    
    return bestConfig;
}

// Generate Alternative Configurations
function generateAlternativeConfigs(targetBitrate) {
    const alternatives = [];
    const numChannels = currentModel.channels ? currentModel.channels.length : 1;
    const cardSize = parseInt(cardSizeSelect.value);
    const useDualCard = currentModel.dualCard && !useOneCardOnly;
    
    // Strategy 1: Balanced quality (all channels similar)
    const balancedVariations = [0.6, 0.8, 1.2, 1.4]; // -40%, -20%, +20%, +40%
    balancedVariations.forEach(multiplier => {
        const adjustedBitrate = targetBitrate * multiplier;
        const configs = generateConfigForModel(adjustedBitrate, numChannels);
        if (configs && configs.length > 0) {
            alternatives.push({ 
                configs, 
                multiplier,
                strategy: 'balanced',
                name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
            });
        }
    });
    
    // Strategy 2: For multi-channel models, create mixed quality options
    if (numChannels > 1 && (currentModel.name === 'JC371' || currentModel.name === 'JC450')) {
        // High priority on CH1, lower on others
        const mixedConfigs1 = generateMixedQualityConfig(targetBitrate * 1.5, targetBitrate * 0.7, 0);
        if (mixedConfigs1) {
            alternatives.push({
                configs: mixedConfigs1,
                multiplier: 1.0,
                strategy: 'mixed-high-ch1',
                name: 'CH1 Priorizado'
            });
        }
        
        // Medium CH1, very low others (maximum recording time)
        const mixedConfigs2 = generateMixedQualityConfig(targetBitrate * 0.8, targetBitrate * 0.4, 0);
        if (mixedConfigs2) {
            alternatives.push({
                configs: mixedConfigs2,
                multiplier: 0.6,
                strategy: 'mixed-max-time',
                name: 'Máximo Tempo'
            });
        }
        
        // High quality all main channels
        const highConfigs = generateMixedQualityConfig(targetBitrate * 1.3, targetBitrate * 1.3, -1);
        if (highConfigs) {
            alternatives.push({
                configs: highConfigs,
                multiplier: 1.3,
                strategy: 'high-all',
                name: 'Máxima Qualidade'
            });
        }
    }
    
    // Strategy 3: For JC400, create smart preset combinations
    if (currentModel.name === 'JC400') {
        // OUT high, IN medium
        alternatives.push({
            configs: [{ preset: 0 }, { preset: 1 }], // 1080P@8M, 720P@3M
            multiplier: 1.1,
            strategy: 'out-priority',
            name: 'OUT Priorizado'
        });
        
        // Both medium
        alternatives.push({
            configs: [{ preset: 1 }, { preset: 1 }], // 720P@4M, 720P@3M
            multiplier: 0.7,
            strategy: 'balanced-medium',
            name: 'Qualidade Média'
        });
        
        // Maximum time
        alternatives.push({
            configs: [{ preset: 3 }, { preset: 3 }], // 360P@0.5M, 360P@0.5M
            multiplier: 0.1,
            strategy: 'max-time',
            name: 'Máximo Tempo'
        });
    }
    
    // Strategy 4: For JC181, vary CH1 quality
    if (currentModel.name === 'JC181') {
        const ch1Variations = [0.5, 0.75, 1.25, 1.5];
        ch1Variations.forEach(multiplier => {
            const ch1Config = findBestConfig(targetBitrate * multiplier, currentModel.channels[0]);
            if (ch1Config) {
                alternatives.push({
                    configs: [
                        ch1Config,
                        { resolution: '360', fps: 25, bitrate: 0.5, fixed: true }
                    ],
                    multiplier,
                    strategy: 'ch1-variation',
                    name: multiplier < 1 ? 'Econômico' : 'Alta Qualidade'
                });
            }
        });
    }
    
    // Remove alternatives that result in the same configuration as the main one
    // and sort by how close they are to the desired time
    return alternatives.filter((alt, index, self) => {
        // Remove duplicates based on actual bitrate
        const altKey = alt.configs.map(c => 
            c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
        ).join('|');
        
        return index === self.findIndex(t => {
            const tKey = t.configs.map(c => 
                c.preset !== undefined ? `p${c.preset}` : `${c.resolution}_${c.bitrate}`
            ).join('|');
            return tKey === altKey;
        });
    });
}

// Helper function to generate mixed quality configurations
function generateMixedQualityConfig(priorityBitrate, othersBitrate, priorityChannelIndex) {
    if (!currentModel.resolutions) return null;
    
    const numChannels = currentModel.channels ? currentModel.channels.length : 2;
    const configs = [];
    
    for (let i = 0; i < numChannels; i++) {
        const bitrate = (priorityChannelIndex === -1 || i === priorityChannelIndex) 
            ? priorityBitrate 
            : othersBitrate;
        const config = findBestResolutionForBitrate(bitrate, currentModel.resolutions);
        if (config) {
            configs.push(config);
        }
    }
    
    return configs.length === numChannels ? configs : null;
}

// Generate Configuration For Model
function generateConfigForModel(targetBitrate, numChannels) {
    const configs = [];
    
    if (currentModel.name === 'JC181') {
        // JC181: CH1 configurable, CH2 fixed
        configs.push(findBestConfig(targetBitrate, currentModel.channels[0]));
        configs.push({
            resolution: '360',
            fps: 25,
            bitrate: 0.5,
            fixed: true
        });
    } else if (currentModel.name === 'JC400') {
        // JC400: OUT and IN cameras with presets
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            const preset = findBestPresetJC400(targetBitrate, channel);
            configs.push(preset);
        }
    } else if (currentModel.name === 'JC371' || currentModel.name === 'JC450') {
        // JC371 and JC450: Flexible configuration
        for (let i = 0; i < numChannels; i++) {
            const channel = currentModel.channels[i];
            configs.push(findBestConfig(targetBitrate, channel));
        }
    }
    
    return configs;
}

// Find Best Config for Channel
function findBestConfig(targetBitrate, channel) {
    let bestConfig = null;
    let minDifference = Infinity;
    
    // Get default FPS from channel
    const defaultFps = channel.fps ? (Array.isArray(channel.fps) ? channel.fps[0] : channel.fps) : 25;
    
    if (channel.resolutions) {
        channel.resolutions.forEach(res => {
            res.bitrates.forEach(bitrate => {
                const difference = Math.abs(bitrate - targetBitrate);
                
                // Prefer configurations that are closer to target
                // If difference is similar, prefer slightly lower bitrate (longer recording time)
                // to avoid exceeding storage too quickly
                let penalty = 0;
                if (bitrate < targetBitrate) {
                    // Lower bitrate = longer recording time (good)
                    penalty = difference * 0.8; // 20% preference for lower bitrate
                } else {
                    // Higher bitrate = shorter recording time (less preferred)
                    penalty = difference * 1.2; // 20% penalty for higher bitrate
                }
                
                if (penalty < minDifference) {
                    minDifference = penalty;
                    bestConfig = {
                        resolution: res.value,
                        fps: defaultFps,
                        bitrate: bitrate
                    };
                }
            });
        });
    }
    
    return bestConfig || {
        resolution: '720',
        fps: defaultFps,
        bitrate: 2
    };
}

// Find Best Preset for JC400
function findBestPresetJC400(targetBitrate, channel) {
    if (!channel.presets) {
        return { preset: 0 };
    }
    
    let bestPreset = 0;
    let minDifference = Infinity;
    
    channel.presets.forEach((preset, index) => {
        const difference = Math.abs(preset.bitrate - targetBitrate);
        
        // Apply same logic: prefer slightly lower bitrate for longer recording
        let penalty = 0;
        if (preset.bitrate < targetBitrate) {
            penalty = difference * 0.8; // Prefer lower bitrate
        } else {
            penalty = difference * 1.2; // Penalize higher bitrate
        }
        
        if (penalty < minDifference) {
            minDifference = penalty;
            bestPreset = index;
        }
    });
    
    return { preset: bestPreset };
}

// Apply Auto Config to UI
function applyAutoConfigToUI(configs) {
    if (!configs || configs.length === 0) return;
    
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, index) => {
        if (index >= configs.length) return;
        
        const config = configs[index];
        
        if (config.fixed) {
            // CH2 of JC181 is fixed, skip
            return;
        }
        
        if (currentModel.name === 'JC400') {
            // Set preset
            const presetSelect = div.querySelector('.channel-preset');
            if (presetSelect && config.preset !== undefined) {
                presetSelect.value = config.preset;
            }
        } else {
            // Set resolution, fps, and bitrate
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            
            if (resolutionSelect && config.resolution) {
                resolutionSelect.value = config.resolution;
            }
            
            if (fpsSelect && config.fps) {
                fpsSelect.value = config.fps;
            }
            
            if (bitrateSelect && config.bitrate) {
                // For JC181, need to update bitrates first
                if (currentModel.name === 'JC181' && index === 0) {
                    updateJC181Bitrates(0);
                }
                bitrateSelect.value = config.bitrate;
            }
        }
    });
    
    // Add visual indicator
    channelDivs.forEach(div => {
        div.style.borderColor = '#10b981';
        div.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.2)';
        setTimeout(() => {
            div.style.borderColor = '';
            div.style.boxShadow = '';
        }, 2000);
    });
}

// Show Notification
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 z-50 px-6 py-4 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full';
    
    if (type === 'success') {
        notification.className += ' bg-green-500 text-white';
        notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>' + message;
    } else if (type === 'error') {
        notification.className += ' bg-red-500 text-white';
        notification.innerHTML = '<i class="fas fa-exclamation-circle mr-2"></i>' + message;
    } else {
        notification.className += ' bg-blue-500 text-white';
        notification.innerHTML = '<i class="fas fa-info-circle mr-2"></i>' + message;
    }
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(120%)';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 4000);
}

// Calculate Recording
function calculateRecording() {
    if (!currentModel) return;
    
    // Clear auto-config alternatives when in manual mode
    configAlternatives = null;
    
    const cardSize = parseInt(cardSizeSelect.value);
    const channels = collectChannelData();
    
    if (channels.length === 0) {
        alert(currentLang === 'pt-BR' 
            ? 'Por favor, configure pelo menos um canal.' 
            : 'Please configure at least one channel.');
        return;
    }
    
    // Special handling for JC450 dual card
    let results;
    if (currentModel.name === 'JC450') {
        // Use JC450-specific dual card calculation
        results = calculator.calculateJC450DualCard(cardSize, channels, useOneCardOnly);
    } else {
        // Use regular calculation for other models
        const useDualCard = currentModel.dualCard && !useOneCardOnly;
        results = calculator.calculateTotal(cardSize, channels, useDualCard);
    }
    
    currentConfig = { modelName: currentModel.name, results, channels };
    
    // Display results
    displayResults(results);
    
    // Show results section
    resultsSection.classList.remove('hidden');
    resultsSection.scrollIntoView({ behavior: 'smooth' });
    
    saveState();
}

// Calculate Reverse Mode
// Collect Channel Data
function collectChannelData() {
    const channels = [];
    const channelDivs = channelConfigDiv.querySelectorAll('.channel-config-card');
    
    channelDivs.forEach((div, index) => {
        // Skip inactive channels
        if (!activeChannels.includes(index)) {
            return;
        }
        
        const channelInfo = currentModel.channels 
            ? currentModel.channels[index] 
            : { id: `CH${index + 1}`, name: `Channel ${index + 1}` };
        
        // JC181 - CH2 is fixed
        if (currentModel.name === 'JC181' && index === 1) {
            channels.push({
                active: true,
                channelId: 'CH2',
                channelName: 'CH2 - Internal Camera',
                resolution: '360',
                fps: 25,
                bitrate: 0.5,
                codec: 'H.264',
                codecMultiplier: 1,
                fixed: true
            });
            return;
        }
        
        if (currentModel.name === 'JC400') {
            const presetSelect = div.querySelector('.channel-preset');
            const selectedOption = presetSelect.options[presetSelect.selectedIndex];
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                preset: presetSelect.value,
                resolution: selectedOption.dataset.resolution,
                fps: parseInt(selectedOption.dataset.fps),
                bitrate: parseFloat(selectedOption.dataset.bitrate),
                codec: 'H.264',
                codecMultiplier: 1
            });
        } else {
            const resolutionSelect = div.querySelector('.channel-resolution');
            const fpsSelect = div.querySelector('.channel-fps');
            const bitrateSelect = div.querySelector('.channel-bitrate');
            const codecSelect = div.querySelector('.channel-codec');
            
            // Skip if elements not found (fixed channel)
            if (!resolutionSelect || !fpsSelect || !bitrateSelect) {
                return;
            }
            
            // Bitrate is already in Mbps from models.js
            let bitrate = parseFloat(bitrateSelect.value);
            
            let codecMultiplier = 1;
            let codecName = 'H.264';
            if (codecSelect) {
                const selectedCodec = codecSelect.options[codecSelect.selectedIndex];
                codecMultiplier = parseFloat(selectedCodec.dataset.multiplier);
                codecName = selectedCodec.textContent;
            }
            
            channels.push({
                active: true,
                channelId: channelInfo.id,
                channelName: channelInfo.name,
                resolution: resolutionSelect.value,
                fps: parseInt(fpsSelect.value),
                bitrate: bitrate,
                codec: codecName,
                codecMultiplier: codecMultiplier
            });
        }
    });
    
    return channels;
}

// Display Results
function displayResults(results) {
    // Update main time display - showing only days and hours
    document.getElementById('totalTimeDays').textContent = results.totalTimeDays.toFixed(1);
    document.getElementById('totalTimeHours').textContent = results.totalTimeHours.toFixed(1);
    
    // Create configuration summary
    const configSummaryDiv = document.getElementById('configSummary');
    configSummaryDiv.innerHTML = '';
    
    // Check if we're in auto mode and show comparison
    const isAutoMode = autoModeBtn && autoModeBtn.classList.contains('active');
    if (isAutoMode && desiredDaysInput && desiredHoursInput) {
        const desiredDays = parseInt(desiredDaysInput.value) || 0;
        const desiredHours = parseInt(desiredHoursInput.value) || 0;
        const totalDesiredHours = (desiredDays * 24) + desiredHours;
        const achievedHours = results.totalTimeHours;
        const difference = achievedHours - totalDesiredHours;
        const percentDiff = ((achievedHours / totalDesiredHours) - 1) * 100;
        
        if (totalDesiredHours > 0) {
            const comparisonBox = document.createElement('div');
            comparisonBox.className = 'mb-4 p-4 rounded-lg border-2 ' + 
                (Math.abs(percentDiff) <= 5 ? 'bg-green-50 border-green-300' : 'bg-blue-50 border-blue-300');
            
            comparisonBox.innerHTML = '<div class="flex items-start">' +
                '<i class="fas fa-chart-line text-2xl mr-3 ' + 
                (Math.abs(percentDiff) <= 5 ? 'text-green-600' : 'text-blue-600') + '"></i>' +
                '<div class="flex-1">' +
                '<h4 class="font-bold text-gray-800 mb-2">' +
                '<i class="fas fa-bullseye mr-2"></i>' +
                (currentLang === 'pt-BR' ? 'Comparação: Tempo Desejado vs Tempo Real Alcançado' : 'Comparison: Desired Time vs Actual Time Achieved') +
                '</h4>' +
                '<div class="grid grid-cols-2 gap-3 text-sm">' +
                '<div class="p-2 bg-white rounded border border-gray-200">' +
                '<div class="text-gray-600 text-xs mb-1">' + 
                (currentLang === 'pt-BR' ? '🎯 Tempo Solicitado:' : '🎯 Requested Time:') + 
                '</div>' +
                '<div class="font-bold text-gray-800">' + 
                totalDesiredHours.toFixed(1) + ' ' + t('hours') + 
                ' <span class="text-xs text-gray-500">(' + desiredDays + 'd ' + (desiredHours) + 'h)</span>' +
                '</div>' +
                '</div>' +
                '<div class="p-2 bg-white rounded border border-gray-200">' +
                '<div class="text-gray-600 text-xs mb-1">' + 
                (currentLang === 'pt-BR' ? '✅ Tempo Alcançado:' : '✅ Time Achieved:') + 
                '</div>' +
                '<div class="font-bold text-gray-800">' + 
                achievedHours.toFixed(1) + ' ' + t('hours') + 
                ' <span class="text-xs text-gray-500">(' + results.totalTimeDays.toFixed(1) + 'd)</span>' +
                '</div>' +
                '</div>' +
                '</div>' +
                '<div class="mt-3 p-2 bg-white rounded text-sm">' +
                '<strong>' + (currentLang === 'pt-BR' ? 'Diferença:' : 'Difference:') + '</strong> ' +
                '<span class="' + (difference >= 0 ? 'text-green-700' : 'text-red-700') + ' font-bold">' +
                (difference >= 0 ? '+' : '') + difference.toFixed(1) + ' ' + t('hours') +
                ' (' + (percentDiff >= 0 ? '+' : '') + percentDiff.toFixed(1) + '%)' +
                '</span>' +
                '<div class="text-xs text-gray-600 mt-1">' +
                '<i class="fas fa-info-circle mr-1"></i>' +
                (currentLang === 'pt-BR' 
                    ? 'Variação devido às configurações discretas disponíveis (resoluções, fps e bitrates fixos).' 
                    : 'Variation due to discrete configurations available (fixed resolutions, fps and bitrates).') +
                '</div>' +
                '</div>' +
                '</div>' +
                '</div>';
            
            configSummaryDiv.appendChild(comparisonBox);
            
            // Check if desired time cannot be achieved even with minimum settings
            if (difference < 0 && Math.abs(difference) > totalDesiredHours * 0.1) {
                // Time achieved is more than 10% below desired
                const unachievableWarning = document.createElement('div');
                unachievableWarning.className = 'mb-4 p-5 rounded-lg border-2 bg-red-50 border-red-400';
                
                // Calculate what size would be needed
                const currentCardSize = parseInt(cardSizeSelect?.value || 64);
                const neededCardSize = Math.ceil((totalDesiredHours / achievedHours) * currentCardSize);
                const nextAvailableSize = [32, 64, 128, 256, 512, 1024].find(size => size >= neededCardSize) || neededCardSize;
                
                // Calculate how many channels could be disabled
                const activeChannelCount = currentConfig?.channels?.filter(ch => ch.active).length || 3;
                const possibleWithLessChannels = activeChannelCount > 1 
                    ? Math.ceil(achievedHours * activeChannelCount / (activeChannelCount - 1))
                    : achievedHours;
                
                unachievableWarning.innerHTML = 
                    '<div class="flex items-start">' +
                    '<i class="fas fa-exclamation-triangle text-red-600 text-3xl mr-4"></i>' +
                    '<div class="flex-1">' +
                    '<h4 class="font-bold text-red-800 text-lg mb-3">' +
                    '<i class="fas fa-times-circle mr-2"></i>' +
                    (currentLang === 'pt-BR' 
                        ? 'Tempo Desejado Não Pode Ser Alcançado' 
                        : 'Desired Time Cannot Be Achieved') +
                    '</h4>' +
                    
                    '<p class="text-gray-700 mb-4">' +
                    (currentLang === 'pt-BR'
                        ? `Mesmo com as configurações mínimas (menor resolução e bitrate), o cartão de <strong>${currentCardSize}GB</strong> consegue gravar apenas <strong>${achievedHours.toFixed(1)}h</strong>, que está <strong>${Math.abs(difference).toFixed(1)}h abaixo</strong> das <strong>${totalDesiredHours}h</strong> solicitadas.`
                        : `Even with minimum settings (lowest resolution and bitrate), the <strong>${currentCardSize}GB</strong> card can only record <strong>${achievedHours.toFixed(1)}h</strong>, which is <strong>${Math.abs(difference).toFixed(1)}h below</strong> the requested <strong>${totalDesiredHours}h</strong>.`) +
                    '</p>' +
                    
                    '<div class="bg-white rounded-lg p-4 border-2 border-red-200 mb-4">' +
                    '<h5 class="font-bold text-gray-800 mb-3">' +
                    '<i class="fas fa-lightbulb text-yellow-500 mr-2"></i>' +
                    (currentLang === 'pt-BR' ? 'Soluções Recomendadas:' : 'Recommended Solutions:') +
                    '</h5>' +
                    
                    '<div class="space-y-3">' +
                    // Option 1: Larger card
                    '<div class="flex items-start p-3 bg-green-50 rounded-lg border border-green-300">' +
                    '<div class="flex-shrink-0 w-8 h-8 bg-green-600 text-white rounded-full flex items-center justify-center font-bold mr-3">1</div>' +
                    '<div class="flex-1">' +
                    '<h6 class="font-bold text-green-800 mb-1">' +
                    '<i class="fas fa-sd-card mr-2"></i>' +
                    (currentLang === 'pt-BR' ? 'Usar Cartão SD Maior' : 'Use Larger SD Card') +
                    '</h6>' +
                    '<p class="text-sm text-gray-700 mb-2">' +
                    (currentLang === 'pt-BR'
                        ? `Para alcançar ${totalDesiredHours}h, você precisaria de um cartão de pelo menos <strong>${nextAvailableSize}GB</strong>.`
                        : `To achieve ${totalDesiredHours}h, you would need a card of at least <strong>${nextAvailableSize}GB</strong>.`) +
                    '</p>' +
                    '<p class="text-xs text-gray-600">' +
                    '<i class="fas fa-info-circle mr-1"></i>' +
                    (currentLang === 'pt-BR'
                        ? 'Recomendamos cartões classe 10 ou superior para gravação de vídeo contínua.'
                        : 'We recommend class 10 or higher cards for continuous video recording.') +
                    '</p>' +
                    '</div>' +
                    '</div>' +
                    
                    // Option 2: Disable channels (if applicable)
                    (activeChannelCount > 1 ? 
                        '<div class="flex items-start p-3 bg-blue-50 rounded-lg border border-blue-300">' +
                        '<div class="flex-shrink-0 w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold mr-3">2</div>' +
                        '<div class="flex-1">' +
                        '<h6 class="font-bold text-blue-800 mb-1">' +
                        '<i class="fas fa-video-slash mr-2"></i>' +
                        (currentLang === 'pt-BR' ? 'Desabilitar Câmeras Menos Importantes' : 'Disable Less Important Cameras') +
                        '</h6>' +
                        '<p class="text-sm text-gray-700 mb-2">' +
                        (currentLang === 'pt-BR'
                            ? `Gravando com ${activeChannelCount - 1} câmera(s) ao invés de ${activeChannelCount}, você poderia alcançar aproximadamente <strong>${possibleWithLessChannels.toFixed(1)}h</strong>.`
                            : `Recording with ${activeChannelCount - 1} camera(s) instead of ${activeChannelCount}, you could achieve approximately <strong>${possibleWithLessChannels.toFixed(1)}h</strong>.`) +
                        '</p>' +
                        '<p class="text-xs text-gray-600">' +
                        '<i class="fas fa-info-circle mr-1"></i>' +
                        (currentLang === 'pt-BR'
                            ? 'Avalie quais câmeras são realmente necessárias para sua aplicação.'
                            : 'Evaluate which cameras are truly necessary for your application.') +
                        '</p>' +
                        '</div>' +
                        '</div>'
                        : '') +
                    
                    // Option 3: Reduce desired time
                    '<div class="flex items-start p-3 bg-amber-50 rounded-lg border border-amber-300">' +
                    '<div class="flex-shrink-0 w-8 h-8 bg-amber-600 text-white rounded-full flex items-center justify-center font-bold mr-3">' + (activeChannelCount > 1 ? '3' : '2') + '</div>' +
                    '<div class="flex-1">' +
                    '<h6 class="font-bold text-amber-800 mb-1">' +
                    '<i class="fas fa-clock mr-2"></i>' +
                    (currentLang === 'pt-BR' ? 'Ajustar Tempo de Gravação' : 'Adjust Recording Time') +
                    '</h6>' +
                    '<p class="text-sm text-gray-700 mb-2">' +
                    (currentLang === 'pt-BR'
                        ? `Com o cartão atual, o máximo que você pode gravar é <strong>${achievedHours.toFixed(1)}h</strong> (aproximadamente ${results.totalTimeDays.toFixed(1)} dias).`
                        : `With the current card, the maximum you can record is <strong>${achievedHours.toFixed(1)}h</strong> (approximately ${results.totalTimeDays.toFixed(1)} days).`) +
                    '</p>' +
                    '<p class="text-xs text-gray-600">' +
                    '<i class="fas fa-info-circle mr-1"></i>' +
                    (currentLang === 'pt-BR'
                        ? 'Esta configuração já utiliza a menor qualidade possível.'
                        : 'This configuration already uses the lowest quality possible.') +
                    '</p>' +
                    '</div>' +
                    '</div>' +
                    
                    '</div>' +
                    '</div>' +
                    
                    '</div>' +
                    '</div>';
                
                configSummaryDiv.appendChild(unachievableWarning);
            }
            
            // Show alternative configurations if available
            if (currentConfig && (currentConfig.alternativeHigher || currentConfig.alternativeLower)) {
                const alternativesBox = document.createElement('div');
                alternativesBox.className = 'mt-3 p-4 bg-amber-50 rounded-lg border-2 border-amber-300';
                
                let alternativesHTML = '<div class="flex items-start">' +
                    '<i class="fas fa-layer-group text-amber-600 text-2xl mr-3"></i>' +
                    '<div class="flex-1">' +
                    '<h4 class="font-bold text-gray-800 mb-3">' +
                    '<i class="fas fa-exchange-alt mr-2"></i>' +
                    (currentLang === 'pt-BR' ? 'Configurações Alternativas' : 'Alternative Configurations') +
                    '</h4>';
                
                // Show reason if time difference is significant
                const timeDiffPercent = Math.abs((achievedHours / totalDesiredHours - 1) * 100);
                if (timeDiffPercent > 10) {
                    const reason = achievedHours < totalDesiredHours
                        ? (currentLang === 'pt-BR' 
                            ? '⚠️ <strong>Não foi possível atingir o tempo exato</strong> devido às limitações de resolução, fps e bitrate disponíveis no dispositivo.'
                            : '⚠️ <strong>Could not achieve exact time</strong> due to device resolution, fps and bitrate limitations.')
                        : (currentLang === 'pt-BR'
                            ? '✅ <strong>Tempo excedido</strong> - esta é a configuração mais próxima sem reduzir qualidade excessivamente.'
                            : '✅ <strong>Time exceeded</strong> - this is the closest configuration without reducing quality excessively.');
                    
                    alternativesHTML += '<div class="mb-3 p-2 bg-white rounded text-sm text-gray-700">' + reason + '</div>';
                }
                
                alternativesHTML += '<div class="grid grid-cols-1 md:grid-cols-2 gap-3">';
                
                // Higher time alternative
                if (currentConfig.alternativeHigher) {
                    const higherChannels = currentConfig.alternativeHigher.configs.filter(c => c !== null);
                    const higherTime = currentConfig.alternativeHigher.calculatedTime;
                    const channelsSummary = higherChannels.map((ch, idx) => {
                        const isPriority = selectedPriorityChannel !== 'equal' && idx === parseInt(selectedPriorityChannel);
                        return `${ch.channelName || 'CH'+(idx+1)}: ${ch.resolution || ch.preset}@${ch.fps}fps, ${ch.bitrate}M${isPriority ? ' 🎯' : ''}`;
                    }).join('<br>');
                    
                    alternativesHTML += '<div class="p-3 bg-white rounded-lg border border-green-300">' +
                        '<div class="text-xs font-semibold text-green-700 mb-2">' +
                        '<i class="fas fa-arrow-up mr-1"></i>' +
                        (currentLang === 'pt-BR' ? 'Mais Tempo' : 'More Time') +
                        '</div>' +
                        '<div class="text-sm font-bold text-gray-800 mb-2">' +
                        higherTime.toFixed(1) + ' ' + t('hours') +
                        ' <span class="text-xs text-gray-500">(' + (higherTime/24).toFixed(1) + 'd)</span>' +
                        '</div>' +
                        '<div class="text-xs text-gray-600">' + channelsSummary + '</div>' +
                        '</div>';
                }
                
                // Lower time alternative
                if (currentConfig.alternativeLower) {
                    const lowerChannels = currentConfig.alternativeLower.configs.filter(c => c !== null);
                    const lowerTime = currentConfig.alternativeLower.calculatedTime;
                    const channelsSummary = lowerChannels.map((ch, idx) => {
                        const isPriority = selectedPriorityChannel !== 'equal' && idx === parseInt(selectedPriorityChannel);
                        return `${ch.channelName || 'CH'+(idx+1)}: ${ch.resolution || ch.preset}@${ch.fps}fps, ${ch.bitrate}M${isPriority ? ' 🎯' : ''}`;
                    }).join('<br>');
                    
                    alternativesHTML += '<div class="p-3 bg-white rounded-lg border border-blue-300">' +
                        '<div class="text-xs font-semibold text-blue-700 mb-2">' +
                        '<i class="fas fa-arrow-down mr-1"></i>' +
                        (currentLang === 'pt-BR' ? 'Menos Tempo / Mais Qualidade' : 'Less Time / More Quality') +
                        '</div>' +
                        '<div class="text-sm font-bold text-gray-800 mb-2">' +
                        lowerTime.toFixed(1) + ' ' + t('hours') +
                        ' <span class="text-xs text-gray-500">(' + (lowerTime/24).toFixed(1) + 'd)</span>' +
                        '</div>' +
                        '<div class="text-xs text-gray-600">' + channelsSummary + '</div>' +
                        '</div>';
                }
                
                alternativesHTML += '</div></div></div>';
                alternativesBox.innerHTML = alternativesHTML;
                configSummaryDiv.appendChild(alternativesBox);
            }
        }
    }
    
    // Card info
    const cardInfo = document.createElement('div');
    cardInfo.className = 'flex items-center p-3 bg-white rounded-lg border border-gray-200';
    
    // Handle different result structures (JC450 vs other models)
    const availableSpace = results.sd1 
        ? results.sd1.availableSpaceMB + results.sd2.availableSpaceMB 
        : results.availableSpaceMB;
    const usablePercent = results.usablePercentage || 90;
    
    cardInfo.innerHTML = '<div class="flex-1">' +
        '<i class="fas fa-sd-card text-blue-500 mr-2"></i>' +
        '<strong>' + t('cardCapacity') + ':</strong> ' + results.cardSizeGB + ' GB' +
        (currentModel && currentModel.name === 'JC450' && !useOneCardOnly ? ' (cada cartão)' : '') +
        '</div>' +
        '<div class="text-sm text-gray-600">' +
        '<i class="fas fa-check-circle text-green-500 mr-1"></i>' +
        t('usableCapacity') + ': ' + (availableSpace ? availableSpace.toFixed(0) : '0') + ' MB (' + usablePercent.toFixed(0) + '%)' +
        '</div>';
    configSummaryDiv.appendChild(cardInfo);
    
    // 🔧 JC450 Dual Card Information
    if (currentModel && currentModel.name === 'JC450' && results.sd1 && results.sd2) {
        const dualCardInfo = document.createElement('div');
        dualCardInfo.className = 'mt-3 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-blue-400';
        dualCardInfo.innerHTML = 
            '<div class="flex items-start">' +
            '<i class="fas fa-hdd text-blue-600 text-2xl mr-3"></i>' +
            '<div class="flex-1">' +
            '<h4 class="font-bold text-blue-900 text-lg mb-3">' +
            '<i class="fas fa-server mr-2"></i>' +
            (currentLang === 'pt-BR' ? 'Configuração Dual Card (JC450)' : 'Dual Card Configuration (JC450)') +
            '</h4>' +
            
            // SD1 and SD2 side-by-side
            '<div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">' +
            
            // SD1 Card
            '<div class="bg-white rounded-lg p-3 border-2 ' + 
            (results.limitingCard === 'SD1' ? 'border-red-400' : 'border-gray-300') + '">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h5 class="font-bold text-gray-800">' +
            '<i class="fas fa-sd-card text-blue-600 mr-1"></i> SD1' +
            '</h5>' +
            (results.limitingCard === 'SD1' ? 
                '<span class="text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>LIMITANTE' +
                '</span>' : '') +
            '</div>' +
            '<div class="text-xs text-gray-600 mb-2">' +
            '<i class="fas fa-video mr-1"></i> ' + results.sd1.channels +
            '</div>' +
            '<div class="space-y-1 text-sm">' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Canais ativos:</span>' +
            '<span class="font-semibold">' + results.sd1.channelCount + '</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Bitrate total:</span>' +
            '<span class="font-semibold text-blue-700">' + results.sd1.totalBitrate.toFixed(1) + ' Mbps</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Consumo/hora:</span>' +
            '<span class="font-semibold">' + results.sd1.totalRateGBh.toFixed(2) + ' GB/h</span>' +
            '</div>' +
            '<div class="flex justify-between border-t border-gray-200 pt-1 mt-1">' +
            '<span class="text-gray-800 font-semibold">Tempo SD1:</span>' +
            '<span class="font-bold text-green-700">' + results.sd1.timeHours.toFixed(1) + ' h</span>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            // SD2 Card
            '<div class="bg-white rounded-lg p-3 border-2 ' + 
            (results.limitingCard === 'SD2' ? 'border-red-400' : 'border-gray-300') + '">' +
            '<div class="flex items-center justify-between mb-2">' +
            '<h5 class="font-bold text-gray-800">' +
            '<i class="fas fa-sd-card text-purple-600 mr-1"></i> SD2' +
            '</h5>' +
            (results.limitingCard === 'SD2' ? 
                '<span class="text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>LIMITANTE' +
                '</span>' : '') +
            '</div>' +
            '<div class="text-xs text-gray-600 mb-2">' +
            '<i class="fas fa-video mr-1"></i> ' + results.sd2.channels +
            '</div>' +
            '<div class="space-y-1 text-sm">' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Canais ativos:</span>' +
            '<span class="font-semibold">' + results.sd2.channelCount + '</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Bitrate total:</span>' +
            '<span class="font-semibold text-purple-700">' + results.sd2.totalBitrate.toFixed(1) + ' Mbps</span>' +
            '</div>' +
            '<div class="flex justify-between">' +
            '<span class="text-gray-600">Consumo/hora:</span>' +
            '<span class="font-semibold">' + results.sd2.totalRateGBh.toFixed(2) + ' GB/h</span>' +
            '</div>' +
            '<div class="flex justify-between border-t border-gray-200 pt-1 mt-1">' +
            '<span class="text-gray-800 font-semibold">Tempo SD2:</span>' +
            '<span class="font-bold text-green-700">' + results.sd2.timeHours.toFixed(1) + ' h</span>' +
            '</div>' +
            '</div>' +
            '</div>' +
            
            '</div>' +
            
            // System totals
            '<div class="bg-gradient-to-r from-gray-100 to-gray-50 rounded-lg p-3 border border-gray-300 mb-3">' +
            '<div class="grid grid-cols-2 gap-3 text-sm">' +
            '<div>' +
            '<div class="text-gray-600 text-xs mb-1">Total Sistema:</div>' +
            '<div class="font-bold text-lg text-gray-900">' + results.totalBitrate.toFixed(1) + ' Mbps</div>' +
            '</div>' +
            '<div>' +
            '<div class="text-gray-600 text-xs mb-1">Consumo Total:</div>' +
            '<div class="font-bold text-lg text-gray-900">' + results.totalRateGBh.toFixed(2) + ' GB/h</div>' +
            '</div>' +
            '</div>' +
            (results.bitrateWarning ? 
                '<div class="mt-2 p-2 bg-red-100 border border-red-300 rounded text-xs text-red-800">' +
                '<i class="fas fa-exclamation-triangle mr-1"></i>' + results.bitrateWarning +
                '</div>' : '') +
            '</div>' +
            
            // Important note
            '<div class="bg-yellow-50 border-l-4 border-yellow-400 p-3 rounded">' +
            '<div class="flex items-start">' +
            '<i class="fas fa-info-circle text-yellow-600 mr-2 mt-0.5"></i>' +
            '<div class="text-xs text-gray-700">' +
            '<strong>' + (currentLang === 'pt-BR' ? 'Importante:' : 'Important:') + '</strong> ' +
            (results.note || 'O JC450 usa dois cartões SD independentes. O tempo total é limitado pelo cartão que enche primeiro.') +
            '</div>' +
            '</div>' +
            '</div>' +
            
            '</div>' +
            '</div>';
        
        configSummaryDiv.appendChild(dualCardInfo);
    }
    
    // 🔧 Realistic Calculation Info Box
    if (results.realisticCorrections && results.variationRange) {
        const realisticInfoBox = document.createElement('div');
        realisticInfoBox.className = 'mt-3 p-4 bg-gradient-to-r from-green-50 to-emerald-50 rounded-lg border-2 border-green-300';
        realisticInfoBox.innerHTML = '<div class="flex items-start">' +
            '<i class="fas fa-check-double text-green-600 text-xl mr-3"></i>' +
            '<div class="flex-1">' +
            '<h4 class="font-bold text-green-800 mb-2">' +
            '<i class="fas fa-chart-line mr-2"></i>' +
            'Estimativa com Fatores Realistas' +
            '</h4>' +
            '<div class="text-sm text-gray-700 mb-2">' +
            'O cálculo foi ajustado com base em <strong>gravações reais</strong>, incluindo:' +
            '</div>' +
            '<ul class="text-xs text-gray-600 space-y-1 mb-3">' +
            '<li><i class="fas fa-plus-circle text-green-600 mr-1"></i> +3% Overhead do container .TS (cabeçalhos e índices)</li>' +
            '<li><i class="fas fa-plus-circle text-green-600 mr-1"></i> +1% Áudio embutido (64-128 kbps)</li>' +
            '<li><i class="fas fa-plus-circle text-green-600 mr-1"></i> +2% Variação VBR (bitrate variável)</li>' +
            '<li><i class="fas fa-plus-circle text-green-600 mr-1"></i> +2% Sistema de arquivos (blocos de 32-64 KB)</li>' +
            '</ul>' +
            '<div class="p-3 bg-white rounded-lg border border-green-200">' +
            '<div class="text-sm font-semibold text-gray-800 mb-1">' +
            '<i class="fas fa-hourglass-half text-blue-600 mr-1"></i> Faixa de Tempo Estimada:' +
            '</div>' +
            '<div class="text-lg font-bold text-green-700">' +
            results.estimatedTimeRange.min.toFixed(1) + ' - ' + 
            results.estimatedTimeRange.max.toFixed(1) + ' horas' +
            '</div>' +
            '<div class="text-xs text-gray-500 mt-1">' +
            '(' + results.estimatedTimeRange.minDays.toFixed(2) + ' - ' + 
            results.estimatedTimeRange.maxDays.toFixed(2) + ' dias) ' +
            '±' + results.variationRange.margin.toFixed(0) + '%' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>';
        configSummaryDiv.appendChild(realisticInfoBox);
    }
    
    // Channels info
    const channelsDiv = document.createElement('div');
    channelsDiv.className = 'mt-3 space-y-2';
    
    const channelHeader = document.createElement('div');
    channelHeader.className = 'font-bold text-gray-700 mb-2';
    channelHeader.innerHTML = '<i class="fas fa-video text-blue-500 mr-2"></i>' + 
        t('activeChannelsCount') + ': ' + results.activeChannels;
    channelsDiv.appendChild(channelHeader);
    
    // Collect bitrate warnings
    const bitrateWarnings = [];
    
    results.channelResults.forEach((channel, index) => {
        // Check if this channel is prioritized
        const isPrioritized = selectedPriorityChannel !== 'equal' && index === parseInt(selectedPriorityChannel);
        
        const channelItem = document.createElement('div');
        channelItem.className = 'flex items-center justify-between p-3 rounded-lg border ' +
            (isPrioritized 
                ? 'bg-gradient-to-r from-amber-50 to-yellow-50 border-2 border-amber-400 shadow-md' 
                : 'bg-white border-gray-200');
        
        // Calculate individual channel consumption (using effective bitrate for realistic estimate)
        const effectiveBitrateForCalc = channel.effectiveBitrate || channel.bitrate;
        const channelConsumption = (effectiveBitrateForCalc * 450 * results.totalTimeHours / 1000).toFixed(2);
        
        // Validate bitrate against model specification
        const modelId = currentModel ? currentModel.name.toLowerCase().replace(/[^a-z0-9]/g, '') : 'jc181';
        const validation = calculator.validateBitrate(channel.bitrate, modelId, channel.resolution);
        
        // Add warning if bitrate is out of range
        if (!validation.valid && validation.warning) {
            bitrateWarnings.push({
                channel: channel.channelName,
                warning: validation.warning,
                range: validation.range
            });
        }
        
        // Build correction info tooltip
        let correctionInfo = '';
        if (channel.correctionFactor && channel.correctionFactor !== 1.0) {
            correctionInfo = ' <span class="text-xs text-green-700" title="Fator de correção aplicado: ' + 
                channel.correctionFactor.toFixed(2) + 'x (inclui overhead real)">' +
                '[×' + channel.correctionFactor.toFixed(2) + ']</span>';
        }
        
        channelItem.innerHTML = '<div class="flex-1">' +
            (isPrioritized ? '<div class="inline-block px-2 py-0.5 bg-amber-500 text-white text-xs font-bold rounded-full mb-1"><i class="fas fa-star mr-1"></i>PRIORIDADE</div><br>' : '') +
            '<span class="font-medium text-gray-800">' + channel.channelName + '</span>: ' +
            '<span class="text-gray-600' + (isPrioritized ? ' font-semibold' : '') + '">' + 
            channel.resolution + 'P @ ' + channel.fps + 'fps, ' + 
            '<span class="' + (isPrioritized ? 'text-amber-700 font-bold text-lg' : '') + '">' + 
            channel.bitrate + ' Mbps</span> (' + channel.codec + ')' + correctionInfo +
            '</span>' +
            (!validation.valid ? '<div class="text-xs text-orange-600 mt-1"><i class="fas fa-exclamation-triangle mr-1"></i>' + validation.warning + '</div>' : '') +
            '</div>' +
            '<div class="text-xs text-gray-500 ml-3">' +
            '<i class="fas fa-database mr-1"></i>' +
            channelConsumption + ' GB' +
            '</div>';
        channelsDiv.appendChild(channelItem);
    });
    
    configSummaryDiv.appendChild(channelsDiv);
    
    // Display bitrate warnings summary if any
    if (bitrateWarnings.length > 0) {
        const warningsBox = document.createElement('div');
        warningsBox.className = 'mt-3 p-4 bg-orange-50 border-2 border-orange-300 rounded-lg';
        warningsBox.innerHTML = '<div class="flex items-start">' +
            '<i class="fas fa-exclamation-triangle text-orange-600 text-xl mr-3"></i>' +
            '<div class="flex-1">' +
            '<h4 class="font-bold text-orange-800 mb-2">' +
            (currentLang === 'pt-BR' ? '⚠️ Avisos de Bitrate' : '⚠️ Bitrate Warnings') +
            '</h4>' +
            '<div class="text-sm text-orange-700 space-y-1">' +
            bitrateWarnings.map(w => 
                '<div><strong>' + w.channel + ':</strong> ' + w.warning + '</div>'
            ).join('') +
            '</div>' +
            '</div>' +
            '</div>';
        configSummaryDiv.appendChild(warningsBox);
    }
    
    // Total consumption summary
    const totalConsumption = results.channelResults.reduce((sum, ch) => 
        sum + (ch.bitrate * 450 * results.totalTimeHours / 1000), 0);
    
    const consumptionSummary = document.createElement('div');
    consumptionSummary.className = 'mt-3 p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200';
    consumptionSummary.innerHTML = '<div class="flex items-center justify-between">' +
        '<div>' +
        '<i class="fas fa-chart-pie text-purple-600 mr-2"></i>' +
        '<strong class="text-gray-800">' + (currentLang === 'pt-BR' ? 'Consumo Total:' : 'Total Consumption:') + '</strong>' +
        '</div>' +
        '<div class="text-right">' +
        '<div class="font-bold text-purple-700 text-lg">' + totalConsumption.toFixed(2) + ' GB</div>' +
        '<div class="text-xs text-gray-600">' + 
        (currentLang === 'pt-BR' ? 'Taxa média: ' : 'Average rate: ') +
        (totalConsumption * 1000 / results.totalTimeHours).toFixed(0) + ' MB/h' +
        '</div>' +
        '</div>' +
        '</div>';
    configSummaryDiv.appendChild(consumptionSummary);
    
    // ⚠️ Important Notice about Estimate Accuracy
    const accuracyNotice = document.createElement('div');
    accuracyNotice.className = 'mt-4 p-4 bg-blue-50 rounded-lg border-2 border-blue-300';
    accuracyNotice.innerHTML = '<div class="flex items-start">' +
        '<i class="fas fa-info-circle text-blue-600 text-xl mr-3 mt-1"></i>' +
        '<div class="flex-1">' +
        '<h4 class="font-bold text-blue-800 mb-2">' +
        '<i class="fas fa-lightbulb mr-2"></i>' +
        'Sobre a Precisão desta Estimativa' +
        '</h4>' +
        '<div class="text-sm text-gray-700 space-y-2">' +
        '<p>' +
        '<strong>✅ Este resultado é uma estimativa aprimorada</strong>, ajustada com base em <strong>testes reais de gravação</strong> ' +
        '(como arquivos .TS da JC400 em 1080P@8Mbps@25fps).' +
        '</p>' +
        '<p class="text-xs text-gray-600">' +
        '<i class="fas fa-chart-line text-blue-500 mr-1"></i> ' +
        '<strong>Variação esperada: ±' + (results.variationRange?.margin || 10).toFixed(0) + '%</strong> ' +
        'devido a fatores como:' +
        '</p>' +
        '<ul class="text-xs text-gray-600 ml-4 space-y-1">' +
        '<li>• <strong>Codificação variável (VBR)</strong>: bitrate real varia conforme movimento na cena</li>' +
        '<li>• <strong>Overhead do formato .TS</strong>: cabeçalhos e metadados de sincronização</li>' +
        '<li>• <strong>Áudio embutido</strong>: 64-128 kbps adicional por canal</li>' +
        '<li>• <strong>Sistema de arquivos</strong>: fragmentação e espaço desperdiçado em blocos</li>' +
        '<li>• <strong>Condições de gravação</strong>: luz, movimento, ruído e complexidade da cena</li>' +
        '</ul>' +
        '<div class="mt-3 p-3 bg-white rounded border border-blue-200">' +
        '<p class="text-sm font-semibold text-blue-800">' +
        '<i class="fas fa-flask text-purple-600 mr-1"></i> ' +
        '💡 Dica para Máxima Precisão:' +
        '</p>' +
        '<p class="text-xs text-gray-600 mt-1">' +
        'Valide com gravações reais no equipamento e compare o consumo médio por hora. ' +
        'Diferenças de até ±10% são normais e esperadas.' +
        '</p>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>';
    configSummaryDiv.appendChild(accuracyNotice);
    
    // Update command display
    updateCommandDisplay();
}

// Update Command Display
function updateCommandDisplay() {
    console.log('🔧 updateCommandDisplay called');
    console.log('   currentConfig:', currentConfig);
    console.log('   currentModel:', currentModel);
    
    if (!currentConfig) {
        console.warn('⚠️ No currentConfig available');
        return;
    }
    
    const commandDiv = document.getElementById('commandDisplay');
    const commands = currentModel.commandFormat(currentConfig);
    
    console.log('   Generated commands:', commands);
    
    commandDiv.innerHTML = commands.split('\n').map(function(cmd) {
        return '<div class="mb-1">' + cmd + '</div>';
    }).join('');
}

// Reset Calculator
function resetCalculator() {
    currentModel = null;
    currentConfig = null;
    
    modelCards.forEach(card => card.classList.remove('active'));
    configSection.classList.add('hidden');
    resultsSection.classList.add('hidden');
    
    // Hide recommended section
    if (recommendedSection) {
        recommendedSection.classList.add('hidden');
    }
    
    if (recordingChart) {
        recordingChart.destroy();
        recordingChart = null;
    }
    
    localStorage.removeItem('dvrCalculatorState');
}

// State Management
function saveState() {
    if (!currentModel) return;
    
    const state = {
        modelName: currentModel.name,
        cardSize: cardSizeSelect.value,
        activeChannels: activeChannels
    };
    
    localStorage.setItem('dvrCalculatorState', JSON.stringify(state));
}

function loadSavedState() {
    const savedState = localStorage.getItem('dvrCalculatorState');
    if (savedState) {
        try {
            const state = JSON.parse(savedState);
            if (state.modelName && isValidModel(state.modelName)) {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    selectModel(state.modelName);
                    if (state.cardSize && cardSizeSelect) {
                        cardSizeSelect.value = state.cardSize;
                    }
                    if (state.activeChannels) {
                        activeChannels = state.activeChannels;
                    }
                    if (currentModel) {
                        updateChannelConfig();
                    }
                }, 100);
            }
        } catch (e) {
            console.error('Error loading saved state:', e);
            // Clear invalid state
            localStorage.removeItem('dvrCalculatorState');
        }
    }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', init);

